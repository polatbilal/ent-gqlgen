// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobauthor"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobdetail"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/predicate"
)

// JobAuthorUpdate is the builder for updating JobAuthor entities.
type JobAuthorUpdate struct {
	config
	hooks    []Hook
	mutation *JobAuthorMutation
}

// Where appends a list predicates to the JobAuthorUpdate builder.
func (jau *JobAuthorUpdate) Where(ps ...predicate.JobAuthor) *JobAuthorUpdate {
	jau.mutation.Where(ps...)
	return jau
}

// SetStatic sets the "Static" field.
func (jau *JobAuthorUpdate) SetStatic(s string) *JobAuthorUpdate {
	jau.mutation.SetStatic(s)
	return jau
}

// SetNillableStatic sets the "Static" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableStatic(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetStatic(*s)
	}
	return jau
}

// ClearStatic clears the value of the "Static" field.
func (jau *JobAuthorUpdate) ClearStatic() *JobAuthorUpdate {
	jau.mutation.ClearStatic()
	return jau
}

// SetMechanic sets the "Mechanic" field.
func (jau *JobAuthorUpdate) SetMechanic(s string) *JobAuthorUpdate {
	jau.mutation.SetMechanic(s)
	return jau
}

// SetNillableMechanic sets the "Mechanic" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableMechanic(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetMechanic(*s)
	}
	return jau
}

// ClearMechanic clears the value of the "Mechanic" field.
func (jau *JobAuthorUpdate) ClearMechanic() *JobAuthorUpdate {
	jau.mutation.ClearMechanic()
	return jau
}

// SetElectric sets the "Electric" field.
func (jau *JobAuthorUpdate) SetElectric(s string) *JobAuthorUpdate {
	jau.mutation.SetElectric(s)
	return jau
}

// SetNillableElectric sets the "Electric" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableElectric(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetElectric(*s)
	}
	return jau
}

// ClearElectric clears the value of the "Electric" field.
func (jau *JobAuthorUpdate) ClearElectric() *JobAuthorUpdate {
	jau.mutation.ClearElectric()
	return jau
}

// SetArchitect sets the "Architect" field.
func (jau *JobAuthorUpdate) SetArchitect(s string) *JobAuthorUpdate {
	jau.mutation.SetArchitect(s)
	return jau
}

// SetNillableArchitect sets the "Architect" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableArchitect(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetArchitect(*s)
	}
	return jau
}

// ClearArchitect clears the value of the "Architect" field.
func (jau *JobAuthorUpdate) ClearArchitect() *JobAuthorUpdate {
	jau.mutation.ClearArchitect()
	return jau
}

// SetGeotechnicalEngineer sets the "GeotechnicalEngineer" field.
func (jau *JobAuthorUpdate) SetGeotechnicalEngineer(s string) *JobAuthorUpdate {
	jau.mutation.SetGeotechnicalEngineer(s)
	return jau
}

// SetNillableGeotechnicalEngineer sets the "GeotechnicalEngineer" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableGeotechnicalEngineer(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetGeotechnicalEngineer(*s)
	}
	return jau
}

// ClearGeotechnicalEngineer clears the value of the "GeotechnicalEngineer" field.
func (jau *JobAuthorUpdate) ClearGeotechnicalEngineer() *JobAuthorUpdate {
	jau.mutation.ClearGeotechnicalEngineer()
	return jau
}

// SetGeotechnicalGeologist sets the "GeotechnicalGeologist" field.
func (jau *JobAuthorUpdate) SetGeotechnicalGeologist(s string) *JobAuthorUpdate {
	jau.mutation.SetGeotechnicalGeologist(s)
	return jau
}

// SetNillableGeotechnicalGeologist sets the "GeotechnicalGeologist" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableGeotechnicalGeologist(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetGeotechnicalGeologist(*s)
	}
	return jau
}

// ClearGeotechnicalGeologist clears the value of the "GeotechnicalGeologist" field.
func (jau *JobAuthorUpdate) ClearGeotechnicalGeologist() *JobAuthorUpdate {
	jau.mutation.ClearGeotechnicalGeologist()
	return jau
}

// SetGeotechnicalGeophysicist sets the "GeotechnicalGeophysicist" field.
func (jau *JobAuthorUpdate) SetGeotechnicalGeophysicist(s string) *JobAuthorUpdate {
	jau.mutation.SetGeotechnicalGeophysicist(s)
	return jau
}

// SetNillableGeotechnicalGeophysicist sets the "GeotechnicalGeophysicist" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableGeotechnicalGeophysicist(s *string) *JobAuthorUpdate {
	if s != nil {
		jau.SetGeotechnicalGeophysicist(*s)
	}
	return jau
}

// ClearGeotechnicalGeophysicist clears the value of the "GeotechnicalGeophysicist" field.
func (jau *JobAuthorUpdate) ClearGeotechnicalGeophysicist() *JobAuthorUpdate {
	jau.mutation.ClearGeotechnicalGeophysicist()
	return jau
}

// SetCreatedAt sets the "CreatedAt" field.
func (jau *JobAuthorUpdate) SetCreatedAt(t time.Time) *JobAuthorUpdate {
	jau.mutation.SetCreatedAt(t)
	return jau
}

// SetNillableCreatedAt sets the "CreatedAt" field if the given value is not nil.
func (jau *JobAuthorUpdate) SetNillableCreatedAt(t *time.Time) *JobAuthorUpdate {
	if t != nil {
		jau.SetCreatedAt(*t)
	}
	return jau
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (jau *JobAuthorUpdate) SetUpdatedAt(t time.Time) *JobAuthorUpdate {
	jau.mutation.SetUpdatedAt(t)
	return jau
}

// AddAuthorIDs adds the "authors" edge to the JobDetail entity by IDs.
func (jau *JobAuthorUpdate) AddAuthorIDs(ids ...int) *JobAuthorUpdate {
	jau.mutation.AddAuthorIDs(ids...)
	return jau
}

// AddAuthors adds the "authors" edges to the JobDetail entity.
func (jau *JobAuthorUpdate) AddAuthors(j ...*JobDetail) *JobAuthorUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jau.AddAuthorIDs(ids...)
}

// Mutation returns the JobAuthorMutation object of the builder.
func (jau *JobAuthorUpdate) Mutation() *JobAuthorMutation {
	return jau.mutation
}

// ClearAuthors clears all "authors" edges to the JobDetail entity.
func (jau *JobAuthorUpdate) ClearAuthors() *JobAuthorUpdate {
	jau.mutation.ClearAuthors()
	return jau
}

// RemoveAuthorIDs removes the "authors" edge to JobDetail entities by IDs.
func (jau *JobAuthorUpdate) RemoveAuthorIDs(ids ...int) *JobAuthorUpdate {
	jau.mutation.RemoveAuthorIDs(ids...)
	return jau
}

// RemoveAuthors removes "authors" edges to JobDetail entities.
func (jau *JobAuthorUpdate) RemoveAuthors(j ...*JobDetail) *JobAuthorUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jau.RemoveAuthorIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (jau *JobAuthorUpdate) Save(ctx context.Context) (int, error) {
	jau.defaults()
	return withHooks(ctx, jau.sqlSave, jau.mutation, jau.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (jau *JobAuthorUpdate) SaveX(ctx context.Context) int {
	affected, err := jau.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (jau *JobAuthorUpdate) Exec(ctx context.Context) error {
	_, err := jau.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (jau *JobAuthorUpdate) ExecX(ctx context.Context) {
	if err := jau.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (jau *JobAuthorUpdate) defaults() {
	if _, ok := jau.mutation.UpdatedAt(); !ok {
		v := jobauthor.UpdateDefaultUpdatedAt()
		jau.mutation.SetUpdatedAt(v)
	}
}

func (jau *JobAuthorUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(jobauthor.Table, jobauthor.Columns, sqlgraph.NewFieldSpec(jobauthor.FieldID, field.TypeInt))
	if ps := jau.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := jau.mutation.Static(); ok {
		_spec.SetField(jobauthor.FieldStatic, field.TypeString, value)
	}
	if jau.mutation.StaticCleared() {
		_spec.ClearField(jobauthor.FieldStatic, field.TypeString)
	}
	if value, ok := jau.mutation.Mechanic(); ok {
		_spec.SetField(jobauthor.FieldMechanic, field.TypeString, value)
	}
	if jau.mutation.MechanicCleared() {
		_spec.ClearField(jobauthor.FieldMechanic, field.TypeString)
	}
	if value, ok := jau.mutation.Electric(); ok {
		_spec.SetField(jobauthor.FieldElectric, field.TypeString, value)
	}
	if jau.mutation.ElectricCleared() {
		_spec.ClearField(jobauthor.FieldElectric, field.TypeString)
	}
	if value, ok := jau.mutation.Architect(); ok {
		_spec.SetField(jobauthor.FieldArchitect, field.TypeString, value)
	}
	if jau.mutation.ArchitectCleared() {
		_spec.ClearField(jobauthor.FieldArchitect, field.TypeString)
	}
	if value, ok := jau.mutation.GeotechnicalEngineer(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalEngineer, field.TypeString, value)
	}
	if jau.mutation.GeotechnicalEngineerCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalEngineer, field.TypeString)
	}
	if value, ok := jau.mutation.GeotechnicalGeologist(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalGeologist, field.TypeString, value)
	}
	if jau.mutation.GeotechnicalGeologistCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalGeologist, field.TypeString)
	}
	if value, ok := jau.mutation.GeotechnicalGeophysicist(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalGeophysicist, field.TypeString, value)
	}
	if jau.mutation.GeotechnicalGeophysicistCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalGeophysicist, field.TypeString)
	}
	if value, ok := jau.mutation.CreatedAt(); ok {
		_spec.SetField(jobauthor.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := jau.mutation.UpdatedAt(); ok {
		_spec.SetField(jobauthor.FieldUpdatedAt, field.TypeTime, value)
	}
	if jau.mutation.AuthorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := jau.mutation.RemovedAuthorsIDs(); len(nodes) > 0 && !jau.mutation.AuthorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := jau.mutation.AuthorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, jau.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{jobauthor.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	jau.mutation.done = true
	return n, nil
}

// JobAuthorUpdateOne is the builder for updating a single JobAuthor entity.
type JobAuthorUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *JobAuthorMutation
}

// SetStatic sets the "Static" field.
func (jauo *JobAuthorUpdateOne) SetStatic(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetStatic(s)
	return jauo
}

// SetNillableStatic sets the "Static" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableStatic(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetStatic(*s)
	}
	return jauo
}

// ClearStatic clears the value of the "Static" field.
func (jauo *JobAuthorUpdateOne) ClearStatic() *JobAuthorUpdateOne {
	jauo.mutation.ClearStatic()
	return jauo
}

// SetMechanic sets the "Mechanic" field.
func (jauo *JobAuthorUpdateOne) SetMechanic(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetMechanic(s)
	return jauo
}

// SetNillableMechanic sets the "Mechanic" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableMechanic(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetMechanic(*s)
	}
	return jauo
}

// ClearMechanic clears the value of the "Mechanic" field.
func (jauo *JobAuthorUpdateOne) ClearMechanic() *JobAuthorUpdateOne {
	jauo.mutation.ClearMechanic()
	return jauo
}

// SetElectric sets the "Electric" field.
func (jauo *JobAuthorUpdateOne) SetElectric(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetElectric(s)
	return jauo
}

// SetNillableElectric sets the "Electric" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableElectric(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetElectric(*s)
	}
	return jauo
}

// ClearElectric clears the value of the "Electric" field.
func (jauo *JobAuthorUpdateOne) ClearElectric() *JobAuthorUpdateOne {
	jauo.mutation.ClearElectric()
	return jauo
}

// SetArchitect sets the "Architect" field.
func (jauo *JobAuthorUpdateOne) SetArchitect(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetArchitect(s)
	return jauo
}

// SetNillableArchitect sets the "Architect" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableArchitect(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetArchitect(*s)
	}
	return jauo
}

// ClearArchitect clears the value of the "Architect" field.
func (jauo *JobAuthorUpdateOne) ClearArchitect() *JobAuthorUpdateOne {
	jauo.mutation.ClearArchitect()
	return jauo
}

// SetGeotechnicalEngineer sets the "GeotechnicalEngineer" field.
func (jauo *JobAuthorUpdateOne) SetGeotechnicalEngineer(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetGeotechnicalEngineer(s)
	return jauo
}

// SetNillableGeotechnicalEngineer sets the "GeotechnicalEngineer" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableGeotechnicalEngineer(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetGeotechnicalEngineer(*s)
	}
	return jauo
}

// ClearGeotechnicalEngineer clears the value of the "GeotechnicalEngineer" field.
func (jauo *JobAuthorUpdateOne) ClearGeotechnicalEngineer() *JobAuthorUpdateOne {
	jauo.mutation.ClearGeotechnicalEngineer()
	return jauo
}

// SetGeotechnicalGeologist sets the "GeotechnicalGeologist" field.
func (jauo *JobAuthorUpdateOne) SetGeotechnicalGeologist(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetGeotechnicalGeologist(s)
	return jauo
}

// SetNillableGeotechnicalGeologist sets the "GeotechnicalGeologist" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableGeotechnicalGeologist(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetGeotechnicalGeologist(*s)
	}
	return jauo
}

// ClearGeotechnicalGeologist clears the value of the "GeotechnicalGeologist" field.
func (jauo *JobAuthorUpdateOne) ClearGeotechnicalGeologist() *JobAuthorUpdateOne {
	jauo.mutation.ClearGeotechnicalGeologist()
	return jauo
}

// SetGeotechnicalGeophysicist sets the "GeotechnicalGeophysicist" field.
func (jauo *JobAuthorUpdateOne) SetGeotechnicalGeophysicist(s string) *JobAuthorUpdateOne {
	jauo.mutation.SetGeotechnicalGeophysicist(s)
	return jauo
}

// SetNillableGeotechnicalGeophysicist sets the "GeotechnicalGeophysicist" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableGeotechnicalGeophysicist(s *string) *JobAuthorUpdateOne {
	if s != nil {
		jauo.SetGeotechnicalGeophysicist(*s)
	}
	return jauo
}

// ClearGeotechnicalGeophysicist clears the value of the "GeotechnicalGeophysicist" field.
func (jauo *JobAuthorUpdateOne) ClearGeotechnicalGeophysicist() *JobAuthorUpdateOne {
	jauo.mutation.ClearGeotechnicalGeophysicist()
	return jauo
}

// SetCreatedAt sets the "CreatedAt" field.
func (jauo *JobAuthorUpdateOne) SetCreatedAt(t time.Time) *JobAuthorUpdateOne {
	jauo.mutation.SetCreatedAt(t)
	return jauo
}

// SetNillableCreatedAt sets the "CreatedAt" field if the given value is not nil.
func (jauo *JobAuthorUpdateOne) SetNillableCreatedAt(t *time.Time) *JobAuthorUpdateOne {
	if t != nil {
		jauo.SetCreatedAt(*t)
	}
	return jauo
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (jauo *JobAuthorUpdateOne) SetUpdatedAt(t time.Time) *JobAuthorUpdateOne {
	jauo.mutation.SetUpdatedAt(t)
	return jauo
}

// AddAuthorIDs adds the "authors" edge to the JobDetail entity by IDs.
func (jauo *JobAuthorUpdateOne) AddAuthorIDs(ids ...int) *JobAuthorUpdateOne {
	jauo.mutation.AddAuthorIDs(ids...)
	return jauo
}

// AddAuthors adds the "authors" edges to the JobDetail entity.
func (jauo *JobAuthorUpdateOne) AddAuthors(j ...*JobDetail) *JobAuthorUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jauo.AddAuthorIDs(ids...)
}

// Mutation returns the JobAuthorMutation object of the builder.
func (jauo *JobAuthorUpdateOne) Mutation() *JobAuthorMutation {
	return jauo.mutation
}

// ClearAuthors clears all "authors" edges to the JobDetail entity.
func (jauo *JobAuthorUpdateOne) ClearAuthors() *JobAuthorUpdateOne {
	jauo.mutation.ClearAuthors()
	return jauo
}

// RemoveAuthorIDs removes the "authors" edge to JobDetail entities by IDs.
func (jauo *JobAuthorUpdateOne) RemoveAuthorIDs(ids ...int) *JobAuthorUpdateOne {
	jauo.mutation.RemoveAuthorIDs(ids...)
	return jauo
}

// RemoveAuthors removes "authors" edges to JobDetail entities.
func (jauo *JobAuthorUpdateOne) RemoveAuthors(j ...*JobDetail) *JobAuthorUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return jauo.RemoveAuthorIDs(ids...)
}

// Where appends a list predicates to the JobAuthorUpdate builder.
func (jauo *JobAuthorUpdateOne) Where(ps ...predicate.JobAuthor) *JobAuthorUpdateOne {
	jauo.mutation.Where(ps...)
	return jauo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (jauo *JobAuthorUpdateOne) Select(field string, fields ...string) *JobAuthorUpdateOne {
	jauo.fields = append([]string{field}, fields...)
	return jauo
}

// Save executes the query and returns the updated JobAuthor entity.
func (jauo *JobAuthorUpdateOne) Save(ctx context.Context) (*JobAuthor, error) {
	jauo.defaults()
	return withHooks(ctx, jauo.sqlSave, jauo.mutation, jauo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (jauo *JobAuthorUpdateOne) SaveX(ctx context.Context) *JobAuthor {
	node, err := jauo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (jauo *JobAuthorUpdateOne) Exec(ctx context.Context) error {
	_, err := jauo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (jauo *JobAuthorUpdateOne) ExecX(ctx context.Context) {
	if err := jauo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (jauo *JobAuthorUpdateOne) defaults() {
	if _, ok := jauo.mutation.UpdatedAt(); !ok {
		v := jobauthor.UpdateDefaultUpdatedAt()
		jauo.mutation.SetUpdatedAt(v)
	}
}

func (jauo *JobAuthorUpdateOne) sqlSave(ctx context.Context) (_node *JobAuthor, err error) {
	_spec := sqlgraph.NewUpdateSpec(jobauthor.Table, jobauthor.Columns, sqlgraph.NewFieldSpec(jobauthor.FieldID, field.TypeInt))
	id, ok := jauo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "JobAuthor.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := jauo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, jobauthor.FieldID)
		for _, f := range fields {
			if !jobauthor.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != jobauthor.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := jauo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := jauo.mutation.Static(); ok {
		_spec.SetField(jobauthor.FieldStatic, field.TypeString, value)
	}
	if jauo.mutation.StaticCleared() {
		_spec.ClearField(jobauthor.FieldStatic, field.TypeString)
	}
	if value, ok := jauo.mutation.Mechanic(); ok {
		_spec.SetField(jobauthor.FieldMechanic, field.TypeString, value)
	}
	if jauo.mutation.MechanicCleared() {
		_spec.ClearField(jobauthor.FieldMechanic, field.TypeString)
	}
	if value, ok := jauo.mutation.Electric(); ok {
		_spec.SetField(jobauthor.FieldElectric, field.TypeString, value)
	}
	if jauo.mutation.ElectricCleared() {
		_spec.ClearField(jobauthor.FieldElectric, field.TypeString)
	}
	if value, ok := jauo.mutation.Architect(); ok {
		_spec.SetField(jobauthor.FieldArchitect, field.TypeString, value)
	}
	if jauo.mutation.ArchitectCleared() {
		_spec.ClearField(jobauthor.FieldArchitect, field.TypeString)
	}
	if value, ok := jauo.mutation.GeotechnicalEngineer(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalEngineer, field.TypeString, value)
	}
	if jauo.mutation.GeotechnicalEngineerCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalEngineer, field.TypeString)
	}
	if value, ok := jauo.mutation.GeotechnicalGeologist(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalGeologist, field.TypeString, value)
	}
	if jauo.mutation.GeotechnicalGeologistCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalGeologist, field.TypeString)
	}
	if value, ok := jauo.mutation.GeotechnicalGeophysicist(); ok {
		_spec.SetField(jobauthor.FieldGeotechnicalGeophysicist, field.TypeString, value)
	}
	if jauo.mutation.GeotechnicalGeophysicistCleared() {
		_spec.ClearField(jobauthor.FieldGeotechnicalGeophysicist, field.TypeString)
	}
	if value, ok := jauo.mutation.CreatedAt(); ok {
		_spec.SetField(jobauthor.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := jauo.mutation.UpdatedAt(); ok {
		_spec.SetField(jobauthor.FieldUpdatedAt, field.TypeTime, value)
	}
	if jauo.mutation.AuthorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := jauo.mutation.RemovedAuthorsIDs(); len(nodes) > 0 && !jauo.mutation.AuthorsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := jauo.mutation.AuthorsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   jobauthor.AuthorsTable,
			Columns: []string{jobauthor.AuthorsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(jobdetail.FieldID, field.TypeInt),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &JobAuthor{config: jauo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, jauo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{jobauthor.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	jauo.mutation.done = true
	return _node, nil
}
