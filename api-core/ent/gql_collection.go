// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/companydetail"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/companyengineer"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/companytoken"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobauthor"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobcontractor"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobdetail"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/joblayer"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobowner"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobpayments"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobprogress"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobrelations"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/jobsupervisor"
	"github.com/polatbilal/gqlgen-ent/api-core/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cd *CompanyDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cd, nil
	}
	if err := cd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cd, nil
}

func (cd *CompanyDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companydetail.Columns))
		selectedFields = []string{companydetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "jobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			cd.WithNamedJobs(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			cd.WithNamedUsers(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})

		case "tokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyTokenClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companytokenImplementors)...); err != nil {
				return err
			}
			cd.WithNamedTokens(alias, func(wq *CompanyTokenQuery) {
				*wq = *query
			})

		case "engineers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			cd.WithNamedEngineers(alias, func(wq *CompanyEngineerQuery) {
				*wq = *query
			})
		case "companycode":
			if _, ok := fieldSeen[companydetail.FieldCompanyCode]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCompanyCode)
				fieldSeen[companydetail.FieldCompanyCode] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[companydetail.FieldName]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldName)
				fieldSeen[companydetail.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companydetail.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldAddress)
				fieldSeen[companydetail.FieldAddress] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companydetail.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldPhone)
				fieldSeen[companydetail.FieldPhone] = struct{}{}
			}
		case "fax":
			if _, ok := fieldSeen[companydetail.FieldFax]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldFax)
				fieldSeen[companydetail.FieldFax] = struct{}{}
			}
		case "mobilephone":
			if _, ok := fieldSeen[companydetail.FieldMobilePhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldMobilePhone)
				fieldSeen[companydetail.FieldMobilePhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companydetail.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldEmail)
				fieldSeen[companydetail.FieldEmail] = struct{}{}
			}
		case "website":
			if _, ok := fieldSeen[companydetail.FieldWebsite]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldWebsite)
				fieldSeen[companydetail.FieldWebsite] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[companydetail.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxAdmin)
				fieldSeen[companydetail.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[companydetail.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxNo)
				fieldSeen[companydetail.FieldTaxNo] = struct{}{}
			}
		case "chamberinfo":
			if _, ok := fieldSeen[companydetail.FieldChamberInfo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldChamberInfo)
				fieldSeen[companydetail.FieldChamberInfo] = struct{}{}
			}
		case "chamberregisterno":
			if _, ok := fieldSeen[companydetail.FieldChamberRegisterNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldChamberRegisterNo)
				fieldSeen[companydetail.FieldChamberRegisterNo] = struct{}{}
			}
		case "visadate":
			if _, ok := fieldSeen[companydetail.FieldVisaDate]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaDate)
				fieldSeen[companydetail.FieldVisaDate] = struct{}{}
			}
		case "visaenddate":
			if _, ok := fieldSeen[companydetail.FieldVisaEndDate]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaEndDate)
				fieldSeen[companydetail.FieldVisaEndDate] = struct{}{}
			}
		case "visafinishedfor90days":
			if _, ok := fieldSeen[companydetail.FieldVisaFinishedFor90Days]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaFinishedFor90Days)
				fieldSeen[companydetail.FieldVisaFinishedFor90Days] = struct{}{}
			}
		case "corepersonabsent90days":
			if _, ok := fieldSeen[companydetail.FieldCorePersonAbsent90Days]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCorePersonAbsent90Days)
				fieldSeen[companydetail.FieldCorePersonAbsent90Days] = struct{}{}
			}
		case "isclosed":
			if _, ok := fieldSeen[companydetail.FieldIsClosed]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldIsClosed)
				fieldSeen[companydetail.FieldIsClosed] = struct{}{}
			}
		case "ownername":
			if _, ok := fieldSeen[companydetail.FieldOwnerName]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerName)
				fieldSeen[companydetail.FieldOwnerName] = struct{}{}
			}
		case "ownertcno":
			if _, ok := fieldSeen[companydetail.FieldOwnerTcNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerTcNo)
				fieldSeen[companydetail.FieldOwnerTcNo] = struct{}{}
			}
		case "owneraddress":
			if _, ok := fieldSeen[companydetail.FieldOwnerAddress]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerAddress)
				fieldSeen[companydetail.FieldOwnerAddress] = struct{}{}
			}
		case "ownerphone":
			if _, ok := fieldSeen[companydetail.FieldOwnerPhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerPhone)
				fieldSeen[companydetail.FieldOwnerPhone] = struct{}{}
			}
		case "owneremail":
			if _, ok := fieldSeen[companydetail.FieldOwnerEmail]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerEmail)
				fieldSeen[companydetail.FieldOwnerEmail] = struct{}{}
			}
		case "ownerregisterno":
			if _, ok := fieldSeen[companydetail.FieldOwnerRegisterNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerRegisterNo)
				fieldSeen[companydetail.FieldOwnerRegisterNo] = struct{}{}
			}
		case "ownercareer":
			if _, ok := fieldSeen[companydetail.FieldOwnerCareer]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerCareer)
				fieldSeen[companydetail.FieldOwnerCareer] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companydetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCreatedAt)
				fieldSeen[companydetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companydetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldUpdatedAt)
				fieldSeen[companydetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cd.Select(selectedFields...)
	}
	return nil
}

type companydetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyDetailPaginateOption
}

func newCompanyDetailPaginateArgs(rv map[string]any) *companydetailPaginateArgs {
	args := &companydetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ce *CompanyEngineerQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyEngineerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ce, nil
	}
	if err := ce.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ce, nil
}

func (ce *CompanyEngineerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companyengineer.Columns))
		selectedFields = []string{companyengineer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ce.withCompany = query

		case "statics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedStatics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "mechanics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedMechanics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "electrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedElectrics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "inspectors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedInspectors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "architects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedArchitects(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "controllers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedControllers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "mechaniccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedMechaniccontrollers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "electriccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ce.WithNamedElectriccontrollers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[companyengineer.FieldName]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldName)
				fieldSeen[companyengineer.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[companyengineer.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldTcNo)
				fieldSeen[companyengineer.FieldTcNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companyengineer.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPhone)
				fieldSeen[companyengineer.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companyengineer.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmail)
				fieldSeen[companyengineer.FieldEmail] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companyengineer.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldAddress)
				fieldSeen[companyengineer.FieldAddress] = struct{}{}
			}
		case "career":
			if _, ok := fieldSeen[companyengineer.FieldCareer]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCareer)
				fieldSeen[companyengineer.FieldCareer] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[companyengineer.FieldPosition]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPosition)
				fieldSeen[companyengineer.FieldPosition] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[companyengineer.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldRegisterNo)
				fieldSeen[companyengineer.FieldRegisterNo] = struct{}{}
			}
		case "certno":
			if _, ok := fieldSeen[companyengineer.FieldCertNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCertNo)
				fieldSeen[companyengineer.FieldCertNo] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[companyengineer.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldYDSID)
				fieldSeen[companyengineer.FieldYDSID] = struct{}{}
			}
		case "employment":
			if _, ok := fieldSeen[companyengineer.FieldEmployment]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmployment)
				fieldSeen[companyengineer.FieldEmployment] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[companyengineer.FieldStatus]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldStatus)
				fieldSeen[companyengineer.FieldStatus] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[companyengineer.FieldNote]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldNote)
				fieldSeen[companyengineer.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companyengineer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCreatedAt)
				fieldSeen[companyengineer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companyengineer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldUpdatedAt)
				fieldSeen[companyengineer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ce.Select(selectedFields...)
	}
	return nil
}

type companyengineerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyEngineerPaginateOption
}

func newCompanyEngineerPaginateArgs(rv map[string]any) *companyengineerPaginateArgs {
	args := &companyengineerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ct *CompanyTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ct, nil
	}
	if err := ct.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ct, nil
}

func (ct *CompanyTokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companytoken.Columns))
		selectedFields = []string{companytoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ct.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ct.withCompany = query
		case "ydkusername":
			if _, ok := fieldSeen[companytoken.FieldYDKUsername]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldYDKUsername)
				fieldSeen[companytoken.FieldYDKUsername] = struct{}{}
			}
		case "ydkpassword":
			if _, ok := fieldSeen[companytoken.FieldYDKPassword]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldYDKPassword)
				fieldSeen[companytoken.FieldYDKPassword] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[companytoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldToken)
				fieldSeen[companytoken.FieldToken] = struct{}{}
			}
		case "departmentid":
			if _, ok := fieldSeen[companytoken.FieldDepartmentId]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldDepartmentId)
				fieldSeen[companytoken.FieldDepartmentId] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companytoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldCreatedAt)
				fieldSeen[companytoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companytoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldUpdatedAt)
				fieldSeen[companytoken.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ct.Select(selectedFields...)
	}
	return nil
}

type companytokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyTokenPaginateOption
}

func newCompanyTokenPaginateArgs(rv map[string]any) *companytokenPaginateArgs {
	args := &companytokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cu *CompanyUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cu, nil
	}
	if err := cu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cu, nil
}

func (cu *CompanyUserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			cu.withCompany = query

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			cu.withUser = query
		}
	}
	return nil
}

type companyuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyUserPaginateOption
}

func newCompanyUserPaginateArgs(rv map[string]any) *companyuserPaginateArgs {
	args := &companyuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ja *JobAuthorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobAuthorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ja, nil
	}
	if err := ja.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ja, nil
}

func (ja *JobAuthorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobauthor.Columns))
		selectedFields = []string{jobauthor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ja.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ja.WithNamedAuthors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobauthor.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldYibfNo)
				fieldSeen[jobauthor.FieldYibfNo] = struct{}{}
			}
		case "static":
			if _, ok := fieldSeen[jobauthor.FieldStatic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldStatic)
				fieldSeen[jobauthor.FieldStatic] = struct{}{}
			}
		case "mechanic":
			if _, ok := fieldSeen[jobauthor.FieldMechanic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldMechanic)
				fieldSeen[jobauthor.FieldMechanic] = struct{}{}
			}
		case "electric":
			if _, ok := fieldSeen[jobauthor.FieldElectric]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldElectric)
				fieldSeen[jobauthor.FieldElectric] = struct{}{}
			}
		case "architect":
			if _, ok := fieldSeen[jobauthor.FieldArchitect]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldArchitect)
				fieldSeen[jobauthor.FieldArchitect] = struct{}{}
			}
		case "geotechnicalengineer":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalEngineer]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalEngineer)
				fieldSeen[jobauthor.FieldGeotechnicalEngineer] = struct{}{}
			}
		case "geotechnicalgeologist":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalGeologist]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalGeologist)
				fieldSeen[jobauthor.FieldGeotechnicalGeologist] = struct{}{}
			}
		case "geotechnicalgeophysicist":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalGeophysicist]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalGeophysicist)
				fieldSeen[jobauthor.FieldGeotechnicalGeophysicist] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobauthor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldCreatedAt)
				fieldSeen[jobauthor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobauthor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldUpdatedAt)
				fieldSeen[jobauthor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ja.Select(selectedFields...)
	}
	return nil
}

type jobauthorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobAuthorPaginateOption
}

func newJobAuthorPaginateArgs(rv map[string]any) *jobauthorPaginateArgs {
	args := &jobauthorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jc *JobContractorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobContractorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jc, nil
	}
	if err := jc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jc, nil
}

func (jc *JobContractorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobcontractor.Columns))
		selectedFields = []string{jobcontractor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "contractors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jc.WithNamedContractors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobcontractor.FieldName]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldName)
				fieldSeen[jobcontractor.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobcontractor.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTcNo)
				fieldSeen[jobcontractor.FieldTcNo] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[jobcontractor.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldRegisterNo)
				fieldSeen[jobcontractor.FieldRegisterNo] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobcontractor.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldAddress)
				fieldSeen[jobcontractor.FieldAddress] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobcontractor.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTaxNo)
				fieldSeen[jobcontractor.FieldTaxNo] = struct{}{}
			}
		case "mobilephone":
			if _, ok := fieldSeen[jobcontractor.FieldMobilePhone]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldMobilePhone)
				fieldSeen[jobcontractor.FieldMobilePhone] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobcontractor.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldPhone)
				fieldSeen[jobcontractor.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobcontractor.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldEmail)
				fieldSeen[jobcontractor.FieldEmail] = struct{}{}
			}
		case "persontype":
			if _, ok := fieldSeen[jobcontractor.FieldPersonType]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldPersonType)
				fieldSeen[jobcontractor.FieldPersonType] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobcontractor.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldYDSID)
				fieldSeen[jobcontractor.FieldYDSID] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobcontractor.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldNote)
				fieldSeen[jobcontractor.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobcontractor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldCreatedAt)
				fieldSeen[jobcontractor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobcontractor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldUpdatedAt)
				fieldSeen[jobcontractor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jc.Select(selectedFields...)
	}
	return nil
}

type jobcontractorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobContractorPaginateOption
}

func newJobContractorPaginateArgs(rv map[string]any) *jobcontractorPaginateArgs {
	args := &jobcontractorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jd *JobDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jd, nil
	}
	if err := jd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jd, nil
}

func (jd *JobDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobdetail.Columns))
		selectedFields = []string{jobdetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "relations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jd.withRelations = query
		case "yibfno":
			if _, ok := fieldSeen[jobdetail.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldYibfNo)
				fieldSeen[jobdetail.FieldYibfNo] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[jobdetail.FieldTitle]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldTitle)
				fieldSeen[jobdetail.FieldTitle] = struct{}{}
			}
		case "administration":
			if _, ok := fieldSeen[jobdetail.FieldAdministration]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldAdministration)
				fieldSeen[jobdetail.FieldAdministration] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[jobdetail.FieldState]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldState)
				fieldSeen[jobdetail.FieldState] = struct{}{}
			}
		case "island":
			if _, ok := fieldSeen[jobdetail.FieldIsland]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsland)
				fieldSeen[jobdetail.FieldIsland] = struct{}{}
			}
		case "parcel":
			if _, ok := fieldSeen[jobdetail.FieldParcel]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldParcel)
				fieldSeen[jobdetail.FieldParcel] = struct{}{}
			}
		case "sheet":
			if _, ok := fieldSeen[jobdetail.FieldSheet]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldSheet)
				fieldSeen[jobdetail.FieldSheet] = struct{}{}
			}
		case "contractdate":
			if _, ok := fieldSeen[jobdetail.FieldContractDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldContractDate)
				fieldSeen[jobdetail.FieldContractDate] = struct{}{}
			}
		case "startdate":
			if _, ok := fieldSeen[jobdetail.FieldStartDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStartDate)
				fieldSeen[jobdetail.FieldStartDate] = struct{}{}
			}
		case "licensedate":
			if _, ok := fieldSeen[jobdetail.FieldLicenseDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseDate)
				fieldSeen[jobdetail.FieldLicenseDate] = struct{}{}
			}
		case "licenseno":
			if _, ok := fieldSeen[jobdetail.FieldLicenseNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseNo)
				fieldSeen[jobdetail.FieldLicenseNo] = struct{}{}
			}
		case "distributiondate":
			if _, ok := fieldSeen[jobdetail.FieldDistributionDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldDistributionDate)
				fieldSeen[jobdetail.FieldDistributionDate] = struct{}{}
			}
		case "completiondate":
			if _, ok := fieldSeen[jobdetail.FieldCompletionDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCompletionDate)
				fieldSeen[jobdetail.FieldCompletionDate] = struct{}{}
			}
		case "landarea":
			if _, ok := fieldSeen[jobdetail.FieldLandArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLandArea)
				fieldSeen[jobdetail.FieldLandArea] = struct{}{}
			}
		case "totalarea":
			if _, ok := fieldSeen[jobdetail.FieldTotalArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldTotalArea)
				fieldSeen[jobdetail.FieldTotalArea] = struct{}{}
			}
		case "constructionarea":
			if _, ok := fieldSeen[jobdetail.FieldConstructionArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldConstructionArea)
				fieldSeen[jobdetail.FieldConstructionArea] = struct{}{}
			}
		case "leftarea":
			if _, ok := fieldSeen[jobdetail.FieldLeftArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLeftArea)
				fieldSeen[jobdetail.FieldLeftArea] = struct{}{}
			}
		case "ydsaddress":
			if _, ok := fieldSeen[jobdetail.FieldYDSAddress]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldYDSAddress)
				fieldSeen[jobdetail.FieldYDSAddress] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobdetail.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldAddress)
				fieldSeen[jobdetail.FieldAddress] = struct{}{}
			}
		case "buildingclass":
			if _, ok := fieldSeen[jobdetail.FieldBuildingClass]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingClass)
				fieldSeen[jobdetail.FieldBuildingClass] = struct{}{}
			}
		case "buildingtype":
			if _, ok := fieldSeen[jobdetail.FieldBuildingType]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingType)
				fieldSeen[jobdetail.FieldBuildingType] = struct{}{}
			}
		case "level":
			if _, ok := fieldSeen[jobdetail.FieldLevel]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLevel)
				fieldSeen[jobdetail.FieldLevel] = struct{}{}
			}
		case "unitprice":
			if _, ok := fieldSeen[jobdetail.FieldUnitPrice]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUnitPrice)
				fieldSeen[jobdetail.FieldUnitPrice] = struct{}{}
			}
		case "floorcount":
			if _, ok := fieldSeen[jobdetail.FieldFloorCount]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFloorCount)
				fieldSeen[jobdetail.FieldFloorCount] = struct{}{}
			}
		case "bksreferenceno":
			if _, ok := fieldSeen[jobdetail.FieldBKSReferenceNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBKSReferenceNo)
				fieldSeen[jobdetail.FieldBKSReferenceNo] = struct{}{}
			}
		case "coordinates":
			if _, ok := fieldSeen[jobdetail.FieldCoordinates]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCoordinates)
				fieldSeen[jobdetail.FieldCoordinates] = struct{}{}
			}
		case "folderno":
			if _, ok := fieldSeen[jobdetail.FieldFolderNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFolderNo)
				fieldSeen[jobdetail.FieldFolderNo] = struct{}{}
			}
		case "uploadedfile":
			if _, ok := fieldSeen[jobdetail.FieldUploadedFile]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUploadedFile)
				fieldSeen[jobdetail.FieldUploadedFile] = struct{}{}
			}
		case "industryarea":
			if _, ok := fieldSeen[jobdetail.FieldIndustryArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIndustryArea)
				fieldSeen[jobdetail.FieldIndustryArea] = struct{}{}
			}
		case "clusterstructure":
			if _, ok := fieldSeen[jobdetail.FieldClusterStructure]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldClusterStructure)
				fieldSeen[jobdetail.FieldClusterStructure] = struct{}{}
			}
		case "islicenseexpired":
			if _, ok := fieldSeen[jobdetail.FieldIsLicenseExpired]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsLicenseExpired)
				fieldSeen[jobdetail.FieldIsLicenseExpired] = struct{}{}
			}
		case "iscompleted":
			if _, ok := fieldSeen[jobdetail.FieldIsCompleted]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsCompleted)
				fieldSeen[jobdetail.FieldIsCompleted] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobdetail.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldNote)
				fieldSeen[jobdetail.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobdetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCreatedAt)
				fieldSeen[jobdetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobdetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUpdatedAt)
				fieldSeen[jobdetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jd.Select(selectedFields...)
	}
	return nil
}

type jobdetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobDetailPaginateOption
}

func newJobDetailPaginateArgs(rv map[string]any) *jobdetailPaginateArgs {
	args := &jobdetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jl *JobLayerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobLayerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jl, nil
	}
	if err := jl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jl, nil
}

func (jl *JobLayerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(joblayer.Columns))
		selectedFields = []string{joblayer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "layer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jl.withLayer = query
		case "yibfno":
			if _, ok := fieldSeen[joblayer.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldYibfNo)
				fieldSeen[joblayer.FieldYibfNo] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[joblayer.FieldName]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldName)
				fieldSeen[joblayer.FieldName] = struct{}{}
			}
		case "metre":
			if _, ok := fieldSeen[joblayer.FieldMetre]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMetre)
				fieldSeen[joblayer.FieldMetre] = struct{}{}
			}
		case "molddate":
			if _, ok := fieldSeen[joblayer.FieldMoldDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMoldDate)
				fieldSeen[joblayer.FieldMoldDate] = struct{}{}
			}
		case "concretedate":
			if _, ok := fieldSeen[joblayer.FieldConcreteDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteDate)
				fieldSeen[joblayer.FieldConcreteDate] = struct{}{}
			}
		case "samples":
			if _, ok := fieldSeen[joblayer.FieldSamples]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldSamples)
				fieldSeen[joblayer.FieldSamples] = struct{}{}
			}
		case "concreteclass":
			if _, ok := fieldSeen[joblayer.FieldConcreteClass]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteClass)
				fieldSeen[joblayer.FieldConcreteClass] = struct{}{}
			}
		case "weekresult":
			if _, ok := fieldSeen[joblayer.FieldWeekResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldWeekResult)
				fieldSeen[joblayer.FieldWeekResult] = struct{}{}
			}
		case "monthresult":
			if _, ok := fieldSeen[joblayer.FieldMonthResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMonthResult)
				fieldSeen[joblayer.FieldMonthResult] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[joblayer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldCreatedAt)
				fieldSeen[joblayer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[joblayer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldUpdatedAt)
				fieldSeen[joblayer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jl.Select(selectedFields...)
	}
	return nil
}

type joblayerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobLayerPaginateOption
}

func newJobLayerPaginateArgs(rv map[string]any) *joblayerPaginateArgs {
	args := &joblayerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jo *JobOwnerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobOwnerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jo, nil
	}
	if err := jo.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jo, nil
}

func (jo *JobOwnerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobowner.Columns))
		selectedFields = []string{jobowner.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jo.WithNamedOwners(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobowner.FieldName]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldName)
				fieldSeen[jobowner.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobowner.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldAddress)
				fieldSeen[jobowner.FieldAddress] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobowner.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTcNo)
				fieldSeen[jobowner.FieldTcNo] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[jobowner.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxAdmin)
				fieldSeen[jobowner.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobowner.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxNo)
				fieldSeen[jobowner.FieldTaxNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobowner.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldPhone)
				fieldSeen[jobowner.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobowner.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldEmail)
				fieldSeen[jobowner.FieldEmail] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobowner.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldYDSID)
				fieldSeen[jobowner.FieldYDSID] = struct{}{}
			}
		case "shareholder":
			if _, ok := fieldSeen[jobowner.FieldShareholder]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldShareholder)
				fieldSeen[jobowner.FieldShareholder] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobowner.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldNote)
				fieldSeen[jobowner.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobowner.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldCreatedAt)
				fieldSeen[jobowner.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobowner.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldUpdatedAt)
				fieldSeen[jobowner.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jo.Select(selectedFields...)
	}
	return nil
}

type jobownerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobOwnerPaginateOption
}

func newJobOwnerPaginateArgs(rv map[string]any) *jobownerPaginateArgs {
	args := &jobownerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jp *JobPaymentsQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobPaymentsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jp, nil
	}
	if err := jp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jp, nil
}

func (jp *JobPaymentsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobpayments.Columns))
		selectedFields = []string{jobpayments.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jp.withPayments = query
		case "yibfno":
			if _, ok := fieldSeen[jobpayments.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldYibfNo)
				fieldSeen[jobpayments.FieldYibfNo] = struct{}{}
			}
		case "paymentno":
			if _, ok := fieldSeen[jobpayments.FieldPaymentNo]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentNo)
				fieldSeen[jobpayments.FieldPaymentNo] = struct{}{}
			}
		case "paymentdate":
			if _, ok := fieldSeen[jobpayments.FieldPaymentDate]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentDate)
				fieldSeen[jobpayments.FieldPaymentDate] = struct{}{}
			}
		case "paymenttype":
			if _, ok := fieldSeen[jobpayments.FieldPaymentType]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentType)
				fieldSeen[jobpayments.FieldPaymentType] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[jobpayments.FieldState]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldState)
				fieldSeen[jobpayments.FieldState] = struct{}{}
			}
		case "totalpayment":
			if _, ok := fieldSeen[jobpayments.FieldTotalPayment]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldTotalPayment)
				fieldSeen[jobpayments.FieldTotalPayment] = struct{}{}
			}
		case "levelrequest":
			if _, ok := fieldSeen[jobpayments.FieldLevelRequest]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldLevelRequest)
				fieldSeen[jobpayments.FieldLevelRequest] = struct{}{}
			}
		case "levelapprove":
			if _, ok := fieldSeen[jobpayments.FieldLevelApprove]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldLevelApprove)
				fieldSeen[jobpayments.FieldLevelApprove] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[jobpayments.FieldAmount]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldAmount)
				fieldSeen[jobpayments.FieldAmount] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobpayments.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldCreatedAt)
				fieldSeen[jobpayments.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobpayments.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldUpdatedAt)
				fieldSeen[jobpayments.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jp.Select(selectedFields...)
	}
	return nil
}

type jobpaymentsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobPaymentsPaginateOption
}

func newJobPaymentsPaginateArgs(rv map[string]any) *jobpaymentsPaginateArgs {
	args := &jobpaymentsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jp *JobProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jp, nil
	}
	if err := jp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jp, nil
}

func (jp *JobProgressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobprogress.Columns))
		selectedFields = []string{jobprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jp.WithNamedProgress(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobprogress.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldYibfNo)
				fieldSeen[jobprogress.FieldYibfNo] = struct{}{}
			}
		case "one":
			if _, ok := fieldSeen[jobprogress.FieldOne]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldOne)
				fieldSeen[jobprogress.FieldOne] = struct{}{}
			}
		case "two":
			if _, ok := fieldSeen[jobprogress.FieldTwo]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldTwo)
				fieldSeen[jobprogress.FieldTwo] = struct{}{}
			}
		case "three":
			if _, ok := fieldSeen[jobprogress.FieldThree]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldThree)
				fieldSeen[jobprogress.FieldThree] = struct{}{}
			}
		case "four":
			if _, ok := fieldSeen[jobprogress.FieldFour]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFour)
				fieldSeen[jobprogress.FieldFour] = struct{}{}
			}
		case "five":
			if _, ok := fieldSeen[jobprogress.FieldFive]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFive)
				fieldSeen[jobprogress.FieldFive] = struct{}{}
			}
		case "six":
			if _, ok := fieldSeen[jobprogress.FieldSix]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldSix)
				fieldSeen[jobprogress.FieldSix] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldCreatedAt)
				fieldSeen[jobprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldUpdatedAt)
				fieldSeen[jobprogress.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jp.Select(selectedFields...)
	}
	return nil
}

type jobprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobProgressPaginateOption
}

func newJobProgressPaginateArgs(rv map[string]any) *jobprogressPaginateArgs {
	args := &jobprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jr *JobRelationsQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobRelationsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jr, nil
	}
	if err := jr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jr, nil
}

func (jr *JobRelationsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobrelations.Columns))
		selectedFields = []string{jobrelations.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jr.withJob = query

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobOwnerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobownerImplementors)...); err != nil {
				return err
			}
			jr.withOwner = query

		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobAuthorClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobauthorImplementors)...); err != nil {
				return err
			}
			jr.withAuthor = query

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			jr.withCompany = query

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobprogressImplementors)...); err != nil {
				return err
			}
			jr.withProgress = query

		case "contractor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobContractorClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobcontractorImplementors)...); err != nil {
				return err
			}
			jr.withContractor = query

		case "supervisor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobSupervisorClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobsupervisorImplementors)...); err != nil {
				return err
			}
			jr.withSupervisor = query

		case "static":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withStatic = query

		case "mechanic":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withMechanic = query

		case "electric":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withElectric = query

		case "inspector":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withInspector = query

		case "architect":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withArchitect = query

		case "controller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withController = query

		case "mechaniccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withMechaniccontroller = query

		case "electriccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jr.withElectriccontroller = query

		case "layers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobLayerClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, joblayerImplementors)...); err != nil {
				return err
			}
			jr.WithNamedLayers(alias, func(wq *JobLayerQuery) {
				*wq = *query
			})

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobPaymentsClient{config: jr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobpaymentsImplementors)...); err != nil {
				return err
			}
			jr.WithNamedPayments(alias, func(wq *JobPaymentsQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobrelations.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldYibfNo)
				fieldSeen[jobrelations.FieldYibfNo] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobrelations.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldCreatedAt)
				fieldSeen[jobrelations.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobrelations.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldUpdatedAt)
				fieldSeen[jobrelations.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jr.Select(selectedFields...)
	}
	return nil
}

type jobrelationsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobRelationsPaginateOption
}

func newJobRelationsPaginateArgs(rv map[string]any) *jobrelationsPaginateArgs {
	args := &jobrelationsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (js *JobSupervisorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobSupervisorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return js, nil
	}
	if err := js.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return js, nil
}

func (js *JobSupervisorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobsupervisor.Columns))
		selectedFields = []string{jobsupervisor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "supervisors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: js.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			js.WithNamedSupervisors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobsupervisor.FieldName]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldName)
				fieldSeen[jobsupervisor.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobsupervisor.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldAddress)
				fieldSeen[jobsupervisor.FieldAddress] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobsupervisor.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldPhone)
				fieldSeen[jobsupervisor.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobsupervisor.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldEmail)
				fieldSeen[jobsupervisor.FieldEmail] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobsupervisor.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldTcNo)
				fieldSeen[jobsupervisor.FieldTcNo] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[jobsupervisor.FieldPosition]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldPosition)
				fieldSeen[jobsupervisor.FieldPosition] = struct{}{}
			}
		case "career":
			if _, ok := fieldSeen[jobsupervisor.FieldCareer]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldCareer)
				fieldSeen[jobsupervisor.FieldCareer] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[jobsupervisor.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldRegisterNo)
				fieldSeen[jobsupervisor.FieldRegisterNo] = struct{}{}
			}
		case "socialsecurityno":
			if _, ok := fieldSeen[jobsupervisor.FieldSocialSecurityNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldSocialSecurityNo)
				fieldSeen[jobsupervisor.FieldSocialSecurityNo] = struct{}{}
			}
		case "schoolgraduation":
			if _, ok := fieldSeen[jobsupervisor.FieldSchoolGraduation]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldSchoolGraduation)
				fieldSeen[jobsupervisor.FieldSchoolGraduation] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobsupervisor.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldYDSID)
				fieldSeen[jobsupervisor.FieldYDSID] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobsupervisor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldCreatedAt)
				fieldSeen[jobsupervisor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobsupervisor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldUpdatedAt)
				fieldSeen[jobsupervisor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		js.Select(selectedFields...)
	}
	return nil
}

type jobsupervisorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobSupervisorPaginateOption
}

func newJobSupervisorPaginateArgs(rv map[string]any) *jobsupervisorPaginateArgs {
	args := &jobsupervisorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "companies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			u.WithNamedCompanies(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[user.FieldPhone]; !ok {
				selectedFields = append(selectedFields, user.FieldPhone)
				fieldSeen[user.FieldPhone] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[user.FieldPassword]; !ok {
				selectedFields = append(selectedFields, user.FieldPassword)
				fieldSeen[user.FieldPassword] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "licenseexpiredate":
			if _, ok := fieldSeen[user.FieldLicenseExpireDate]; !ok {
				selectedFields = append(selectedFields, user.FieldLicenseExpireDate)
				fieldSeen[user.FieldLicenseExpireDate] = struct{}{}
			}
		case "lastlogin":
			if _, ok := fieldSeen[user.FieldLastLogin]; !ok {
				selectedFields = append(selectedFields, user.FieldLastLogin)
				fieldSeen[user.FieldLastLogin] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[user.FieldActive]; !ok {
				selectedFields = append(selectedFields, user.FieldActive)
				fieldSeen[user.FieldActive] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
