package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.62

import (
	"context"
	"fmt"

	"github.com/polatbilal/gqlgen-ent/ent"
	"github.com/polatbilal/gqlgen-ent/ent/companydetail"
	"github.com/polatbilal/gqlgen-ent/ent/companytoken"
	"github.com/polatbilal/gqlgen-ent/graphql/generated"
	"github.com/polatbilal/gqlgen-ent/graphql/model"
	"github.com/polatbilal/gqlgen-ent/middlewares"
)

// CompanyCode is the resolver for the CompanyCode field.
func (r *companyTokenResolver) CompanyCode(ctx context.Context, obj *ent.CompanyToken) (*int, error) {
	company, err := obj.QueryCompany().Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, nil
		}
		return nil, fmt.Errorf("şirket bilgisi alınamadı: %v", err)
	}

	return &company.CompanyCode, nil
}

// UpsertToken, token yoksa oluşturur varsa günceller
func (r *mutationResolver) UpsertToken(ctx context.Context, departmentID int, input model.CompanyTokenInput) (*ent.CompanyToken, error) {
	client := middlewares.GetClientFromContext(ctx)

	// Yetkili kullanıcıyı kontrol et
	if userRole := middlewares.CtxValue(ctx); userRole == nil || userRole.Role != "Admin" {
		return nil, fmt.Errorf("yetkiniz yok")
	}

	// Önce token'ı kontrol et
	existingToken, err := client.CompanyToken.Query().Where(companytoken.DepartmentIdEQ(departmentID)).Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			// Token bulunamadı, yeni token oluştur
			// 1. Önce token'ı kaydet
			tokenCreate := client.CompanyToken.Create().
				SetYDKUsername(*input.YDKUsername).
				SetYDKPassword(*input.YDKPassword).
				SetToken(*input.Token).
				SetDepartmentId(departmentID)
			createCompanyToken, err := tokenCreate.Save(ctx)
			if err != nil {
				return nil, fmt.Errorf("şirket token oluşturulamadı: %v", err)
			}

			return createCompanyToken, nil
		}
		return nil, fmt.Errorf("token sorgulama hatası: %v", err)
	}

	// Token bulunduysa güncelle
	updatedCompanyToken, err := existingToken.Update().
		SetToken(*input.Token).
		Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("şirket token güncellenemedi: %v", err)
	}

	return updatedCompanyToken, nil
}

// CompanyToken is the resolver for the companyToken field.
func (r *queryResolver) CompanyToken(ctx context.Context, companyCode *int) (*ent.CompanyToken, error) {
	client := middlewares.GetClientFromContext(ctx)

	// Önce companyCode ile arama yapalım
	company, err := client.CompanyDetail.Query().Where(companydetail.CompanyCodeEQ(*companyCode)).Only(ctx)
	if err != nil {
		if !ent.IsNotFound(err) {
			return nil, fmt.Errorf("şirket sorgulama hatası: %v", err)
		}

		// CompanyCode ile bulunamadıysa, departmentId olarak deneyelim
		companyToken, err := client.CompanyToken.Query().
			Where(companytoken.DepartmentIdEQ(*companyCode)).
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("şirket token bulunamadı: %v", err)
		}
		return companyToken, nil
	}

	// CompanyCode ile şirket bulunduysa, token'ı getirelim
	companyToken, err := company.QueryTokens().Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("şirket token bulunamadı: %v", err)
	}

	return companyToken, nil
}

// CompanyToken returns generated.CompanyTokenResolver implementation.
func (r *Resolver) CompanyToken() generated.CompanyTokenResolver { return &companyTokenResolver{r} }

type companyTokenResolver struct{ *Resolver }
