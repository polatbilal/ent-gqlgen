// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/polatbilal/ent-gqlgen/ent/companydetail"
	"github.com/polatbilal/ent-gqlgen/ent/companyengineer"
	"github.com/polatbilal/ent-gqlgen/ent/companytoken"
	"github.com/polatbilal/ent-gqlgen/ent/companyuser"
	"github.com/polatbilal/ent-gqlgen/ent/jobauthor"
	"github.com/polatbilal/ent-gqlgen/ent/jobcontractor"
	"github.com/polatbilal/ent-gqlgen/ent/jobdetail"
	"github.com/polatbilal/ent-gqlgen/ent/jobfloor"
	"github.com/polatbilal/ent-gqlgen/ent/jobowner"
	"github.com/polatbilal/ent-gqlgen/ent/jobpayments"
	"github.com/polatbilal/ent-gqlgen/ent/jobprogress"
	"github.com/polatbilal/ent-gqlgen/ent/jobreceipt"
	"github.com/polatbilal/ent-gqlgen/ent/jobrelations"
	"github.com/polatbilal/ent-gqlgen/ent/jobsupervisor"
	"github.com/polatbilal/ent-gqlgen/ent/user"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CompanyDetailEdge is the edge representation of CompanyDetail.
type CompanyDetailEdge struct {
	Node   *CompanyDetail `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CompanyDetailConnection is the connection containing edges to CompanyDetail.
type CompanyDetailConnection struct {
	Edges      []*CompanyDetailEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *CompanyDetailConnection) build(nodes []*CompanyDetail, pager *companydetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyDetailPaginateOption enables pagination customization.
type CompanyDetailPaginateOption func(*companydetailPager) error

// WithCompanyDetailOrder configures pagination ordering.
func WithCompanyDetailOrder(order *CompanyDetailOrder) CompanyDetailPaginateOption {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	o := *order
	return func(pager *companydetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyDetailFilter configures pagination filter.
func WithCompanyDetailFilter(filter func(*CompanyDetailQuery) (*CompanyDetailQuery, error)) CompanyDetailPaginateOption {
	return func(pager *companydetailPager) error {
		if filter == nil {
			return errors.New("CompanyDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companydetailPager struct {
	reverse bool
	order   *CompanyDetailOrder
	filter  func(*CompanyDetailQuery) (*CompanyDetailQuery, error)
}

func newCompanyDetailPager(opts []CompanyDetailPaginateOption, reverse bool) (*companydetailPager, error) {
	pager := &companydetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyDetailOrder
	}
	return pager, nil
}

func (p *companydetailPager) applyFilter(query *CompanyDetailQuery) (*CompanyDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companydetailPager) toCursor(_m *CompanyDetail) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *companydetailPager) applyCursors(query *CompanyDetailQuery, after, before *Cursor) (*CompanyDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companydetailPager) applyOrder(query *CompanyDetailQuery) *CompanyDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyDetailOrder.Field {
		query = query.Order(DefaultCompanyDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companydetailPager) orderExpr(query *CompanyDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyDetailOrder.Field {
			b.Comma().Ident(DefaultCompanyDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyDetail.
func (_m *CompanyDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyDetailPaginateOption,
) (*CompanyDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CompanyDetailConnection{Edges: []*CompanyDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyDetailOrderField defines the ordering field of CompanyDetail.
type CompanyDetailOrderField struct {
	// Value extracts the ordering value from the given CompanyDetail.
	Value    func(*CompanyDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companydetail.OrderOption
	toCursor func(*CompanyDetail) Cursor
}

// CompanyDetailOrder defines the ordering of CompanyDetail.
type CompanyDetailOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CompanyDetailOrderField `json:"field"`
}

// DefaultCompanyDetailOrder is the default ordering of CompanyDetail.
var DefaultCompanyDetailOrder = &CompanyDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyDetailOrderField{
		Value: func(_m *CompanyDetail) (ent.Value, error) {
			return _m.ID, nil
		},
		column: companydetail.FieldID,
		toTerm: companydetail.ByID,
		toCursor: func(_m *CompanyDetail) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CompanyDetail into CompanyDetailEdge.
func (_m *CompanyDetail) ToEdge(order *CompanyDetailOrder) *CompanyDetailEdge {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	return &CompanyDetailEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CompanyEngineerEdge is the edge representation of CompanyEngineer.
type CompanyEngineerEdge struct {
	Node   *CompanyEngineer `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CompanyEngineerConnection is the connection containing edges to CompanyEngineer.
type CompanyEngineerConnection struct {
	Edges      []*CompanyEngineerEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CompanyEngineerConnection) build(nodes []*CompanyEngineer, pager *companyengineerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyEngineer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEngineerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEngineerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyEngineerPaginateOption enables pagination customization.
type CompanyEngineerPaginateOption func(*companyengineerPager) error

// WithCompanyEngineerOrder configures pagination ordering.
func WithCompanyEngineerOrder(order *CompanyEngineerOrder) CompanyEngineerPaginateOption {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	o := *order
	return func(pager *companyengineerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyEngineerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyEngineerFilter configures pagination filter.
func WithCompanyEngineerFilter(filter func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)) CompanyEngineerPaginateOption {
	return func(pager *companyengineerPager) error {
		if filter == nil {
			return errors.New("CompanyEngineerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyengineerPager struct {
	reverse bool
	order   *CompanyEngineerOrder
	filter  func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)
}

func newCompanyEngineerPager(opts []CompanyEngineerPaginateOption, reverse bool) (*companyengineerPager, error) {
	pager := &companyengineerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyEngineerOrder
	}
	return pager, nil
}

func (p *companyengineerPager) applyFilter(query *CompanyEngineerQuery) (*CompanyEngineerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyengineerPager) toCursor(_m *CompanyEngineer) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *companyengineerPager) applyCursors(query *CompanyEngineerQuery, after, before *Cursor) (*CompanyEngineerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyEngineerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyengineerPager) applyOrder(query *CompanyEngineerQuery) *CompanyEngineerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyEngineerOrder.Field {
		query = query.Order(DefaultCompanyEngineerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyengineerPager) orderExpr(query *CompanyEngineerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyEngineerOrder.Field {
			b.Comma().Ident(DefaultCompanyEngineerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyEngineer.
func (_m *CompanyEngineerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyEngineerPaginateOption,
) (*CompanyEngineerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyEngineerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CompanyEngineerConnection{Edges: []*CompanyEngineerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyEngineerOrderField defines the ordering field of CompanyEngineer.
type CompanyEngineerOrderField struct {
	// Value extracts the ordering value from the given CompanyEngineer.
	Value    func(*CompanyEngineer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyengineer.OrderOption
	toCursor func(*CompanyEngineer) Cursor
}

// CompanyEngineerOrder defines the ordering of CompanyEngineer.
type CompanyEngineerOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CompanyEngineerOrderField `json:"field"`
}

// DefaultCompanyEngineerOrder is the default ordering of CompanyEngineer.
var DefaultCompanyEngineerOrder = &CompanyEngineerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyEngineerOrderField{
		Value: func(_m *CompanyEngineer) (ent.Value, error) {
			return _m.ID, nil
		},
		column: companyengineer.FieldID,
		toTerm: companyengineer.ByID,
		toCursor: func(_m *CompanyEngineer) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CompanyEngineer into CompanyEngineerEdge.
func (_m *CompanyEngineer) ToEdge(order *CompanyEngineerOrder) *CompanyEngineerEdge {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	return &CompanyEngineerEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CompanyTokenEdge is the edge representation of CompanyToken.
type CompanyTokenEdge struct {
	Node   *CompanyToken `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CompanyTokenConnection is the connection containing edges to CompanyToken.
type CompanyTokenConnection struct {
	Edges      []*CompanyTokenEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CompanyTokenConnection) build(nodes []*CompanyToken, pager *companytokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyTokenPaginateOption enables pagination customization.
type CompanyTokenPaginateOption func(*companytokenPager) error

// WithCompanyTokenOrder configures pagination ordering.
func WithCompanyTokenOrder(order *CompanyTokenOrder) CompanyTokenPaginateOption {
	if order == nil {
		order = DefaultCompanyTokenOrder
	}
	o := *order
	return func(pager *companytokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyTokenFilter configures pagination filter.
func WithCompanyTokenFilter(filter func(*CompanyTokenQuery) (*CompanyTokenQuery, error)) CompanyTokenPaginateOption {
	return func(pager *companytokenPager) error {
		if filter == nil {
			return errors.New("CompanyTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companytokenPager struct {
	reverse bool
	order   *CompanyTokenOrder
	filter  func(*CompanyTokenQuery) (*CompanyTokenQuery, error)
}

func newCompanyTokenPager(opts []CompanyTokenPaginateOption, reverse bool) (*companytokenPager, error) {
	pager := &companytokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyTokenOrder
	}
	return pager, nil
}

func (p *companytokenPager) applyFilter(query *CompanyTokenQuery) (*CompanyTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companytokenPager) toCursor(_m *CompanyToken) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *companytokenPager) applyCursors(query *CompanyTokenQuery, after, before *Cursor) (*CompanyTokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companytokenPager) applyOrder(query *CompanyTokenQuery) *CompanyTokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyTokenOrder.Field {
		query = query.Order(DefaultCompanyTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companytokenPager) orderExpr(query *CompanyTokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyTokenOrder.Field {
			b.Comma().Ident(DefaultCompanyTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyToken.
func (_m *CompanyTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyTokenPaginateOption,
) (*CompanyTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CompanyTokenConnection{Edges: []*CompanyTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyTokenOrderField defines the ordering field of CompanyToken.
type CompanyTokenOrderField struct {
	// Value extracts the ordering value from the given CompanyToken.
	Value    func(*CompanyToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companytoken.OrderOption
	toCursor func(*CompanyToken) Cursor
}

// CompanyTokenOrder defines the ordering of CompanyToken.
type CompanyTokenOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CompanyTokenOrderField `json:"field"`
}

// DefaultCompanyTokenOrder is the default ordering of CompanyToken.
var DefaultCompanyTokenOrder = &CompanyTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyTokenOrderField{
		Value: func(_m *CompanyToken) (ent.Value, error) {
			return _m.ID, nil
		},
		column: companytoken.FieldID,
		toTerm: companytoken.ByID,
		toCursor: func(_m *CompanyToken) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CompanyToken into CompanyTokenEdge.
func (_m *CompanyToken) ToEdge(order *CompanyTokenOrder) *CompanyTokenEdge {
	if order == nil {
		order = DefaultCompanyTokenOrder
	}
	return &CompanyTokenEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// CompanyUserEdge is the edge representation of CompanyUser.
type CompanyUserEdge struct {
	Node   *CompanyUser `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CompanyUserConnection is the connection containing edges to CompanyUser.
type CompanyUserConnection struct {
	Edges      []*CompanyUserEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *CompanyUserConnection) build(nodes []*CompanyUser, pager *companyuserPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyUser {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyUserPaginateOption enables pagination customization.
type CompanyUserPaginateOption func(*companyuserPager) error

// WithCompanyUserOrder configures pagination ordering.
func WithCompanyUserOrder(order *CompanyUserOrder) CompanyUserPaginateOption {
	if order == nil {
		order = DefaultCompanyUserOrder
	}
	o := *order
	return func(pager *companyuserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyUserFilter configures pagination filter.
func WithCompanyUserFilter(filter func(*CompanyUserQuery) (*CompanyUserQuery, error)) CompanyUserPaginateOption {
	return func(pager *companyuserPager) error {
		if filter == nil {
			return errors.New("CompanyUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyuserPager struct {
	reverse bool
	order   *CompanyUserOrder
	filter  func(*CompanyUserQuery) (*CompanyUserQuery, error)
}

func newCompanyUserPager(opts []CompanyUserPaginateOption, reverse bool) (*companyuserPager, error) {
	pager := &companyuserPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyUserOrder
	}
	return pager, nil
}

func (p *companyuserPager) applyFilter(query *CompanyUserQuery) (*CompanyUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyuserPager) toCursor(_m *CompanyUser) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *companyuserPager) applyCursors(query *CompanyUserQuery, after, before *Cursor) (*CompanyUserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyuserPager) applyOrder(query *CompanyUserQuery) *CompanyUserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyUserOrder.Field {
		query = query.Order(DefaultCompanyUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyuserPager) orderExpr(query *CompanyUserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyUserOrder.Field {
			b.Comma().Ident(DefaultCompanyUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyUser.
func (_m *CompanyUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyUserPaginateOption,
) (*CompanyUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &CompanyUserConnection{Edges: []*CompanyUserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyUserOrderField defines the ordering field of CompanyUser.
type CompanyUserOrderField struct {
	// Value extracts the ordering value from the given CompanyUser.
	Value    func(*CompanyUser) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyuser.OrderOption
	toCursor func(*CompanyUser) Cursor
}

// CompanyUserOrder defines the ordering of CompanyUser.
type CompanyUserOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CompanyUserOrderField `json:"field"`
}

// DefaultCompanyUserOrder is the default ordering of CompanyUser.
var DefaultCompanyUserOrder = &CompanyUserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyUserOrderField{
		Value: func(_m *CompanyUser) (ent.Value, error) {
			return _m.ID, nil
		},
		column: companyuser.FieldID,
		toTerm: companyuser.ByID,
		toCursor: func(_m *CompanyUser) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts CompanyUser into CompanyUserEdge.
func (_m *CompanyUser) ToEdge(order *CompanyUserOrder) *CompanyUserEdge {
	if order == nil {
		order = DefaultCompanyUserOrder
	}
	return &CompanyUserEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobAuthorEdge is the edge representation of JobAuthor.
type JobAuthorEdge struct {
	Node   *JobAuthor `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobAuthorConnection is the connection containing edges to JobAuthor.
type JobAuthorConnection struct {
	Edges      []*JobAuthorEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobAuthorConnection) build(nodes []*JobAuthor, pager *jobauthorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobAuthor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobAuthor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobAuthor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobAuthorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobAuthorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobAuthorPaginateOption enables pagination customization.
type JobAuthorPaginateOption func(*jobauthorPager) error

// WithJobAuthorOrder configures pagination ordering.
func WithJobAuthorOrder(order *JobAuthorOrder) JobAuthorPaginateOption {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	o := *order
	return func(pager *jobauthorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobAuthorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobAuthorFilter configures pagination filter.
func WithJobAuthorFilter(filter func(*JobAuthorQuery) (*JobAuthorQuery, error)) JobAuthorPaginateOption {
	return func(pager *jobauthorPager) error {
		if filter == nil {
			return errors.New("JobAuthorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobauthorPager struct {
	reverse bool
	order   *JobAuthorOrder
	filter  func(*JobAuthorQuery) (*JobAuthorQuery, error)
}

func newJobAuthorPager(opts []JobAuthorPaginateOption, reverse bool) (*jobauthorPager, error) {
	pager := &jobauthorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobAuthorOrder
	}
	return pager, nil
}

func (p *jobauthorPager) applyFilter(query *JobAuthorQuery) (*JobAuthorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobauthorPager) toCursor(_m *JobAuthor) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobauthorPager) applyCursors(query *JobAuthorQuery, after, before *Cursor) (*JobAuthorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobAuthorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobauthorPager) applyOrder(query *JobAuthorQuery) *JobAuthorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobAuthorOrder.Field {
		query = query.Order(DefaultJobAuthorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobauthorPager) orderExpr(query *JobAuthorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobAuthorOrder.Field {
			b.Comma().Ident(DefaultJobAuthorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobAuthor.
func (_m *JobAuthorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobAuthorPaginateOption,
) (*JobAuthorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobAuthorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobAuthorConnection{Edges: []*JobAuthorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobAuthorOrderField defines the ordering field of JobAuthor.
type JobAuthorOrderField struct {
	// Value extracts the ordering value from the given JobAuthor.
	Value    func(*JobAuthor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobauthor.OrderOption
	toCursor func(*JobAuthor) Cursor
}

// JobAuthorOrder defines the ordering of JobAuthor.
type JobAuthorOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobAuthorOrderField `json:"field"`
}

// DefaultJobAuthorOrder is the default ordering of JobAuthor.
var DefaultJobAuthorOrder = &JobAuthorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobAuthorOrderField{
		Value: func(_m *JobAuthor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobauthor.FieldID,
		toTerm: jobauthor.ByID,
		toCursor: func(_m *JobAuthor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobAuthor into JobAuthorEdge.
func (_m *JobAuthor) ToEdge(order *JobAuthorOrder) *JobAuthorEdge {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	return &JobAuthorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobContractorEdge is the edge representation of JobContractor.
type JobContractorEdge struct {
	Node   *JobContractor `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// JobContractorConnection is the connection containing edges to JobContractor.
type JobContractorConnection struct {
	Edges      []*JobContractorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *JobContractorConnection) build(nodes []*JobContractor, pager *jobcontractorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobContractor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobContractor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobContractor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobContractorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobContractorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobContractorPaginateOption enables pagination customization.
type JobContractorPaginateOption func(*jobcontractorPager) error

// WithJobContractorOrder configures pagination ordering.
func WithJobContractorOrder(order *JobContractorOrder) JobContractorPaginateOption {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	o := *order
	return func(pager *jobcontractorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobContractorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobContractorFilter configures pagination filter.
func WithJobContractorFilter(filter func(*JobContractorQuery) (*JobContractorQuery, error)) JobContractorPaginateOption {
	return func(pager *jobcontractorPager) error {
		if filter == nil {
			return errors.New("JobContractorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobcontractorPager struct {
	reverse bool
	order   *JobContractorOrder
	filter  func(*JobContractorQuery) (*JobContractorQuery, error)
}

func newJobContractorPager(opts []JobContractorPaginateOption, reverse bool) (*jobcontractorPager, error) {
	pager := &jobcontractorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobContractorOrder
	}
	return pager, nil
}

func (p *jobcontractorPager) applyFilter(query *JobContractorQuery) (*JobContractorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobcontractorPager) toCursor(_m *JobContractor) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobcontractorPager) applyCursors(query *JobContractorQuery, after, before *Cursor) (*JobContractorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobContractorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobcontractorPager) applyOrder(query *JobContractorQuery) *JobContractorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobContractorOrder.Field {
		query = query.Order(DefaultJobContractorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobcontractorPager) orderExpr(query *JobContractorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobContractorOrder.Field {
			b.Comma().Ident(DefaultJobContractorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobContractor.
func (_m *JobContractorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobContractorPaginateOption,
) (*JobContractorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobContractorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobContractorConnection{Edges: []*JobContractorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobContractorOrderField defines the ordering field of JobContractor.
type JobContractorOrderField struct {
	// Value extracts the ordering value from the given JobContractor.
	Value    func(*JobContractor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobcontractor.OrderOption
	toCursor func(*JobContractor) Cursor
}

// JobContractorOrder defines the ordering of JobContractor.
type JobContractorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *JobContractorOrderField `json:"field"`
}

// DefaultJobContractorOrder is the default ordering of JobContractor.
var DefaultJobContractorOrder = &JobContractorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobContractorOrderField{
		Value: func(_m *JobContractor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobcontractor.FieldID,
		toTerm: jobcontractor.ByID,
		toCursor: func(_m *JobContractor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobContractor into JobContractorEdge.
func (_m *JobContractor) ToEdge(order *JobContractorOrder) *JobContractorEdge {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	return &JobContractorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobDetailEdge is the edge representation of JobDetail.
type JobDetailEdge struct {
	Node   *JobDetail `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobDetailConnection is the connection containing edges to JobDetail.
type JobDetailConnection struct {
	Edges      []*JobDetailEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobDetailConnection) build(nodes []*JobDetail, pager *jobdetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobDetailPaginateOption enables pagination customization.
type JobDetailPaginateOption func(*jobdetailPager) error

// WithJobDetailOrder configures pagination ordering.
func WithJobDetailOrder(order *JobDetailOrder) JobDetailPaginateOption {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	o := *order
	return func(pager *jobdetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobDetailFilter configures pagination filter.
func WithJobDetailFilter(filter func(*JobDetailQuery) (*JobDetailQuery, error)) JobDetailPaginateOption {
	return func(pager *jobdetailPager) error {
		if filter == nil {
			return errors.New("JobDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobdetailPager struct {
	reverse bool
	order   *JobDetailOrder
	filter  func(*JobDetailQuery) (*JobDetailQuery, error)
}

func newJobDetailPager(opts []JobDetailPaginateOption, reverse bool) (*jobdetailPager, error) {
	pager := &jobdetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobDetailOrder
	}
	return pager, nil
}

func (p *jobdetailPager) applyFilter(query *JobDetailQuery) (*JobDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobdetailPager) toCursor(_m *JobDetail) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobdetailPager) applyCursors(query *JobDetailQuery, after, before *Cursor) (*JobDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobdetailPager) applyOrder(query *JobDetailQuery) *JobDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobDetailOrder.Field {
		query = query.Order(DefaultJobDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobdetailPager) orderExpr(query *JobDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobDetailOrder.Field {
			b.Comma().Ident(DefaultJobDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobDetail.
func (_m *JobDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobDetailPaginateOption,
) (*JobDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobDetailConnection{Edges: []*JobDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobDetailOrderField defines the ordering field of JobDetail.
type JobDetailOrderField struct {
	// Value extracts the ordering value from the given JobDetail.
	Value    func(*JobDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobdetail.OrderOption
	toCursor func(*JobDetail) Cursor
}

// JobDetailOrder defines the ordering of JobDetail.
type JobDetailOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobDetailOrderField `json:"field"`
}

// DefaultJobDetailOrder is the default ordering of JobDetail.
var DefaultJobDetailOrder = &JobDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobDetailOrderField{
		Value: func(_m *JobDetail) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobdetail.FieldID,
		toTerm: jobdetail.ByID,
		toCursor: func(_m *JobDetail) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobDetail into JobDetailEdge.
func (_m *JobDetail) ToEdge(order *JobDetailOrder) *JobDetailEdge {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	return &JobDetailEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobFloorEdge is the edge representation of JobFloor.
type JobFloorEdge struct {
	Node   *JobFloor `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobFloorConnection is the connection containing edges to JobFloor.
type JobFloorConnection struct {
	Edges      []*JobFloorEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobFloorConnection) build(nodes []*JobFloor, pager *jobfloorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobFloor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobFloor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobFloor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobFloorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobFloorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobFloorPaginateOption enables pagination customization.
type JobFloorPaginateOption func(*jobfloorPager) error

// WithJobFloorOrder configures pagination ordering.
func WithJobFloorOrder(order *JobFloorOrder) JobFloorPaginateOption {
	if order == nil {
		order = DefaultJobFloorOrder
	}
	o := *order
	return func(pager *jobfloorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobFloorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobFloorFilter configures pagination filter.
func WithJobFloorFilter(filter func(*JobFloorQuery) (*JobFloorQuery, error)) JobFloorPaginateOption {
	return func(pager *jobfloorPager) error {
		if filter == nil {
			return errors.New("JobFloorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobfloorPager struct {
	reverse bool
	order   *JobFloorOrder
	filter  func(*JobFloorQuery) (*JobFloorQuery, error)
}

func newJobFloorPager(opts []JobFloorPaginateOption, reverse bool) (*jobfloorPager, error) {
	pager := &jobfloorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobFloorOrder
	}
	return pager, nil
}

func (p *jobfloorPager) applyFilter(query *JobFloorQuery) (*JobFloorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobfloorPager) toCursor(_m *JobFloor) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobfloorPager) applyCursors(query *JobFloorQuery, after, before *Cursor) (*JobFloorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobFloorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobfloorPager) applyOrder(query *JobFloorQuery) *JobFloorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobFloorOrder.Field {
		query = query.Order(DefaultJobFloorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobfloorPager) orderExpr(query *JobFloorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobFloorOrder.Field {
			b.Comma().Ident(DefaultJobFloorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobFloor.
func (_m *JobFloorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobFloorPaginateOption,
) (*JobFloorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobFloorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobFloorConnection{Edges: []*JobFloorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobFloorOrderField defines the ordering field of JobFloor.
type JobFloorOrderField struct {
	// Value extracts the ordering value from the given JobFloor.
	Value    func(*JobFloor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobfloor.OrderOption
	toCursor func(*JobFloor) Cursor
}

// JobFloorOrder defines the ordering of JobFloor.
type JobFloorOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobFloorOrderField `json:"field"`
}

// DefaultJobFloorOrder is the default ordering of JobFloor.
var DefaultJobFloorOrder = &JobFloorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobFloorOrderField{
		Value: func(_m *JobFloor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobfloor.FieldID,
		toTerm: jobfloor.ByID,
		toCursor: func(_m *JobFloor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobFloor into JobFloorEdge.
func (_m *JobFloor) ToEdge(order *JobFloorOrder) *JobFloorEdge {
	if order == nil {
		order = DefaultJobFloorOrder
	}
	return &JobFloorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobOwnerEdge is the edge representation of JobOwner.
type JobOwnerEdge struct {
	Node   *JobOwner `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobOwnerConnection is the connection containing edges to JobOwner.
type JobOwnerConnection struct {
	Edges      []*JobOwnerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobOwnerConnection) build(nodes []*JobOwner, pager *jobownerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobOwner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobOwner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobOwner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobOwnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobOwnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobOwnerPaginateOption enables pagination customization.
type JobOwnerPaginateOption func(*jobownerPager) error

// WithJobOwnerOrder configures pagination ordering.
func WithJobOwnerOrder(order *JobOwnerOrder) JobOwnerPaginateOption {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	o := *order
	return func(pager *jobownerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobOwnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobOwnerFilter configures pagination filter.
func WithJobOwnerFilter(filter func(*JobOwnerQuery) (*JobOwnerQuery, error)) JobOwnerPaginateOption {
	return func(pager *jobownerPager) error {
		if filter == nil {
			return errors.New("JobOwnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobownerPager struct {
	reverse bool
	order   *JobOwnerOrder
	filter  func(*JobOwnerQuery) (*JobOwnerQuery, error)
}

func newJobOwnerPager(opts []JobOwnerPaginateOption, reverse bool) (*jobownerPager, error) {
	pager := &jobownerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobOwnerOrder
	}
	return pager, nil
}

func (p *jobownerPager) applyFilter(query *JobOwnerQuery) (*JobOwnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobownerPager) toCursor(_m *JobOwner) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobownerPager) applyCursors(query *JobOwnerQuery, after, before *Cursor) (*JobOwnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobOwnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobownerPager) applyOrder(query *JobOwnerQuery) *JobOwnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobOwnerOrder.Field {
		query = query.Order(DefaultJobOwnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobownerPager) orderExpr(query *JobOwnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobOwnerOrder.Field {
			b.Comma().Ident(DefaultJobOwnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobOwner.
func (_m *JobOwnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobOwnerPaginateOption,
) (*JobOwnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobOwnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobOwnerConnection{Edges: []*JobOwnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobOwnerOrderField defines the ordering field of JobOwner.
type JobOwnerOrderField struct {
	// Value extracts the ordering value from the given JobOwner.
	Value    func(*JobOwner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobowner.OrderOption
	toCursor func(*JobOwner) Cursor
}

// JobOwnerOrder defines the ordering of JobOwner.
type JobOwnerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobOwnerOrderField `json:"field"`
}

// DefaultJobOwnerOrder is the default ordering of JobOwner.
var DefaultJobOwnerOrder = &JobOwnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobOwnerOrderField{
		Value: func(_m *JobOwner) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobowner.FieldID,
		toTerm: jobowner.ByID,
		toCursor: func(_m *JobOwner) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobOwner into JobOwnerEdge.
func (_m *JobOwner) ToEdge(order *JobOwnerOrder) *JobOwnerEdge {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	return &JobOwnerEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobPaymentsEdge is the edge representation of JobPayments.
type JobPaymentsEdge struct {
	Node   *JobPayments `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobPaymentsConnection is the connection containing edges to JobPayments.
type JobPaymentsConnection struct {
	Edges      []*JobPaymentsEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobPaymentsConnection) build(nodes []*JobPayments, pager *jobpaymentsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobPayments
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobPayments {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobPayments {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobPaymentsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobPaymentsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobPaymentsPaginateOption enables pagination customization.
type JobPaymentsPaginateOption func(*jobpaymentsPager) error

// WithJobPaymentsOrder configures pagination ordering.
func WithJobPaymentsOrder(order *JobPaymentsOrder) JobPaymentsPaginateOption {
	if order == nil {
		order = DefaultJobPaymentsOrder
	}
	o := *order
	return func(pager *jobpaymentsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobPaymentsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobPaymentsFilter configures pagination filter.
func WithJobPaymentsFilter(filter func(*JobPaymentsQuery) (*JobPaymentsQuery, error)) JobPaymentsPaginateOption {
	return func(pager *jobpaymentsPager) error {
		if filter == nil {
			return errors.New("JobPaymentsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobpaymentsPager struct {
	reverse bool
	order   *JobPaymentsOrder
	filter  func(*JobPaymentsQuery) (*JobPaymentsQuery, error)
}

func newJobPaymentsPager(opts []JobPaymentsPaginateOption, reverse bool) (*jobpaymentsPager, error) {
	pager := &jobpaymentsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobPaymentsOrder
	}
	return pager, nil
}

func (p *jobpaymentsPager) applyFilter(query *JobPaymentsQuery) (*JobPaymentsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobpaymentsPager) toCursor(_m *JobPayments) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobpaymentsPager) applyCursors(query *JobPaymentsQuery, after, before *Cursor) (*JobPaymentsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobPaymentsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobpaymentsPager) applyOrder(query *JobPaymentsQuery) *JobPaymentsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobPaymentsOrder.Field {
		query = query.Order(DefaultJobPaymentsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobpaymentsPager) orderExpr(query *JobPaymentsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobPaymentsOrder.Field {
			b.Comma().Ident(DefaultJobPaymentsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobPayments.
func (_m *JobPaymentsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobPaymentsPaginateOption,
) (*JobPaymentsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobPaymentsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobPaymentsConnection{Edges: []*JobPaymentsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobPaymentsOrderField defines the ordering field of JobPayments.
type JobPaymentsOrderField struct {
	// Value extracts the ordering value from the given JobPayments.
	Value    func(*JobPayments) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobpayments.OrderOption
	toCursor func(*JobPayments) Cursor
}

// JobPaymentsOrder defines the ordering of JobPayments.
type JobPaymentsOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobPaymentsOrderField `json:"field"`
}

// DefaultJobPaymentsOrder is the default ordering of JobPayments.
var DefaultJobPaymentsOrder = &JobPaymentsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobPaymentsOrderField{
		Value: func(_m *JobPayments) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobpayments.FieldID,
		toTerm: jobpayments.ByID,
		toCursor: func(_m *JobPayments) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobPayments into JobPaymentsEdge.
func (_m *JobPayments) ToEdge(order *JobPaymentsOrder) *JobPaymentsEdge {
	if order == nil {
		order = DefaultJobPaymentsOrder
	}
	return &JobPaymentsEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobProgressEdge is the edge representation of JobProgress.
type JobProgressEdge struct {
	Node   *JobProgress `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobProgressConnection is the connection containing edges to JobProgress.
type JobProgressConnection struct {
	Edges      []*JobProgressEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobProgressConnection) build(nodes []*JobProgress, pager *jobprogressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobProgress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobProgress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobProgress {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobProgressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobProgressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobProgressPaginateOption enables pagination customization.
type JobProgressPaginateOption func(*jobprogressPager) error

// WithJobProgressOrder configures pagination ordering.
func WithJobProgressOrder(order *JobProgressOrder) JobProgressPaginateOption {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	o := *order
	return func(pager *jobprogressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobProgressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobProgressFilter configures pagination filter.
func WithJobProgressFilter(filter func(*JobProgressQuery) (*JobProgressQuery, error)) JobProgressPaginateOption {
	return func(pager *jobprogressPager) error {
		if filter == nil {
			return errors.New("JobProgressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobprogressPager struct {
	reverse bool
	order   *JobProgressOrder
	filter  func(*JobProgressQuery) (*JobProgressQuery, error)
}

func newJobProgressPager(opts []JobProgressPaginateOption, reverse bool) (*jobprogressPager, error) {
	pager := &jobprogressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobProgressOrder
	}
	return pager, nil
}

func (p *jobprogressPager) applyFilter(query *JobProgressQuery) (*JobProgressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobprogressPager) toCursor(_m *JobProgress) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobprogressPager) applyCursors(query *JobProgressQuery, after, before *Cursor) (*JobProgressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobProgressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobprogressPager) applyOrder(query *JobProgressQuery) *JobProgressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobProgressOrder.Field {
		query = query.Order(DefaultJobProgressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobprogressPager) orderExpr(query *JobProgressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobProgressOrder.Field {
			b.Comma().Ident(DefaultJobProgressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobProgress.
func (_m *JobProgressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobProgressPaginateOption,
) (*JobProgressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobProgressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobProgressConnection{Edges: []*JobProgressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobProgressOrderField defines the ordering field of JobProgress.
type JobProgressOrderField struct {
	// Value extracts the ordering value from the given JobProgress.
	Value    func(*JobProgress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobprogress.OrderOption
	toCursor func(*JobProgress) Cursor
}

// JobProgressOrder defines the ordering of JobProgress.
type JobProgressOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobProgressOrderField `json:"field"`
}

// DefaultJobProgressOrder is the default ordering of JobProgress.
var DefaultJobProgressOrder = &JobProgressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobProgressOrderField{
		Value: func(_m *JobProgress) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobprogress.FieldID,
		toTerm: jobprogress.ByID,
		toCursor: func(_m *JobProgress) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobProgress into JobProgressEdge.
func (_m *JobProgress) ToEdge(order *JobProgressOrder) *JobProgressEdge {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	return &JobProgressEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobReceiptEdge is the edge representation of JobReceipt.
type JobReceiptEdge struct {
	Node   *JobReceipt `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// JobReceiptConnection is the connection containing edges to JobReceipt.
type JobReceiptConnection struct {
	Edges      []*JobReceiptEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *JobReceiptConnection) build(nodes []*JobReceipt, pager *jobreceiptPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobReceipt
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobReceipt {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobReceipt {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobReceiptEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobReceiptEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobReceiptPaginateOption enables pagination customization.
type JobReceiptPaginateOption func(*jobreceiptPager) error

// WithJobReceiptOrder configures pagination ordering.
func WithJobReceiptOrder(order *JobReceiptOrder) JobReceiptPaginateOption {
	if order == nil {
		order = DefaultJobReceiptOrder
	}
	o := *order
	return func(pager *jobreceiptPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobReceiptOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobReceiptFilter configures pagination filter.
func WithJobReceiptFilter(filter func(*JobReceiptQuery) (*JobReceiptQuery, error)) JobReceiptPaginateOption {
	return func(pager *jobreceiptPager) error {
		if filter == nil {
			return errors.New("JobReceiptQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobreceiptPager struct {
	reverse bool
	order   *JobReceiptOrder
	filter  func(*JobReceiptQuery) (*JobReceiptQuery, error)
}

func newJobReceiptPager(opts []JobReceiptPaginateOption, reverse bool) (*jobreceiptPager, error) {
	pager := &jobreceiptPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobReceiptOrder
	}
	return pager, nil
}

func (p *jobreceiptPager) applyFilter(query *JobReceiptQuery) (*JobReceiptQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobreceiptPager) toCursor(_m *JobReceipt) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobreceiptPager) applyCursors(query *JobReceiptQuery, after, before *Cursor) (*JobReceiptQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobReceiptOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobreceiptPager) applyOrder(query *JobReceiptQuery) *JobReceiptQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobReceiptOrder.Field {
		query = query.Order(DefaultJobReceiptOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobreceiptPager) orderExpr(query *JobReceiptQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobReceiptOrder.Field {
			b.Comma().Ident(DefaultJobReceiptOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobReceipt.
func (_m *JobReceiptQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobReceiptPaginateOption,
) (*JobReceiptConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobReceiptPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobReceiptConnection{Edges: []*JobReceiptEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobReceiptOrderField defines the ordering field of JobReceipt.
type JobReceiptOrderField struct {
	// Value extracts the ordering value from the given JobReceipt.
	Value    func(*JobReceipt) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobreceipt.OrderOption
	toCursor func(*JobReceipt) Cursor
}

// JobReceiptOrder defines the ordering of JobReceipt.
type JobReceiptOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *JobReceiptOrderField `json:"field"`
}

// DefaultJobReceiptOrder is the default ordering of JobReceipt.
var DefaultJobReceiptOrder = &JobReceiptOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobReceiptOrderField{
		Value: func(_m *JobReceipt) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobreceipt.FieldID,
		toTerm: jobreceipt.ByID,
		toCursor: func(_m *JobReceipt) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobReceipt into JobReceiptEdge.
func (_m *JobReceipt) ToEdge(order *JobReceiptOrder) *JobReceiptEdge {
	if order == nil {
		order = DefaultJobReceiptOrder
	}
	return &JobReceiptEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobRelationsEdge is the edge representation of JobRelations.
type JobRelationsEdge struct {
	Node   *JobRelations `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// JobRelationsConnection is the connection containing edges to JobRelations.
type JobRelationsConnection struct {
	Edges      []*JobRelationsEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *JobRelationsConnection) build(nodes []*JobRelations, pager *jobrelationsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobRelations
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobRelations {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobRelations {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobRelationsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobRelationsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobRelationsPaginateOption enables pagination customization.
type JobRelationsPaginateOption func(*jobrelationsPager) error

// WithJobRelationsOrder configures pagination ordering.
func WithJobRelationsOrder(order *JobRelationsOrder) JobRelationsPaginateOption {
	if order == nil {
		order = DefaultJobRelationsOrder
	}
	o := *order
	return func(pager *jobrelationsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobRelationsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobRelationsFilter configures pagination filter.
func WithJobRelationsFilter(filter func(*JobRelationsQuery) (*JobRelationsQuery, error)) JobRelationsPaginateOption {
	return func(pager *jobrelationsPager) error {
		if filter == nil {
			return errors.New("JobRelationsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobrelationsPager struct {
	reverse bool
	order   *JobRelationsOrder
	filter  func(*JobRelationsQuery) (*JobRelationsQuery, error)
}

func newJobRelationsPager(opts []JobRelationsPaginateOption, reverse bool) (*jobrelationsPager, error) {
	pager := &jobrelationsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobRelationsOrder
	}
	return pager, nil
}

func (p *jobrelationsPager) applyFilter(query *JobRelationsQuery) (*JobRelationsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobrelationsPager) toCursor(_m *JobRelations) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobrelationsPager) applyCursors(query *JobRelationsQuery, after, before *Cursor) (*JobRelationsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobRelationsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobrelationsPager) applyOrder(query *JobRelationsQuery) *JobRelationsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobRelationsOrder.Field {
		query = query.Order(DefaultJobRelationsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobrelationsPager) orderExpr(query *JobRelationsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobRelationsOrder.Field {
			b.Comma().Ident(DefaultJobRelationsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobRelations.
func (_m *JobRelationsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobRelationsPaginateOption,
) (*JobRelationsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobRelationsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobRelationsConnection{Edges: []*JobRelationsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobRelationsOrderField defines the ordering field of JobRelations.
type JobRelationsOrderField struct {
	// Value extracts the ordering value from the given JobRelations.
	Value    func(*JobRelations) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobrelations.OrderOption
	toCursor func(*JobRelations) Cursor
}

// JobRelationsOrder defines the ordering of JobRelations.
type JobRelationsOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *JobRelationsOrderField `json:"field"`
}

// DefaultJobRelationsOrder is the default ordering of JobRelations.
var DefaultJobRelationsOrder = &JobRelationsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobRelationsOrderField{
		Value: func(_m *JobRelations) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobrelations.FieldID,
		toTerm: jobrelations.ByID,
		toCursor: func(_m *JobRelations) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobRelations into JobRelationsEdge.
func (_m *JobRelations) ToEdge(order *JobRelationsOrder) *JobRelationsEdge {
	if order == nil {
		order = DefaultJobRelationsOrder
	}
	return &JobRelationsEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// JobSupervisorEdge is the edge representation of JobSupervisor.
type JobSupervisorEdge struct {
	Node   *JobSupervisor `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// JobSupervisorConnection is the connection containing edges to JobSupervisor.
type JobSupervisorConnection struct {
	Edges      []*JobSupervisorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *JobSupervisorConnection) build(nodes []*JobSupervisor, pager *jobsupervisorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobSupervisor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobSupervisor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobSupervisor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobSupervisorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobSupervisorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobSupervisorPaginateOption enables pagination customization.
type JobSupervisorPaginateOption func(*jobsupervisorPager) error

// WithJobSupervisorOrder configures pagination ordering.
func WithJobSupervisorOrder(order *JobSupervisorOrder) JobSupervisorPaginateOption {
	if order == nil {
		order = DefaultJobSupervisorOrder
	}
	o := *order
	return func(pager *jobsupervisorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobSupervisorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobSupervisorFilter configures pagination filter.
func WithJobSupervisorFilter(filter func(*JobSupervisorQuery) (*JobSupervisorQuery, error)) JobSupervisorPaginateOption {
	return func(pager *jobsupervisorPager) error {
		if filter == nil {
			return errors.New("JobSupervisorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobsupervisorPager struct {
	reverse bool
	order   *JobSupervisorOrder
	filter  func(*JobSupervisorQuery) (*JobSupervisorQuery, error)
}

func newJobSupervisorPager(opts []JobSupervisorPaginateOption, reverse bool) (*jobsupervisorPager, error) {
	pager := &jobsupervisorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobSupervisorOrder
	}
	return pager, nil
}

func (p *jobsupervisorPager) applyFilter(query *JobSupervisorQuery) (*JobSupervisorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobsupervisorPager) toCursor(_m *JobSupervisor) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *jobsupervisorPager) applyCursors(query *JobSupervisorQuery, after, before *Cursor) (*JobSupervisorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobSupervisorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobsupervisorPager) applyOrder(query *JobSupervisorQuery) *JobSupervisorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobSupervisorOrder.Field {
		query = query.Order(DefaultJobSupervisorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobsupervisorPager) orderExpr(query *JobSupervisorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobSupervisorOrder.Field {
			b.Comma().Ident(DefaultJobSupervisorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobSupervisor.
func (_m *JobSupervisorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobSupervisorPaginateOption,
) (*JobSupervisorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobSupervisorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &JobSupervisorConnection{Edges: []*JobSupervisorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobSupervisorOrderField defines the ordering field of JobSupervisor.
type JobSupervisorOrderField struct {
	// Value extracts the ordering value from the given JobSupervisor.
	Value    func(*JobSupervisor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobsupervisor.OrderOption
	toCursor func(*JobSupervisor) Cursor
}

// JobSupervisorOrder defines the ordering of JobSupervisor.
type JobSupervisorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *JobSupervisorOrderField `json:"field"`
}

// DefaultJobSupervisorOrder is the default ordering of JobSupervisor.
var DefaultJobSupervisorOrder = &JobSupervisorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobSupervisorOrderField{
		Value: func(_m *JobSupervisor) (ent.Value, error) {
			return _m.ID, nil
		},
		column: jobsupervisor.FieldID,
		toTerm: jobsupervisor.ByID,
		toCursor: func(_m *JobSupervisor) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts JobSupervisor into JobSupervisorEdge.
func (_m *JobSupervisor) ToEdge(order *JobSupervisorOrder) *JobSupervisorEdge {
	if order == nil {
		order = DefaultJobSupervisorOrder
	}
	return &JobSupervisorEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(_m *User) Cursor {
	return p.order.Field.toCursor(_m)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (_m *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if _m, err = pager.applyFilter(_m); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := _m.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if _m, err = pager.applyCursors(_m, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		_m.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := _m.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	_m = pager.applyOrder(_m)
	nodes, err := _m.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(_m *User) (ent.Value, error) {
			return _m.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(_m *User) Cursor {
			return Cursor{ID: _m.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (_m *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   _m,
		Cursor: order.Field.toCursor(_m),
	}
}
