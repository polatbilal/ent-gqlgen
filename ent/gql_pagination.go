// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"gqlgen-ent/ent/companycareer"
	"gqlgen-ent/ent/companydetail"
	"gqlgen-ent/ent/companyengineer"
	"gqlgen-ent/ent/companyowner"
	"gqlgen-ent/ent/companyposition"
	"gqlgen-ent/ent/jobauthor"
	"gqlgen-ent/ent/jobcontractor"
	"gqlgen-ent/ent/jobdetail"
	"gqlgen-ent/ent/joblayer"
	"gqlgen-ent/ent/jobowner"
	"gqlgen-ent/ent/jobprogress"
	"gqlgen-ent/ent/user"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CompanyCareerEdge is the edge representation of CompanyCareer.
type CompanyCareerEdge struct {
	Node   *CompanyCareer `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CompanyCareerConnection is the connection containing edges to CompanyCareer.
type CompanyCareerConnection struct {
	Edges      []*CompanyCareerEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *CompanyCareerConnection) build(nodes []*CompanyCareer, pager *companycareerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyCareer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyCareer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyCareer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyCareerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyCareerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyCareerPaginateOption enables pagination customization.
type CompanyCareerPaginateOption func(*companycareerPager) error

// WithCompanyCareerOrder configures pagination ordering.
func WithCompanyCareerOrder(order *CompanyCareerOrder) CompanyCareerPaginateOption {
	if order == nil {
		order = DefaultCompanyCareerOrder
	}
	o := *order
	return func(pager *companycareerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyCareerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyCareerFilter configures pagination filter.
func WithCompanyCareerFilter(filter func(*CompanyCareerQuery) (*CompanyCareerQuery, error)) CompanyCareerPaginateOption {
	return func(pager *companycareerPager) error {
		if filter == nil {
			return errors.New("CompanyCareerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companycareerPager struct {
	reverse bool
	order   *CompanyCareerOrder
	filter  func(*CompanyCareerQuery) (*CompanyCareerQuery, error)
}

func newCompanyCareerPager(opts []CompanyCareerPaginateOption, reverse bool) (*companycareerPager, error) {
	pager := &companycareerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyCareerOrder
	}
	return pager, nil
}

func (p *companycareerPager) applyFilter(query *CompanyCareerQuery) (*CompanyCareerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companycareerPager) toCursor(cc *CompanyCareer) Cursor {
	return p.order.Field.toCursor(cc)
}

func (p *companycareerPager) applyCursors(query *CompanyCareerQuery, after, before *Cursor) (*CompanyCareerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyCareerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companycareerPager) applyOrder(query *CompanyCareerQuery) *CompanyCareerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyCareerOrder.Field {
		query = query.Order(DefaultCompanyCareerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companycareerPager) orderExpr(query *CompanyCareerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyCareerOrder.Field {
			b.Comma().Ident(DefaultCompanyCareerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyCareer.
func (cc *CompanyCareerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyCareerPaginateOption,
) (*CompanyCareerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyCareerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cc, err = pager.applyFilter(cc); err != nil {
		return nil, err
	}
	conn := &CompanyCareerConnection{Edges: []*CompanyCareerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cc, err = pager.applyCursors(cc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cc = pager.applyOrder(cc)
	nodes, err := cc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyCareerOrderField defines the ordering field of CompanyCareer.
type CompanyCareerOrderField struct {
	// Value extracts the ordering value from the given CompanyCareer.
	Value    func(*CompanyCareer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companycareer.OrderOption
	toCursor func(*CompanyCareer) Cursor
}

// CompanyCareerOrder defines the ordering of CompanyCareer.
type CompanyCareerOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CompanyCareerOrderField `json:"field"`
}

// DefaultCompanyCareerOrder is the default ordering of CompanyCareer.
var DefaultCompanyCareerOrder = &CompanyCareerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyCareerOrderField{
		Value: func(cc *CompanyCareer) (ent.Value, error) {
			return cc.ID, nil
		},
		column: companycareer.FieldID,
		toTerm: companycareer.ByID,
		toCursor: func(cc *CompanyCareer) Cursor {
			return Cursor{ID: cc.ID}
		},
	},
}

// ToEdge converts CompanyCareer into CompanyCareerEdge.
func (cc *CompanyCareer) ToEdge(order *CompanyCareerOrder) *CompanyCareerEdge {
	if order == nil {
		order = DefaultCompanyCareerOrder
	}
	return &CompanyCareerEdge{
		Node:   cc,
		Cursor: order.Field.toCursor(cc),
	}
}

// CompanyDetailEdge is the edge representation of CompanyDetail.
type CompanyDetailEdge struct {
	Node   *CompanyDetail `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CompanyDetailConnection is the connection containing edges to CompanyDetail.
type CompanyDetailConnection struct {
	Edges      []*CompanyDetailEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *CompanyDetailConnection) build(nodes []*CompanyDetail, pager *companydetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyDetailPaginateOption enables pagination customization.
type CompanyDetailPaginateOption func(*companydetailPager) error

// WithCompanyDetailOrder configures pagination ordering.
func WithCompanyDetailOrder(order *CompanyDetailOrder) CompanyDetailPaginateOption {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	o := *order
	return func(pager *companydetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyDetailFilter configures pagination filter.
func WithCompanyDetailFilter(filter func(*CompanyDetailQuery) (*CompanyDetailQuery, error)) CompanyDetailPaginateOption {
	return func(pager *companydetailPager) error {
		if filter == nil {
			return errors.New("CompanyDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companydetailPager struct {
	reverse bool
	order   *CompanyDetailOrder
	filter  func(*CompanyDetailQuery) (*CompanyDetailQuery, error)
}

func newCompanyDetailPager(opts []CompanyDetailPaginateOption, reverse bool) (*companydetailPager, error) {
	pager := &companydetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyDetailOrder
	}
	return pager, nil
}

func (p *companydetailPager) applyFilter(query *CompanyDetailQuery) (*CompanyDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companydetailPager) toCursor(cd *CompanyDetail) Cursor {
	return p.order.Field.toCursor(cd)
}

func (p *companydetailPager) applyCursors(query *CompanyDetailQuery, after, before *Cursor) (*CompanyDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companydetailPager) applyOrder(query *CompanyDetailQuery) *CompanyDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyDetailOrder.Field {
		query = query.Order(DefaultCompanyDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companydetailPager) orderExpr(query *CompanyDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyDetailOrder.Field {
			b.Comma().Ident(DefaultCompanyDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyDetail.
func (cd *CompanyDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyDetailPaginateOption,
) (*CompanyDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CompanyDetailConnection{Edges: []*CompanyDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyDetailOrderField defines the ordering field of CompanyDetail.
type CompanyDetailOrderField struct {
	// Value extracts the ordering value from the given CompanyDetail.
	Value    func(*CompanyDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companydetail.OrderOption
	toCursor func(*CompanyDetail) Cursor
}

// CompanyDetailOrder defines the ordering of CompanyDetail.
type CompanyDetailOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CompanyDetailOrderField `json:"field"`
}

// DefaultCompanyDetailOrder is the default ordering of CompanyDetail.
var DefaultCompanyDetailOrder = &CompanyDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyDetailOrderField{
		Value: func(cd *CompanyDetail) (ent.Value, error) {
			return cd.ID, nil
		},
		column: companydetail.FieldID,
		toTerm: companydetail.ByID,
		toCursor: func(cd *CompanyDetail) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CompanyDetail into CompanyDetailEdge.
func (cd *CompanyDetail) ToEdge(order *CompanyDetailOrder) *CompanyDetailEdge {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	return &CompanyDetailEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CompanyEngineerEdge is the edge representation of CompanyEngineer.
type CompanyEngineerEdge struct {
	Node   *CompanyEngineer `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CompanyEngineerConnection is the connection containing edges to CompanyEngineer.
type CompanyEngineerConnection struct {
	Edges      []*CompanyEngineerEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CompanyEngineerConnection) build(nodes []*CompanyEngineer, pager *companyengineerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyEngineer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEngineerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEngineerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyEngineerPaginateOption enables pagination customization.
type CompanyEngineerPaginateOption func(*companyengineerPager) error

// WithCompanyEngineerOrder configures pagination ordering.
func WithCompanyEngineerOrder(order *CompanyEngineerOrder) CompanyEngineerPaginateOption {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	o := *order
	return func(pager *companyengineerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyEngineerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyEngineerFilter configures pagination filter.
func WithCompanyEngineerFilter(filter func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)) CompanyEngineerPaginateOption {
	return func(pager *companyengineerPager) error {
		if filter == nil {
			return errors.New("CompanyEngineerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyengineerPager struct {
	reverse bool
	order   *CompanyEngineerOrder
	filter  func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)
}

func newCompanyEngineerPager(opts []CompanyEngineerPaginateOption, reverse bool) (*companyengineerPager, error) {
	pager := &companyengineerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyEngineerOrder
	}
	return pager, nil
}

func (p *companyengineerPager) applyFilter(query *CompanyEngineerQuery) (*CompanyEngineerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyengineerPager) toCursor(ce *CompanyEngineer) Cursor {
	return p.order.Field.toCursor(ce)
}

func (p *companyengineerPager) applyCursors(query *CompanyEngineerQuery, after, before *Cursor) (*CompanyEngineerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyEngineerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyengineerPager) applyOrder(query *CompanyEngineerQuery) *CompanyEngineerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyEngineerOrder.Field {
		query = query.Order(DefaultCompanyEngineerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyengineerPager) orderExpr(query *CompanyEngineerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyEngineerOrder.Field {
			b.Comma().Ident(DefaultCompanyEngineerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyEngineer.
func (ce *CompanyEngineerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyEngineerPaginateOption,
) (*CompanyEngineerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyEngineerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ce, err = pager.applyFilter(ce); err != nil {
		return nil, err
	}
	conn := &CompanyEngineerConnection{Edges: []*CompanyEngineerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ce.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ce, err = pager.applyCursors(ce, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ce.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ce.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ce = pager.applyOrder(ce)
	nodes, err := ce.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyEngineerOrderField defines the ordering field of CompanyEngineer.
type CompanyEngineerOrderField struct {
	// Value extracts the ordering value from the given CompanyEngineer.
	Value    func(*CompanyEngineer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyengineer.OrderOption
	toCursor func(*CompanyEngineer) Cursor
}

// CompanyEngineerOrder defines the ordering of CompanyEngineer.
type CompanyEngineerOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CompanyEngineerOrderField `json:"field"`
}

// DefaultCompanyEngineerOrder is the default ordering of CompanyEngineer.
var DefaultCompanyEngineerOrder = &CompanyEngineerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyEngineerOrderField{
		Value: func(ce *CompanyEngineer) (ent.Value, error) {
			return ce.ID, nil
		},
		column: companyengineer.FieldID,
		toTerm: companyengineer.ByID,
		toCursor: func(ce *CompanyEngineer) Cursor {
			return Cursor{ID: ce.ID}
		},
	},
}

// ToEdge converts CompanyEngineer into CompanyEngineerEdge.
func (ce *CompanyEngineer) ToEdge(order *CompanyEngineerOrder) *CompanyEngineerEdge {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	return &CompanyEngineerEdge{
		Node:   ce,
		Cursor: order.Field.toCursor(ce),
	}
}

// CompanyOwnerEdge is the edge representation of CompanyOwner.
type CompanyOwnerEdge struct {
	Node   *CompanyOwner `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CompanyOwnerConnection is the connection containing edges to CompanyOwner.
type CompanyOwnerConnection struct {
	Edges      []*CompanyOwnerEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CompanyOwnerConnection) build(nodes []*CompanyOwner, pager *companyownerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyOwner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyOwner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyOwner {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyOwnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyOwnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyOwnerPaginateOption enables pagination customization.
type CompanyOwnerPaginateOption func(*companyownerPager) error

// WithCompanyOwnerOrder configures pagination ordering.
func WithCompanyOwnerOrder(order *CompanyOwnerOrder) CompanyOwnerPaginateOption {
	if order == nil {
		order = DefaultCompanyOwnerOrder
	}
	o := *order
	return func(pager *companyownerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyOwnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyOwnerFilter configures pagination filter.
func WithCompanyOwnerFilter(filter func(*CompanyOwnerQuery) (*CompanyOwnerQuery, error)) CompanyOwnerPaginateOption {
	return func(pager *companyownerPager) error {
		if filter == nil {
			return errors.New("CompanyOwnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyownerPager struct {
	reverse bool
	order   *CompanyOwnerOrder
	filter  func(*CompanyOwnerQuery) (*CompanyOwnerQuery, error)
}

func newCompanyOwnerPager(opts []CompanyOwnerPaginateOption, reverse bool) (*companyownerPager, error) {
	pager := &companyownerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyOwnerOrder
	}
	return pager, nil
}

func (p *companyownerPager) applyFilter(query *CompanyOwnerQuery) (*CompanyOwnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyownerPager) toCursor(co *CompanyOwner) Cursor {
	return p.order.Field.toCursor(co)
}

func (p *companyownerPager) applyCursors(query *CompanyOwnerQuery, after, before *Cursor) (*CompanyOwnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyOwnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyownerPager) applyOrder(query *CompanyOwnerQuery) *CompanyOwnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyOwnerOrder.Field {
		query = query.Order(DefaultCompanyOwnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyownerPager) orderExpr(query *CompanyOwnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyOwnerOrder.Field {
			b.Comma().Ident(DefaultCompanyOwnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyOwner.
func (co *CompanyOwnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyOwnerPaginateOption,
) (*CompanyOwnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyOwnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if co, err = pager.applyFilter(co); err != nil {
		return nil, err
	}
	conn := &CompanyOwnerConnection{Edges: []*CompanyOwnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := co.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if co, err = pager.applyCursors(co, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		co.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := co.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	co = pager.applyOrder(co)
	nodes, err := co.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyOwnerOrderField defines the ordering field of CompanyOwner.
type CompanyOwnerOrderField struct {
	// Value extracts the ordering value from the given CompanyOwner.
	Value    func(*CompanyOwner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyowner.OrderOption
	toCursor func(*CompanyOwner) Cursor
}

// CompanyOwnerOrder defines the ordering of CompanyOwner.
type CompanyOwnerOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CompanyOwnerOrderField `json:"field"`
}

// DefaultCompanyOwnerOrder is the default ordering of CompanyOwner.
var DefaultCompanyOwnerOrder = &CompanyOwnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyOwnerOrderField{
		Value: func(co *CompanyOwner) (ent.Value, error) {
			return co.ID, nil
		},
		column: companyowner.FieldID,
		toTerm: companyowner.ByID,
		toCursor: func(co *CompanyOwner) Cursor {
			return Cursor{ID: co.ID}
		},
	},
}

// ToEdge converts CompanyOwner into CompanyOwnerEdge.
func (co *CompanyOwner) ToEdge(order *CompanyOwnerOrder) *CompanyOwnerEdge {
	if order == nil {
		order = DefaultCompanyOwnerOrder
	}
	return &CompanyOwnerEdge{
		Node:   co,
		Cursor: order.Field.toCursor(co),
	}
}

// CompanyPositionEdge is the edge representation of CompanyPosition.
type CompanyPositionEdge struct {
	Node   *CompanyPosition `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CompanyPositionConnection is the connection containing edges to CompanyPosition.
type CompanyPositionConnection struct {
	Edges      []*CompanyPositionEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CompanyPositionConnection) build(nodes []*CompanyPosition, pager *companypositionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyPosition
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyPosition {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyPosition {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyPositionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyPositionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyPositionPaginateOption enables pagination customization.
type CompanyPositionPaginateOption func(*companypositionPager) error

// WithCompanyPositionOrder configures pagination ordering.
func WithCompanyPositionOrder(order *CompanyPositionOrder) CompanyPositionPaginateOption {
	if order == nil {
		order = DefaultCompanyPositionOrder
	}
	o := *order
	return func(pager *companypositionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyPositionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyPositionFilter configures pagination filter.
func WithCompanyPositionFilter(filter func(*CompanyPositionQuery) (*CompanyPositionQuery, error)) CompanyPositionPaginateOption {
	return func(pager *companypositionPager) error {
		if filter == nil {
			return errors.New("CompanyPositionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companypositionPager struct {
	reverse bool
	order   *CompanyPositionOrder
	filter  func(*CompanyPositionQuery) (*CompanyPositionQuery, error)
}

func newCompanyPositionPager(opts []CompanyPositionPaginateOption, reverse bool) (*companypositionPager, error) {
	pager := &companypositionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyPositionOrder
	}
	return pager, nil
}

func (p *companypositionPager) applyFilter(query *CompanyPositionQuery) (*CompanyPositionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companypositionPager) toCursor(cp *CompanyPosition) Cursor {
	return p.order.Field.toCursor(cp)
}

func (p *companypositionPager) applyCursors(query *CompanyPositionQuery, after, before *Cursor) (*CompanyPositionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyPositionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companypositionPager) applyOrder(query *CompanyPositionQuery) *CompanyPositionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyPositionOrder.Field {
		query = query.Order(DefaultCompanyPositionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companypositionPager) orderExpr(query *CompanyPositionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyPositionOrder.Field {
			b.Comma().Ident(DefaultCompanyPositionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyPosition.
func (cp *CompanyPositionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyPositionPaginateOption,
) (*CompanyPositionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyPositionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cp, err = pager.applyFilter(cp); err != nil {
		return nil, err
	}
	conn := &CompanyPositionConnection{Edges: []*CompanyPositionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cp, err = pager.applyCursors(cp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cp = pager.applyOrder(cp)
	nodes, err := cp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyPositionOrderField defines the ordering field of CompanyPosition.
type CompanyPositionOrderField struct {
	// Value extracts the ordering value from the given CompanyPosition.
	Value    func(*CompanyPosition) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyposition.OrderOption
	toCursor func(*CompanyPosition) Cursor
}

// CompanyPositionOrder defines the ordering of CompanyPosition.
type CompanyPositionOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CompanyPositionOrderField `json:"field"`
}

// DefaultCompanyPositionOrder is the default ordering of CompanyPosition.
var DefaultCompanyPositionOrder = &CompanyPositionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyPositionOrderField{
		Value: func(cp *CompanyPosition) (ent.Value, error) {
			return cp.ID, nil
		},
		column: companyposition.FieldID,
		toTerm: companyposition.ByID,
		toCursor: func(cp *CompanyPosition) Cursor {
			return Cursor{ID: cp.ID}
		},
	},
}

// ToEdge converts CompanyPosition into CompanyPositionEdge.
func (cp *CompanyPosition) ToEdge(order *CompanyPositionOrder) *CompanyPositionEdge {
	if order == nil {
		order = DefaultCompanyPositionOrder
	}
	return &CompanyPositionEdge{
		Node:   cp,
		Cursor: order.Field.toCursor(cp),
	}
}

// JobAuthorEdge is the edge representation of JobAuthor.
type JobAuthorEdge struct {
	Node   *JobAuthor `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobAuthorConnection is the connection containing edges to JobAuthor.
type JobAuthorConnection struct {
	Edges      []*JobAuthorEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobAuthorConnection) build(nodes []*JobAuthor, pager *jobauthorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobAuthor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobAuthor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobAuthor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobAuthorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobAuthorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobAuthorPaginateOption enables pagination customization.
type JobAuthorPaginateOption func(*jobauthorPager) error

// WithJobAuthorOrder configures pagination ordering.
func WithJobAuthorOrder(order *JobAuthorOrder) JobAuthorPaginateOption {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	o := *order
	return func(pager *jobauthorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobAuthorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobAuthorFilter configures pagination filter.
func WithJobAuthorFilter(filter func(*JobAuthorQuery) (*JobAuthorQuery, error)) JobAuthorPaginateOption {
	return func(pager *jobauthorPager) error {
		if filter == nil {
			return errors.New("JobAuthorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobauthorPager struct {
	reverse bool
	order   *JobAuthorOrder
	filter  func(*JobAuthorQuery) (*JobAuthorQuery, error)
}

func newJobAuthorPager(opts []JobAuthorPaginateOption, reverse bool) (*jobauthorPager, error) {
	pager := &jobauthorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobAuthorOrder
	}
	return pager, nil
}

func (p *jobauthorPager) applyFilter(query *JobAuthorQuery) (*JobAuthorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobauthorPager) toCursor(ja *JobAuthor) Cursor {
	return p.order.Field.toCursor(ja)
}

func (p *jobauthorPager) applyCursors(query *JobAuthorQuery, after, before *Cursor) (*JobAuthorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobAuthorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobauthorPager) applyOrder(query *JobAuthorQuery) *JobAuthorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobAuthorOrder.Field {
		query = query.Order(DefaultJobAuthorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobauthorPager) orderExpr(query *JobAuthorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobAuthorOrder.Field {
			b.Comma().Ident(DefaultJobAuthorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobAuthor.
func (ja *JobAuthorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobAuthorPaginateOption,
) (*JobAuthorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobAuthorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ja, err = pager.applyFilter(ja); err != nil {
		return nil, err
	}
	conn := &JobAuthorConnection{Edges: []*JobAuthorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ja.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ja, err = pager.applyCursors(ja, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ja.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ja.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ja = pager.applyOrder(ja)
	nodes, err := ja.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobAuthorOrderField defines the ordering field of JobAuthor.
type JobAuthorOrderField struct {
	// Value extracts the ordering value from the given JobAuthor.
	Value    func(*JobAuthor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobauthor.OrderOption
	toCursor func(*JobAuthor) Cursor
}

// JobAuthorOrder defines the ordering of JobAuthor.
type JobAuthorOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobAuthorOrderField `json:"field"`
}

// DefaultJobAuthorOrder is the default ordering of JobAuthor.
var DefaultJobAuthorOrder = &JobAuthorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobAuthorOrderField{
		Value: func(ja *JobAuthor) (ent.Value, error) {
			return ja.ID, nil
		},
		column: jobauthor.FieldID,
		toTerm: jobauthor.ByID,
		toCursor: func(ja *JobAuthor) Cursor {
			return Cursor{ID: ja.ID}
		},
	},
}

// ToEdge converts JobAuthor into JobAuthorEdge.
func (ja *JobAuthor) ToEdge(order *JobAuthorOrder) *JobAuthorEdge {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	return &JobAuthorEdge{
		Node:   ja,
		Cursor: order.Field.toCursor(ja),
	}
}

// JobContractorEdge is the edge representation of JobContractor.
type JobContractorEdge struct {
	Node   *JobContractor `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// JobContractorConnection is the connection containing edges to JobContractor.
type JobContractorConnection struct {
	Edges      []*JobContractorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *JobContractorConnection) build(nodes []*JobContractor, pager *jobcontractorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobContractor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobContractor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobContractor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobContractorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobContractorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobContractorPaginateOption enables pagination customization.
type JobContractorPaginateOption func(*jobcontractorPager) error

// WithJobContractorOrder configures pagination ordering.
func WithJobContractorOrder(order *JobContractorOrder) JobContractorPaginateOption {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	o := *order
	return func(pager *jobcontractorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobContractorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobContractorFilter configures pagination filter.
func WithJobContractorFilter(filter func(*JobContractorQuery) (*JobContractorQuery, error)) JobContractorPaginateOption {
	return func(pager *jobcontractorPager) error {
		if filter == nil {
			return errors.New("JobContractorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobcontractorPager struct {
	reverse bool
	order   *JobContractorOrder
	filter  func(*JobContractorQuery) (*JobContractorQuery, error)
}

func newJobContractorPager(opts []JobContractorPaginateOption, reverse bool) (*jobcontractorPager, error) {
	pager := &jobcontractorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobContractorOrder
	}
	return pager, nil
}

func (p *jobcontractorPager) applyFilter(query *JobContractorQuery) (*JobContractorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobcontractorPager) toCursor(jc *JobContractor) Cursor {
	return p.order.Field.toCursor(jc)
}

func (p *jobcontractorPager) applyCursors(query *JobContractorQuery, after, before *Cursor) (*JobContractorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobContractorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobcontractorPager) applyOrder(query *JobContractorQuery) *JobContractorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobContractorOrder.Field {
		query = query.Order(DefaultJobContractorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobcontractorPager) orderExpr(query *JobContractorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobContractorOrder.Field {
			b.Comma().Ident(DefaultJobContractorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobContractor.
func (jc *JobContractorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobContractorPaginateOption,
) (*JobContractorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobContractorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jc, err = pager.applyFilter(jc); err != nil {
		return nil, err
	}
	conn := &JobContractorConnection{Edges: []*JobContractorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jc, err = pager.applyCursors(jc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jc = pager.applyOrder(jc)
	nodes, err := jc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobContractorOrderField defines the ordering field of JobContractor.
type JobContractorOrderField struct {
	// Value extracts the ordering value from the given JobContractor.
	Value    func(*JobContractor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobcontractor.OrderOption
	toCursor func(*JobContractor) Cursor
}

// JobContractorOrder defines the ordering of JobContractor.
type JobContractorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *JobContractorOrderField `json:"field"`
}

// DefaultJobContractorOrder is the default ordering of JobContractor.
var DefaultJobContractorOrder = &JobContractorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobContractorOrderField{
		Value: func(jc *JobContractor) (ent.Value, error) {
			return jc.ID, nil
		},
		column: jobcontractor.FieldID,
		toTerm: jobcontractor.ByID,
		toCursor: func(jc *JobContractor) Cursor {
			return Cursor{ID: jc.ID}
		},
	},
}

// ToEdge converts JobContractor into JobContractorEdge.
func (jc *JobContractor) ToEdge(order *JobContractorOrder) *JobContractorEdge {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	return &JobContractorEdge{
		Node:   jc,
		Cursor: order.Field.toCursor(jc),
	}
}

// JobDetailEdge is the edge representation of JobDetail.
type JobDetailEdge struct {
	Node   *JobDetail `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobDetailConnection is the connection containing edges to JobDetail.
type JobDetailConnection struct {
	Edges      []*JobDetailEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobDetailConnection) build(nodes []*JobDetail, pager *jobdetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobDetailPaginateOption enables pagination customization.
type JobDetailPaginateOption func(*jobdetailPager) error

// WithJobDetailOrder configures pagination ordering.
func WithJobDetailOrder(order *JobDetailOrder) JobDetailPaginateOption {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	o := *order
	return func(pager *jobdetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobDetailFilter configures pagination filter.
func WithJobDetailFilter(filter func(*JobDetailQuery) (*JobDetailQuery, error)) JobDetailPaginateOption {
	return func(pager *jobdetailPager) error {
		if filter == nil {
			return errors.New("JobDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobdetailPager struct {
	reverse bool
	order   *JobDetailOrder
	filter  func(*JobDetailQuery) (*JobDetailQuery, error)
}

func newJobDetailPager(opts []JobDetailPaginateOption, reverse bool) (*jobdetailPager, error) {
	pager := &jobdetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobDetailOrder
	}
	return pager, nil
}

func (p *jobdetailPager) applyFilter(query *JobDetailQuery) (*JobDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobdetailPager) toCursor(jd *JobDetail) Cursor {
	return p.order.Field.toCursor(jd)
}

func (p *jobdetailPager) applyCursors(query *JobDetailQuery, after, before *Cursor) (*JobDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobdetailPager) applyOrder(query *JobDetailQuery) *JobDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobDetailOrder.Field {
		query = query.Order(DefaultJobDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobdetailPager) orderExpr(query *JobDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobDetailOrder.Field {
			b.Comma().Ident(DefaultJobDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobDetail.
func (jd *JobDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobDetailPaginateOption,
) (*JobDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jd, err = pager.applyFilter(jd); err != nil {
		return nil, err
	}
	conn := &JobDetailConnection{Edges: []*JobDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jd, err = pager.applyCursors(jd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jd = pager.applyOrder(jd)
	nodes, err := jd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobDetailOrderField defines the ordering field of JobDetail.
type JobDetailOrderField struct {
	// Value extracts the ordering value from the given JobDetail.
	Value    func(*JobDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobdetail.OrderOption
	toCursor func(*JobDetail) Cursor
}

// JobDetailOrder defines the ordering of JobDetail.
type JobDetailOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobDetailOrderField `json:"field"`
}

// DefaultJobDetailOrder is the default ordering of JobDetail.
var DefaultJobDetailOrder = &JobDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobDetailOrderField{
		Value: func(jd *JobDetail) (ent.Value, error) {
			return jd.ID, nil
		},
		column: jobdetail.FieldID,
		toTerm: jobdetail.ByID,
		toCursor: func(jd *JobDetail) Cursor {
			return Cursor{ID: jd.ID}
		},
	},
}

// ToEdge converts JobDetail into JobDetailEdge.
func (jd *JobDetail) ToEdge(order *JobDetailOrder) *JobDetailEdge {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	return &JobDetailEdge{
		Node:   jd,
		Cursor: order.Field.toCursor(jd),
	}
}

// JobLayerEdge is the edge representation of JobLayer.
type JobLayerEdge struct {
	Node   *JobLayer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobLayerConnection is the connection containing edges to JobLayer.
type JobLayerConnection struct {
	Edges      []*JobLayerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobLayerConnection) build(nodes []*JobLayer, pager *joblayerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobLayer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobLayer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobLayer {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobLayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobLayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobLayerPaginateOption enables pagination customization.
type JobLayerPaginateOption func(*joblayerPager) error

// WithJobLayerOrder configures pagination ordering.
func WithJobLayerOrder(order *JobLayerOrder) JobLayerPaginateOption {
	if order == nil {
		order = DefaultJobLayerOrder
	}
	o := *order
	return func(pager *joblayerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobLayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobLayerFilter configures pagination filter.
func WithJobLayerFilter(filter func(*JobLayerQuery) (*JobLayerQuery, error)) JobLayerPaginateOption {
	return func(pager *joblayerPager) error {
		if filter == nil {
			return errors.New("JobLayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type joblayerPager struct {
	reverse bool
	order   *JobLayerOrder
	filter  func(*JobLayerQuery) (*JobLayerQuery, error)
}

func newJobLayerPager(opts []JobLayerPaginateOption, reverse bool) (*joblayerPager, error) {
	pager := &joblayerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobLayerOrder
	}
	return pager, nil
}

func (p *joblayerPager) applyFilter(query *JobLayerQuery) (*JobLayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *joblayerPager) toCursor(jl *JobLayer) Cursor {
	return p.order.Field.toCursor(jl)
}

func (p *joblayerPager) applyCursors(query *JobLayerQuery, after, before *Cursor) (*JobLayerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobLayerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *joblayerPager) applyOrder(query *JobLayerQuery) *JobLayerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobLayerOrder.Field {
		query = query.Order(DefaultJobLayerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *joblayerPager) orderExpr(query *JobLayerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobLayerOrder.Field {
			b.Comma().Ident(DefaultJobLayerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobLayer.
func (jl *JobLayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobLayerPaginateOption,
) (*JobLayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobLayerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jl, err = pager.applyFilter(jl); err != nil {
		return nil, err
	}
	conn := &JobLayerConnection{Edges: []*JobLayerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jl, err = pager.applyCursors(jl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jl = pager.applyOrder(jl)
	nodes, err := jl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobLayerOrderField defines the ordering field of JobLayer.
type JobLayerOrderField struct {
	// Value extracts the ordering value from the given JobLayer.
	Value    func(*JobLayer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) joblayer.OrderOption
	toCursor func(*JobLayer) Cursor
}

// JobLayerOrder defines the ordering of JobLayer.
type JobLayerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobLayerOrderField `json:"field"`
}

// DefaultJobLayerOrder is the default ordering of JobLayer.
var DefaultJobLayerOrder = &JobLayerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobLayerOrderField{
		Value: func(jl *JobLayer) (ent.Value, error) {
			return jl.ID, nil
		},
		column: joblayer.FieldID,
		toTerm: joblayer.ByID,
		toCursor: func(jl *JobLayer) Cursor {
			return Cursor{ID: jl.ID}
		},
	},
}

// ToEdge converts JobLayer into JobLayerEdge.
func (jl *JobLayer) ToEdge(order *JobLayerOrder) *JobLayerEdge {
	if order == nil {
		order = DefaultJobLayerOrder
	}
	return &JobLayerEdge{
		Node:   jl,
		Cursor: order.Field.toCursor(jl),
	}
}

// JobOwnerEdge is the edge representation of JobOwner.
type JobOwnerEdge struct {
	Node   *JobOwner `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobOwnerConnection is the connection containing edges to JobOwner.
type JobOwnerConnection struct {
	Edges      []*JobOwnerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobOwnerConnection) build(nodes []*JobOwner, pager *jobownerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobOwner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobOwner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobOwner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobOwnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobOwnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobOwnerPaginateOption enables pagination customization.
type JobOwnerPaginateOption func(*jobownerPager) error

// WithJobOwnerOrder configures pagination ordering.
func WithJobOwnerOrder(order *JobOwnerOrder) JobOwnerPaginateOption {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	o := *order
	return func(pager *jobownerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobOwnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobOwnerFilter configures pagination filter.
func WithJobOwnerFilter(filter func(*JobOwnerQuery) (*JobOwnerQuery, error)) JobOwnerPaginateOption {
	return func(pager *jobownerPager) error {
		if filter == nil {
			return errors.New("JobOwnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobownerPager struct {
	reverse bool
	order   *JobOwnerOrder
	filter  func(*JobOwnerQuery) (*JobOwnerQuery, error)
}

func newJobOwnerPager(opts []JobOwnerPaginateOption, reverse bool) (*jobownerPager, error) {
	pager := &jobownerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobOwnerOrder
	}
	return pager, nil
}

func (p *jobownerPager) applyFilter(query *JobOwnerQuery) (*JobOwnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobownerPager) toCursor(jo *JobOwner) Cursor {
	return p.order.Field.toCursor(jo)
}

func (p *jobownerPager) applyCursors(query *JobOwnerQuery, after, before *Cursor) (*JobOwnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobOwnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobownerPager) applyOrder(query *JobOwnerQuery) *JobOwnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobOwnerOrder.Field {
		query = query.Order(DefaultJobOwnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobownerPager) orderExpr(query *JobOwnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobOwnerOrder.Field {
			b.Comma().Ident(DefaultJobOwnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobOwner.
func (jo *JobOwnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobOwnerPaginateOption,
) (*JobOwnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobOwnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jo, err = pager.applyFilter(jo); err != nil {
		return nil, err
	}
	conn := &JobOwnerConnection{Edges: []*JobOwnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jo.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jo, err = pager.applyCursors(jo, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jo.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jo.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jo = pager.applyOrder(jo)
	nodes, err := jo.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobOwnerOrderField defines the ordering field of JobOwner.
type JobOwnerOrderField struct {
	// Value extracts the ordering value from the given JobOwner.
	Value    func(*JobOwner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobowner.OrderOption
	toCursor func(*JobOwner) Cursor
}

// JobOwnerOrder defines the ordering of JobOwner.
type JobOwnerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobOwnerOrderField `json:"field"`
}

// DefaultJobOwnerOrder is the default ordering of JobOwner.
var DefaultJobOwnerOrder = &JobOwnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobOwnerOrderField{
		Value: func(jo *JobOwner) (ent.Value, error) {
			return jo.ID, nil
		},
		column: jobowner.FieldID,
		toTerm: jobowner.ByID,
		toCursor: func(jo *JobOwner) Cursor {
			return Cursor{ID: jo.ID}
		},
	},
}

// ToEdge converts JobOwner into JobOwnerEdge.
func (jo *JobOwner) ToEdge(order *JobOwnerOrder) *JobOwnerEdge {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	return &JobOwnerEdge{
		Node:   jo,
		Cursor: order.Field.toCursor(jo),
	}
}

// JobProgressEdge is the edge representation of JobProgress.
type JobProgressEdge struct {
	Node   *JobProgress `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobProgressConnection is the connection containing edges to JobProgress.
type JobProgressConnection struct {
	Edges      []*JobProgressEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobProgressConnection) build(nodes []*JobProgress, pager *jobprogressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobProgress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobProgress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobProgress {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobProgressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobProgressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobProgressPaginateOption enables pagination customization.
type JobProgressPaginateOption func(*jobprogressPager) error

// WithJobProgressOrder configures pagination ordering.
func WithJobProgressOrder(order *JobProgressOrder) JobProgressPaginateOption {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	o := *order
	return func(pager *jobprogressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobProgressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobProgressFilter configures pagination filter.
func WithJobProgressFilter(filter func(*JobProgressQuery) (*JobProgressQuery, error)) JobProgressPaginateOption {
	return func(pager *jobprogressPager) error {
		if filter == nil {
			return errors.New("JobProgressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobprogressPager struct {
	reverse bool
	order   *JobProgressOrder
	filter  func(*JobProgressQuery) (*JobProgressQuery, error)
}

func newJobProgressPager(opts []JobProgressPaginateOption, reverse bool) (*jobprogressPager, error) {
	pager := &jobprogressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobProgressOrder
	}
	return pager, nil
}

func (p *jobprogressPager) applyFilter(query *JobProgressQuery) (*JobProgressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobprogressPager) toCursor(jp *JobProgress) Cursor {
	return p.order.Field.toCursor(jp)
}

func (p *jobprogressPager) applyCursors(query *JobProgressQuery, after, before *Cursor) (*JobProgressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobProgressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobprogressPager) applyOrder(query *JobProgressQuery) *JobProgressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobProgressOrder.Field {
		query = query.Order(DefaultJobProgressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobprogressPager) orderExpr(query *JobProgressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobProgressOrder.Field {
			b.Comma().Ident(DefaultJobProgressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobProgress.
func (jp *JobProgressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobProgressPaginateOption,
) (*JobProgressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobProgressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jp, err = pager.applyFilter(jp); err != nil {
		return nil, err
	}
	conn := &JobProgressConnection{Edges: []*JobProgressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jp, err = pager.applyCursors(jp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jp = pager.applyOrder(jp)
	nodes, err := jp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobProgressOrderField defines the ordering field of JobProgress.
type JobProgressOrderField struct {
	// Value extracts the ordering value from the given JobProgress.
	Value    func(*JobProgress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobprogress.OrderOption
	toCursor func(*JobProgress) Cursor
}

// JobProgressOrder defines the ordering of JobProgress.
type JobProgressOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobProgressOrderField `json:"field"`
}

// DefaultJobProgressOrder is the default ordering of JobProgress.
var DefaultJobProgressOrder = &JobProgressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobProgressOrderField{
		Value: func(jp *JobProgress) (ent.Value, error) {
			return jp.ID, nil
		},
		column: jobprogress.FieldID,
		toTerm: jobprogress.ByID,
		toCursor: func(jp *JobProgress) Cursor {
			return Cursor{ID: jp.ID}
		},
	},
}

// ToEdge converts JobProgress into JobProgressEdge.
func (jp *JobProgress) ToEdge(order *JobProgressOrder) *JobProgressEdge {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	return &JobProgressEdge{
		Node:   jp,
		Cursor: order.Field.toCursor(jp),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
