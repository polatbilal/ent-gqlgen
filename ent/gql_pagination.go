// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/polatbilal/gqlgen-ent/ent/companydetail"
	"github.com/polatbilal/gqlgen-ent/ent/companyengineer"
	"github.com/polatbilal/gqlgen-ent/ent/companyuser"
	"github.com/polatbilal/gqlgen-ent/ent/jobauthor"
	"github.com/polatbilal/gqlgen-ent/ent/jobcontractor"
	"github.com/polatbilal/gqlgen-ent/ent/jobdetail"
	"github.com/polatbilal/gqlgen-ent/ent/joblayer"
	"github.com/polatbilal/gqlgen-ent/ent/jobowner"
	"github.com/polatbilal/gqlgen-ent/ent/jobpayments"
	"github.com/polatbilal/gqlgen-ent/ent/jobprogress"
	"github.com/polatbilal/gqlgen-ent/ent/jobsupervisor"
	"github.com/polatbilal/gqlgen-ent/ent/user"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[int]
	PageInfo       = entgql.PageInfo[int]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CompanyDetailEdge is the edge representation of CompanyDetail.
type CompanyDetailEdge struct {
	Node   *CompanyDetail `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// CompanyDetailConnection is the connection containing edges to CompanyDetail.
type CompanyDetailConnection struct {
	Edges      []*CompanyDetailEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *CompanyDetailConnection) build(nodes []*CompanyDetail, pager *companydetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyDetailPaginateOption enables pagination customization.
type CompanyDetailPaginateOption func(*companydetailPager) error

// WithCompanyDetailOrder configures pagination ordering.
func WithCompanyDetailOrder(order *CompanyDetailOrder) CompanyDetailPaginateOption {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	o := *order
	return func(pager *companydetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyDetailFilter configures pagination filter.
func WithCompanyDetailFilter(filter func(*CompanyDetailQuery) (*CompanyDetailQuery, error)) CompanyDetailPaginateOption {
	return func(pager *companydetailPager) error {
		if filter == nil {
			return errors.New("CompanyDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companydetailPager struct {
	reverse bool
	order   *CompanyDetailOrder
	filter  func(*CompanyDetailQuery) (*CompanyDetailQuery, error)
}

func newCompanyDetailPager(opts []CompanyDetailPaginateOption, reverse bool) (*companydetailPager, error) {
	pager := &companydetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyDetailOrder
	}
	return pager, nil
}

func (p *companydetailPager) applyFilter(query *CompanyDetailQuery) (*CompanyDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companydetailPager) toCursor(cd *CompanyDetail) Cursor {
	return p.order.Field.toCursor(cd)
}

func (p *companydetailPager) applyCursors(query *CompanyDetailQuery, after, before *Cursor) (*CompanyDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companydetailPager) applyOrder(query *CompanyDetailQuery) *CompanyDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyDetailOrder.Field {
		query = query.Order(DefaultCompanyDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companydetailPager) orderExpr(query *CompanyDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyDetailOrder.Field {
			b.Comma().Ident(DefaultCompanyDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyDetail.
func (cd *CompanyDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyDetailPaginateOption,
) (*CompanyDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CompanyDetailConnection{Edges: []*CompanyDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyDetailOrderField defines the ordering field of CompanyDetail.
type CompanyDetailOrderField struct {
	// Value extracts the ordering value from the given CompanyDetail.
	Value    func(*CompanyDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companydetail.OrderOption
	toCursor func(*CompanyDetail) Cursor
}

// CompanyDetailOrder defines the ordering of CompanyDetail.
type CompanyDetailOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *CompanyDetailOrderField `json:"field"`
}

// DefaultCompanyDetailOrder is the default ordering of CompanyDetail.
var DefaultCompanyDetailOrder = &CompanyDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyDetailOrderField{
		Value: func(cd *CompanyDetail) (ent.Value, error) {
			return cd.ID, nil
		},
		column: companydetail.FieldID,
		toTerm: companydetail.ByID,
		toCursor: func(cd *CompanyDetail) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CompanyDetail into CompanyDetailEdge.
func (cd *CompanyDetail) ToEdge(order *CompanyDetailOrder) *CompanyDetailEdge {
	if order == nil {
		order = DefaultCompanyDetailOrder
	}
	return &CompanyDetailEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CompanyEngineerEdge is the edge representation of CompanyEngineer.
type CompanyEngineerEdge struct {
	Node   *CompanyEngineer `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CompanyEngineerConnection is the connection containing edges to CompanyEngineer.
type CompanyEngineerConnection struct {
	Edges      []*CompanyEngineerEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CompanyEngineerConnection) build(nodes []*CompanyEngineer, pager *companyengineerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyEngineer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyEngineer {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEngineerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEngineerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyEngineerPaginateOption enables pagination customization.
type CompanyEngineerPaginateOption func(*companyengineerPager) error

// WithCompanyEngineerOrder configures pagination ordering.
func WithCompanyEngineerOrder(order *CompanyEngineerOrder) CompanyEngineerPaginateOption {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	o := *order
	return func(pager *companyengineerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyEngineerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyEngineerFilter configures pagination filter.
func WithCompanyEngineerFilter(filter func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)) CompanyEngineerPaginateOption {
	return func(pager *companyengineerPager) error {
		if filter == nil {
			return errors.New("CompanyEngineerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyengineerPager struct {
	reverse bool
	order   *CompanyEngineerOrder
	filter  func(*CompanyEngineerQuery) (*CompanyEngineerQuery, error)
}

func newCompanyEngineerPager(opts []CompanyEngineerPaginateOption, reverse bool) (*companyengineerPager, error) {
	pager := &companyengineerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyEngineerOrder
	}
	return pager, nil
}

func (p *companyengineerPager) applyFilter(query *CompanyEngineerQuery) (*CompanyEngineerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyengineerPager) toCursor(ce *CompanyEngineer) Cursor {
	return p.order.Field.toCursor(ce)
}

func (p *companyengineerPager) applyCursors(query *CompanyEngineerQuery, after, before *Cursor) (*CompanyEngineerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyEngineerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyengineerPager) applyOrder(query *CompanyEngineerQuery) *CompanyEngineerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyEngineerOrder.Field {
		query = query.Order(DefaultCompanyEngineerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyengineerPager) orderExpr(query *CompanyEngineerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyEngineerOrder.Field {
			b.Comma().Ident(DefaultCompanyEngineerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyEngineer.
func (ce *CompanyEngineerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyEngineerPaginateOption,
) (*CompanyEngineerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyEngineerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ce, err = pager.applyFilter(ce); err != nil {
		return nil, err
	}
	conn := &CompanyEngineerConnection{Edges: []*CompanyEngineerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ce.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ce, err = pager.applyCursors(ce, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ce.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ce.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ce = pager.applyOrder(ce)
	nodes, err := ce.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyEngineerOrderField defines the ordering field of CompanyEngineer.
type CompanyEngineerOrderField struct {
	// Value extracts the ordering value from the given CompanyEngineer.
	Value    func(*CompanyEngineer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyengineer.OrderOption
	toCursor func(*CompanyEngineer) Cursor
}

// CompanyEngineerOrder defines the ordering of CompanyEngineer.
type CompanyEngineerOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CompanyEngineerOrderField `json:"field"`
}

// DefaultCompanyEngineerOrder is the default ordering of CompanyEngineer.
var DefaultCompanyEngineerOrder = &CompanyEngineerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyEngineerOrderField{
		Value: func(ce *CompanyEngineer) (ent.Value, error) {
			return ce.ID, nil
		},
		column: companyengineer.FieldID,
		toTerm: companyengineer.ByID,
		toCursor: func(ce *CompanyEngineer) Cursor {
			return Cursor{ID: ce.ID}
		},
	},
}

// ToEdge converts CompanyEngineer into CompanyEngineerEdge.
func (ce *CompanyEngineer) ToEdge(order *CompanyEngineerOrder) *CompanyEngineerEdge {
	if order == nil {
		order = DefaultCompanyEngineerOrder
	}
	return &CompanyEngineerEdge{
		Node:   ce,
		Cursor: order.Field.toCursor(ce),
	}
}

// CompanyUserEdge is the edge representation of CompanyUser.
type CompanyUserEdge struct {
	Node   *CompanyUser `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CompanyUserConnection is the connection containing edges to CompanyUser.
type CompanyUserConnection struct {
	Edges      []*CompanyUserEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *CompanyUserConnection) build(nodes []*CompanyUser, pager *companyuserPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CompanyUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CompanyUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CompanyUser {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyUserPaginateOption enables pagination customization.
type CompanyUserPaginateOption func(*companyuserPager) error

// WithCompanyUserOrder configures pagination ordering.
func WithCompanyUserOrder(order *CompanyUserOrder) CompanyUserPaginateOption {
	if order == nil {
		order = DefaultCompanyUserOrder
	}
	o := *order
	return func(pager *companyuserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyUserFilter configures pagination filter.
func WithCompanyUserFilter(filter func(*CompanyUserQuery) (*CompanyUserQuery, error)) CompanyUserPaginateOption {
	return func(pager *companyuserPager) error {
		if filter == nil {
			return errors.New("CompanyUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyuserPager struct {
	reverse bool
	order   *CompanyUserOrder
	filter  func(*CompanyUserQuery) (*CompanyUserQuery, error)
}

func newCompanyUserPager(opts []CompanyUserPaginateOption, reverse bool) (*companyuserPager, error) {
	pager := &companyuserPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyUserOrder
	}
	return pager, nil
}

func (p *companyuserPager) applyFilter(query *CompanyUserQuery) (*CompanyUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyuserPager) toCursor(cu *CompanyUser) Cursor {
	return p.order.Field.toCursor(cu)
}

func (p *companyuserPager) applyCursors(query *CompanyUserQuery, after, before *Cursor) (*CompanyUserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCompanyUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *companyuserPager) applyOrder(query *CompanyUserQuery) *CompanyUserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCompanyUserOrder.Field {
		query = query.Order(DefaultCompanyUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *companyuserPager) orderExpr(query *CompanyUserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyUserOrder.Field {
			b.Comma().Ident(DefaultCompanyUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CompanyUser.
func (cu *CompanyUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyUserPaginateOption,
) (*CompanyUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cu, err = pager.applyFilter(cu); err != nil {
		return nil, err
	}
	conn := &CompanyUserConnection{Edges: []*CompanyUserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cu, err = pager.applyCursors(cu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cu = pager.applyOrder(cu)
	nodes, err := cu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CompanyUserOrderField defines the ordering field of CompanyUser.
type CompanyUserOrderField struct {
	// Value extracts the ordering value from the given CompanyUser.
	Value    func(*CompanyUser) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) companyuser.OrderOption
	toCursor func(*CompanyUser) Cursor
}

// CompanyUserOrder defines the ordering of CompanyUser.
type CompanyUserOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CompanyUserOrderField `json:"field"`
}

// DefaultCompanyUserOrder is the default ordering of CompanyUser.
var DefaultCompanyUserOrder = &CompanyUserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CompanyUserOrderField{
		Value: func(cu *CompanyUser) (ent.Value, error) {
			return cu.ID, nil
		},
		column: companyuser.FieldID,
		toTerm: companyuser.ByID,
		toCursor: func(cu *CompanyUser) Cursor {
			return Cursor{ID: cu.ID}
		},
	},
}

// ToEdge converts CompanyUser into CompanyUserEdge.
func (cu *CompanyUser) ToEdge(order *CompanyUserOrder) *CompanyUserEdge {
	if order == nil {
		order = DefaultCompanyUserOrder
	}
	return &CompanyUserEdge{
		Node:   cu,
		Cursor: order.Field.toCursor(cu),
	}
}

// JobAuthorEdge is the edge representation of JobAuthor.
type JobAuthorEdge struct {
	Node   *JobAuthor `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobAuthorConnection is the connection containing edges to JobAuthor.
type JobAuthorConnection struct {
	Edges      []*JobAuthorEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobAuthorConnection) build(nodes []*JobAuthor, pager *jobauthorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobAuthor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobAuthor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobAuthor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobAuthorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobAuthorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobAuthorPaginateOption enables pagination customization.
type JobAuthorPaginateOption func(*jobauthorPager) error

// WithJobAuthorOrder configures pagination ordering.
func WithJobAuthorOrder(order *JobAuthorOrder) JobAuthorPaginateOption {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	o := *order
	return func(pager *jobauthorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobAuthorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobAuthorFilter configures pagination filter.
func WithJobAuthorFilter(filter func(*JobAuthorQuery) (*JobAuthorQuery, error)) JobAuthorPaginateOption {
	return func(pager *jobauthorPager) error {
		if filter == nil {
			return errors.New("JobAuthorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobauthorPager struct {
	reverse bool
	order   *JobAuthorOrder
	filter  func(*JobAuthorQuery) (*JobAuthorQuery, error)
}

func newJobAuthorPager(opts []JobAuthorPaginateOption, reverse bool) (*jobauthorPager, error) {
	pager := &jobauthorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobAuthorOrder
	}
	return pager, nil
}

func (p *jobauthorPager) applyFilter(query *JobAuthorQuery) (*JobAuthorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobauthorPager) toCursor(ja *JobAuthor) Cursor {
	return p.order.Field.toCursor(ja)
}

func (p *jobauthorPager) applyCursors(query *JobAuthorQuery, after, before *Cursor) (*JobAuthorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobAuthorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobauthorPager) applyOrder(query *JobAuthorQuery) *JobAuthorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobAuthorOrder.Field {
		query = query.Order(DefaultJobAuthorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobauthorPager) orderExpr(query *JobAuthorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobAuthorOrder.Field {
			b.Comma().Ident(DefaultJobAuthorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobAuthor.
func (ja *JobAuthorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobAuthorPaginateOption,
) (*JobAuthorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobAuthorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ja, err = pager.applyFilter(ja); err != nil {
		return nil, err
	}
	conn := &JobAuthorConnection{Edges: []*JobAuthorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ja.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ja, err = pager.applyCursors(ja, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ja.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ja.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ja = pager.applyOrder(ja)
	nodes, err := ja.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobAuthorOrderField defines the ordering field of JobAuthor.
type JobAuthorOrderField struct {
	// Value extracts the ordering value from the given JobAuthor.
	Value    func(*JobAuthor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobauthor.OrderOption
	toCursor func(*JobAuthor) Cursor
}

// JobAuthorOrder defines the ordering of JobAuthor.
type JobAuthorOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobAuthorOrderField `json:"field"`
}

// DefaultJobAuthorOrder is the default ordering of JobAuthor.
var DefaultJobAuthorOrder = &JobAuthorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobAuthorOrderField{
		Value: func(ja *JobAuthor) (ent.Value, error) {
			return ja.ID, nil
		},
		column: jobauthor.FieldID,
		toTerm: jobauthor.ByID,
		toCursor: func(ja *JobAuthor) Cursor {
			return Cursor{ID: ja.ID}
		},
	},
}

// ToEdge converts JobAuthor into JobAuthorEdge.
func (ja *JobAuthor) ToEdge(order *JobAuthorOrder) *JobAuthorEdge {
	if order == nil {
		order = DefaultJobAuthorOrder
	}
	return &JobAuthorEdge{
		Node:   ja,
		Cursor: order.Field.toCursor(ja),
	}
}

// JobContractorEdge is the edge representation of JobContractor.
type JobContractorEdge struct {
	Node   *JobContractor `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// JobContractorConnection is the connection containing edges to JobContractor.
type JobContractorConnection struct {
	Edges      []*JobContractorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *JobContractorConnection) build(nodes []*JobContractor, pager *jobcontractorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobContractor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobContractor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobContractor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobContractorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobContractorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobContractorPaginateOption enables pagination customization.
type JobContractorPaginateOption func(*jobcontractorPager) error

// WithJobContractorOrder configures pagination ordering.
func WithJobContractorOrder(order *JobContractorOrder) JobContractorPaginateOption {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	o := *order
	return func(pager *jobcontractorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobContractorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobContractorFilter configures pagination filter.
func WithJobContractorFilter(filter func(*JobContractorQuery) (*JobContractorQuery, error)) JobContractorPaginateOption {
	return func(pager *jobcontractorPager) error {
		if filter == nil {
			return errors.New("JobContractorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobcontractorPager struct {
	reverse bool
	order   *JobContractorOrder
	filter  func(*JobContractorQuery) (*JobContractorQuery, error)
}

func newJobContractorPager(opts []JobContractorPaginateOption, reverse bool) (*jobcontractorPager, error) {
	pager := &jobcontractorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobContractorOrder
	}
	return pager, nil
}

func (p *jobcontractorPager) applyFilter(query *JobContractorQuery) (*JobContractorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobcontractorPager) toCursor(jc *JobContractor) Cursor {
	return p.order.Field.toCursor(jc)
}

func (p *jobcontractorPager) applyCursors(query *JobContractorQuery, after, before *Cursor) (*JobContractorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobContractorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobcontractorPager) applyOrder(query *JobContractorQuery) *JobContractorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobContractorOrder.Field {
		query = query.Order(DefaultJobContractorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobcontractorPager) orderExpr(query *JobContractorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobContractorOrder.Field {
			b.Comma().Ident(DefaultJobContractorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobContractor.
func (jc *JobContractorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobContractorPaginateOption,
) (*JobContractorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobContractorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jc, err = pager.applyFilter(jc); err != nil {
		return nil, err
	}
	conn := &JobContractorConnection{Edges: []*JobContractorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jc, err = pager.applyCursors(jc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jc = pager.applyOrder(jc)
	nodes, err := jc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobContractorOrderField defines the ordering field of JobContractor.
type JobContractorOrderField struct {
	// Value extracts the ordering value from the given JobContractor.
	Value    func(*JobContractor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobcontractor.OrderOption
	toCursor func(*JobContractor) Cursor
}

// JobContractorOrder defines the ordering of JobContractor.
type JobContractorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *JobContractorOrderField `json:"field"`
}

// DefaultJobContractorOrder is the default ordering of JobContractor.
var DefaultJobContractorOrder = &JobContractorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobContractorOrderField{
		Value: func(jc *JobContractor) (ent.Value, error) {
			return jc.ID, nil
		},
		column: jobcontractor.FieldID,
		toTerm: jobcontractor.ByID,
		toCursor: func(jc *JobContractor) Cursor {
			return Cursor{ID: jc.ID}
		},
	},
}

// ToEdge converts JobContractor into JobContractorEdge.
func (jc *JobContractor) ToEdge(order *JobContractorOrder) *JobContractorEdge {
	if order == nil {
		order = DefaultJobContractorOrder
	}
	return &JobContractorEdge{
		Node:   jc,
		Cursor: order.Field.toCursor(jc),
	}
}

// JobDetailEdge is the edge representation of JobDetail.
type JobDetailEdge struct {
	Node   *JobDetail `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobDetailConnection is the connection containing edges to JobDetail.
type JobDetailConnection struct {
	Edges      []*JobDetailEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobDetailConnection) build(nodes []*JobDetail, pager *jobdetailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobDetail
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobDetail {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobDetail {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobDetailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobDetailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobDetailPaginateOption enables pagination customization.
type JobDetailPaginateOption func(*jobdetailPager) error

// WithJobDetailOrder configures pagination ordering.
func WithJobDetailOrder(order *JobDetailOrder) JobDetailPaginateOption {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	o := *order
	return func(pager *jobdetailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobDetailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobDetailFilter configures pagination filter.
func WithJobDetailFilter(filter func(*JobDetailQuery) (*JobDetailQuery, error)) JobDetailPaginateOption {
	return func(pager *jobdetailPager) error {
		if filter == nil {
			return errors.New("JobDetailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobdetailPager struct {
	reverse bool
	order   *JobDetailOrder
	filter  func(*JobDetailQuery) (*JobDetailQuery, error)
}

func newJobDetailPager(opts []JobDetailPaginateOption, reverse bool) (*jobdetailPager, error) {
	pager := &jobdetailPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobDetailOrder
	}
	return pager, nil
}

func (p *jobdetailPager) applyFilter(query *JobDetailQuery) (*JobDetailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobdetailPager) toCursor(jd *JobDetail) Cursor {
	return p.order.Field.toCursor(jd)
}

func (p *jobdetailPager) applyCursors(query *JobDetailQuery, after, before *Cursor) (*JobDetailQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobDetailOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobdetailPager) applyOrder(query *JobDetailQuery) *JobDetailQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobDetailOrder.Field {
		query = query.Order(DefaultJobDetailOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobdetailPager) orderExpr(query *JobDetailQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobDetailOrder.Field {
			b.Comma().Ident(DefaultJobDetailOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobDetail.
func (jd *JobDetailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobDetailPaginateOption,
) (*JobDetailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobDetailPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jd, err = pager.applyFilter(jd); err != nil {
		return nil, err
	}
	conn := &JobDetailConnection{Edges: []*JobDetailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jd, err = pager.applyCursors(jd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jd = pager.applyOrder(jd)
	nodes, err := jd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobDetailOrderField defines the ordering field of JobDetail.
type JobDetailOrderField struct {
	// Value extracts the ordering value from the given JobDetail.
	Value    func(*JobDetail) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobdetail.OrderOption
	toCursor func(*JobDetail) Cursor
}

// JobDetailOrder defines the ordering of JobDetail.
type JobDetailOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobDetailOrderField `json:"field"`
}

// DefaultJobDetailOrder is the default ordering of JobDetail.
var DefaultJobDetailOrder = &JobDetailOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobDetailOrderField{
		Value: func(jd *JobDetail) (ent.Value, error) {
			return jd.ID, nil
		},
		column: jobdetail.FieldID,
		toTerm: jobdetail.ByID,
		toCursor: func(jd *JobDetail) Cursor {
			return Cursor{ID: jd.ID}
		},
	},
}

// ToEdge converts JobDetail into JobDetailEdge.
func (jd *JobDetail) ToEdge(order *JobDetailOrder) *JobDetailEdge {
	if order == nil {
		order = DefaultJobDetailOrder
	}
	return &JobDetailEdge{
		Node:   jd,
		Cursor: order.Field.toCursor(jd),
	}
}

// JobLayerEdge is the edge representation of JobLayer.
type JobLayerEdge struct {
	Node   *JobLayer `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobLayerConnection is the connection containing edges to JobLayer.
type JobLayerConnection struct {
	Edges      []*JobLayerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobLayerConnection) build(nodes []*JobLayer, pager *joblayerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobLayer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobLayer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobLayer {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobLayerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobLayerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobLayerPaginateOption enables pagination customization.
type JobLayerPaginateOption func(*joblayerPager) error

// WithJobLayerOrder configures pagination ordering.
func WithJobLayerOrder(order *JobLayerOrder) JobLayerPaginateOption {
	if order == nil {
		order = DefaultJobLayerOrder
	}
	o := *order
	return func(pager *joblayerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobLayerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobLayerFilter configures pagination filter.
func WithJobLayerFilter(filter func(*JobLayerQuery) (*JobLayerQuery, error)) JobLayerPaginateOption {
	return func(pager *joblayerPager) error {
		if filter == nil {
			return errors.New("JobLayerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type joblayerPager struct {
	reverse bool
	order   *JobLayerOrder
	filter  func(*JobLayerQuery) (*JobLayerQuery, error)
}

func newJobLayerPager(opts []JobLayerPaginateOption, reverse bool) (*joblayerPager, error) {
	pager := &joblayerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobLayerOrder
	}
	return pager, nil
}

func (p *joblayerPager) applyFilter(query *JobLayerQuery) (*JobLayerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *joblayerPager) toCursor(jl *JobLayer) Cursor {
	return p.order.Field.toCursor(jl)
}

func (p *joblayerPager) applyCursors(query *JobLayerQuery, after, before *Cursor) (*JobLayerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobLayerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *joblayerPager) applyOrder(query *JobLayerQuery) *JobLayerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobLayerOrder.Field {
		query = query.Order(DefaultJobLayerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *joblayerPager) orderExpr(query *JobLayerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobLayerOrder.Field {
			b.Comma().Ident(DefaultJobLayerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobLayer.
func (jl *JobLayerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobLayerPaginateOption,
) (*JobLayerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobLayerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jl, err = pager.applyFilter(jl); err != nil {
		return nil, err
	}
	conn := &JobLayerConnection{Edges: []*JobLayerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jl, err = pager.applyCursors(jl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jl = pager.applyOrder(jl)
	nodes, err := jl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobLayerOrderField defines the ordering field of JobLayer.
type JobLayerOrderField struct {
	// Value extracts the ordering value from the given JobLayer.
	Value    func(*JobLayer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) joblayer.OrderOption
	toCursor func(*JobLayer) Cursor
}

// JobLayerOrder defines the ordering of JobLayer.
type JobLayerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobLayerOrderField `json:"field"`
}

// DefaultJobLayerOrder is the default ordering of JobLayer.
var DefaultJobLayerOrder = &JobLayerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobLayerOrderField{
		Value: func(jl *JobLayer) (ent.Value, error) {
			return jl.ID, nil
		},
		column: joblayer.FieldID,
		toTerm: joblayer.ByID,
		toCursor: func(jl *JobLayer) Cursor {
			return Cursor{ID: jl.ID}
		},
	},
}

// ToEdge converts JobLayer into JobLayerEdge.
func (jl *JobLayer) ToEdge(order *JobLayerOrder) *JobLayerEdge {
	if order == nil {
		order = DefaultJobLayerOrder
	}
	return &JobLayerEdge{
		Node:   jl,
		Cursor: order.Field.toCursor(jl),
	}
}

// JobOwnerEdge is the edge representation of JobOwner.
type JobOwnerEdge struct {
	Node   *JobOwner `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// JobOwnerConnection is the connection containing edges to JobOwner.
type JobOwnerConnection struct {
	Edges      []*JobOwnerEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *JobOwnerConnection) build(nodes []*JobOwner, pager *jobownerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobOwner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobOwner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobOwner {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobOwnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobOwnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobOwnerPaginateOption enables pagination customization.
type JobOwnerPaginateOption func(*jobownerPager) error

// WithJobOwnerOrder configures pagination ordering.
func WithJobOwnerOrder(order *JobOwnerOrder) JobOwnerPaginateOption {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	o := *order
	return func(pager *jobownerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobOwnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobOwnerFilter configures pagination filter.
func WithJobOwnerFilter(filter func(*JobOwnerQuery) (*JobOwnerQuery, error)) JobOwnerPaginateOption {
	return func(pager *jobownerPager) error {
		if filter == nil {
			return errors.New("JobOwnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobownerPager struct {
	reverse bool
	order   *JobOwnerOrder
	filter  func(*JobOwnerQuery) (*JobOwnerQuery, error)
}

func newJobOwnerPager(opts []JobOwnerPaginateOption, reverse bool) (*jobownerPager, error) {
	pager := &jobownerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobOwnerOrder
	}
	return pager, nil
}

func (p *jobownerPager) applyFilter(query *JobOwnerQuery) (*JobOwnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobownerPager) toCursor(jo *JobOwner) Cursor {
	return p.order.Field.toCursor(jo)
}

func (p *jobownerPager) applyCursors(query *JobOwnerQuery, after, before *Cursor) (*JobOwnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobOwnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobownerPager) applyOrder(query *JobOwnerQuery) *JobOwnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobOwnerOrder.Field {
		query = query.Order(DefaultJobOwnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobownerPager) orderExpr(query *JobOwnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobOwnerOrder.Field {
			b.Comma().Ident(DefaultJobOwnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobOwner.
func (jo *JobOwnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobOwnerPaginateOption,
) (*JobOwnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobOwnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jo, err = pager.applyFilter(jo); err != nil {
		return nil, err
	}
	conn := &JobOwnerConnection{Edges: []*JobOwnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jo.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jo, err = pager.applyCursors(jo, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jo.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jo.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jo = pager.applyOrder(jo)
	nodes, err := jo.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobOwnerOrderField defines the ordering field of JobOwner.
type JobOwnerOrderField struct {
	// Value extracts the ordering value from the given JobOwner.
	Value    func(*JobOwner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobowner.OrderOption
	toCursor func(*JobOwner) Cursor
}

// JobOwnerOrder defines the ordering of JobOwner.
type JobOwnerOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *JobOwnerOrderField `json:"field"`
}

// DefaultJobOwnerOrder is the default ordering of JobOwner.
var DefaultJobOwnerOrder = &JobOwnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobOwnerOrderField{
		Value: func(jo *JobOwner) (ent.Value, error) {
			return jo.ID, nil
		},
		column: jobowner.FieldID,
		toTerm: jobowner.ByID,
		toCursor: func(jo *JobOwner) Cursor {
			return Cursor{ID: jo.ID}
		},
	},
}

// ToEdge converts JobOwner into JobOwnerEdge.
func (jo *JobOwner) ToEdge(order *JobOwnerOrder) *JobOwnerEdge {
	if order == nil {
		order = DefaultJobOwnerOrder
	}
	return &JobOwnerEdge{
		Node:   jo,
		Cursor: order.Field.toCursor(jo),
	}
}

// JobPaymentsEdge is the edge representation of JobPayments.
type JobPaymentsEdge struct {
	Node   *JobPayments `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobPaymentsConnection is the connection containing edges to JobPayments.
type JobPaymentsConnection struct {
	Edges      []*JobPaymentsEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobPaymentsConnection) build(nodes []*JobPayments, pager *jobpaymentsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobPayments
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobPayments {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobPayments {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobPaymentsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobPaymentsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobPaymentsPaginateOption enables pagination customization.
type JobPaymentsPaginateOption func(*jobpaymentsPager) error

// WithJobPaymentsOrder configures pagination ordering.
func WithJobPaymentsOrder(order *JobPaymentsOrder) JobPaymentsPaginateOption {
	if order == nil {
		order = DefaultJobPaymentsOrder
	}
	o := *order
	return func(pager *jobpaymentsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobPaymentsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobPaymentsFilter configures pagination filter.
func WithJobPaymentsFilter(filter func(*JobPaymentsQuery) (*JobPaymentsQuery, error)) JobPaymentsPaginateOption {
	return func(pager *jobpaymentsPager) error {
		if filter == nil {
			return errors.New("JobPaymentsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobpaymentsPager struct {
	reverse bool
	order   *JobPaymentsOrder
	filter  func(*JobPaymentsQuery) (*JobPaymentsQuery, error)
}

func newJobPaymentsPager(opts []JobPaymentsPaginateOption, reverse bool) (*jobpaymentsPager, error) {
	pager := &jobpaymentsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobPaymentsOrder
	}
	return pager, nil
}

func (p *jobpaymentsPager) applyFilter(query *JobPaymentsQuery) (*JobPaymentsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobpaymentsPager) toCursor(jp *JobPayments) Cursor {
	return p.order.Field.toCursor(jp)
}

func (p *jobpaymentsPager) applyCursors(query *JobPaymentsQuery, after, before *Cursor) (*JobPaymentsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobPaymentsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobpaymentsPager) applyOrder(query *JobPaymentsQuery) *JobPaymentsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobPaymentsOrder.Field {
		query = query.Order(DefaultJobPaymentsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobpaymentsPager) orderExpr(query *JobPaymentsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobPaymentsOrder.Field {
			b.Comma().Ident(DefaultJobPaymentsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobPayments.
func (jp *JobPaymentsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobPaymentsPaginateOption,
) (*JobPaymentsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobPaymentsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jp, err = pager.applyFilter(jp); err != nil {
		return nil, err
	}
	conn := &JobPaymentsConnection{Edges: []*JobPaymentsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jp, err = pager.applyCursors(jp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jp = pager.applyOrder(jp)
	nodes, err := jp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobPaymentsOrderField defines the ordering field of JobPayments.
type JobPaymentsOrderField struct {
	// Value extracts the ordering value from the given JobPayments.
	Value    func(*JobPayments) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobpayments.OrderOption
	toCursor func(*JobPayments) Cursor
}

// JobPaymentsOrder defines the ordering of JobPayments.
type JobPaymentsOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobPaymentsOrderField `json:"field"`
}

// DefaultJobPaymentsOrder is the default ordering of JobPayments.
var DefaultJobPaymentsOrder = &JobPaymentsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobPaymentsOrderField{
		Value: func(jp *JobPayments) (ent.Value, error) {
			return jp.ID, nil
		},
		column: jobpayments.FieldID,
		toTerm: jobpayments.ByID,
		toCursor: func(jp *JobPayments) Cursor {
			return Cursor{ID: jp.ID}
		},
	},
}

// ToEdge converts JobPayments into JobPaymentsEdge.
func (jp *JobPayments) ToEdge(order *JobPaymentsOrder) *JobPaymentsEdge {
	if order == nil {
		order = DefaultJobPaymentsOrder
	}
	return &JobPaymentsEdge{
		Node:   jp,
		Cursor: order.Field.toCursor(jp),
	}
}

// JobProgressEdge is the edge representation of JobProgress.
type JobProgressEdge struct {
	Node   *JobProgress `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobProgressConnection is the connection containing edges to JobProgress.
type JobProgressConnection struct {
	Edges      []*JobProgressEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobProgressConnection) build(nodes []*JobProgress, pager *jobprogressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobProgress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobProgress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobProgress {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobProgressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobProgressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobProgressPaginateOption enables pagination customization.
type JobProgressPaginateOption func(*jobprogressPager) error

// WithJobProgressOrder configures pagination ordering.
func WithJobProgressOrder(order *JobProgressOrder) JobProgressPaginateOption {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	o := *order
	return func(pager *jobprogressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobProgressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobProgressFilter configures pagination filter.
func WithJobProgressFilter(filter func(*JobProgressQuery) (*JobProgressQuery, error)) JobProgressPaginateOption {
	return func(pager *jobprogressPager) error {
		if filter == nil {
			return errors.New("JobProgressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobprogressPager struct {
	reverse bool
	order   *JobProgressOrder
	filter  func(*JobProgressQuery) (*JobProgressQuery, error)
}

func newJobProgressPager(opts []JobProgressPaginateOption, reverse bool) (*jobprogressPager, error) {
	pager := &jobprogressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobProgressOrder
	}
	return pager, nil
}

func (p *jobprogressPager) applyFilter(query *JobProgressQuery) (*JobProgressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobprogressPager) toCursor(jp *JobProgress) Cursor {
	return p.order.Field.toCursor(jp)
}

func (p *jobprogressPager) applyCursors(query *JobProgressQuery, after, before *Cursor) (*JobProgressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobProgressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobprogressPager) applyOrder(query *JobProgressQuery) *JobProgressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobProgressOrder.Field {
		query = query.Order(DefaultJobProgressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobprogressPager) orderExpr(query *JobProgressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobProgressOrder.Field {
			b.Comma().Ident(DefaultJobProgressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobProgress.
func (jp *JobProgressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobProgressPaginateOption,
) (*JobProgressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobProgressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jp, err = pager.applyFilter(jp); err != nil {
		return nil, err
	}
	conn := &JobProgressConnection{Edges: []*JobProgressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jp, err = pager.applyCursors(jp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jp = pager.applyOrder(jp)
	nodes, err := jp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobProgressOrderField defines the ordering field of JobProgress.
type JobProgressOrderField struct {
	// Value extracts the ordering value from the given JobProgress.
	Value    func(*JobProgress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobprogress.OrderOption
	toCursor func(*JobProgress) Cursor
}

// JobProgressOrder defines the ordering of JobProgress.
type JobProgressOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobProgressOrderField `json:"field"`
}

// DefaultJobProgressOrder is the default ordering of JobProgress.
var DefaultJobProgressOrder = &JobProgressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobProgressOrderField{
		Value: func(jp *JobProgress) (ent.Value, error) {
			return jp.ID, nil
		},
		column: jobprogress.FieldID,
		toTerm: jobprogress.ByID,
		toCursor: func(jp *JobProgress) Cursor {
			return Cursor{ID: jp.ID}
		},
	},
}

// ToEdge converts JobProgress into JobProgressEdge.
func (jp *JobProgress) ToEdge(order *JobProgressOrder) *JobProgressEdge {
	if order == nil {
		order = DefaultJobProgressOrder
	}
	return &JobProgressEdge{
		Node:   jp,
		Cursor: order.Field.toCursor(jp),
	}
}

// JobSuperVisorEdge is the edge representation of JobSuperVisor.
type JobSuperVisorEdge struct {
	Node   *JobSuperVisor `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// JobSuperVisorConnection is the connection containing edges to JobSuperVisor.
type JobSuperVisorConnection struct {
	Edges      []*JobSuperVisorEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *JobSuperVisorConnection) build(nodes []*JobSuperVisor, pager *jobsupervisorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobSuperVisor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobSuperVisor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobSuperVisor {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobSuperVisorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobSuperVisorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobSuperVisorPaginateOption enables pagination customization.
type JobSuperVisorPaginateOption func(*jobsupervisorPager) error

// WithJobSuperVisorOrder configures pagination ordering.
func WithJobSuperVisorOrder(order *JobSuperVisorOrder) JobSuperVisorPaginateOption {
	if order == nil {
		order = DefaultJobSuperVisorOrder
	}
	o := *order
	return func(pager *jobsupervisorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobSuperVisorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobSuperVisorFilter configures pagination filter.
func WithJobSuperVisorFilter(filter func(*JobSuperVisorQuery) (*JobSuperVisorQuery, error)) JobSuperVisorPaginateOption {
	return func(pager *jobsupervisorPager) error {
		if filter == nil {
			return errors.New("JobSuperVisorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobsupervisorPager struct {
	reverse bool
	order   *JobSuperVisorOrder
	filter  func(*JobSuperVisorQuery) (*JobSuperVisorQuery, error)
}

func newJobSuperVisorPager(opts []JobSuperVisorPaginateOption, reverse bool) (*jobsupervisorPager, error) {
	pager := &jobsupervisorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobSuperVisorOrder
	}
	return pager, nil
}

func (p *jobsupervisorPager) applyFilter(query *JobSuperVisorQuery) (*JobSuperVisorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobsupervisorPager) toCursor(jsv *JobSuperVisor) Cursor {
	return p.order.Field.toCursor(jsv)
}

func (p *jobsupervisorPager) applyCursors(query *JobSuperVisorQuery, after, before *Cursor) (*JobSuperVisorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobSuperVisorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobsupervisorPager) applyOrder(query *JobSuperVisorQuery) *JobSuperVisorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobSuperVisorOrder.Field {
		query = query.Order(DefaultJobSuperVisorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobsupervisorPager) orderExpr(query *JobSuperVisorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobSuperVisorOrder.Field {
			b.Comma().Ident(DefaultJobSuperVisorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobSuperVisor.
func (jsv *JobSuperVisorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobSuperVisorPaginateOption,
) (*JobSuperVisorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobSuperVisorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jsv, err = pager.applyFilter(jsv); err != nil {
		return nil, err
	}
	conn := &JobSuperVisorConnection{Edges: []*JobSuperVisorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := jsv.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jsv, err = pager.applyCursors(jsv, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		jsv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jsv.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jsv = pager.applyOrder(jsv)
	nodes, err := jsv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// JobSuperVisorOrderField defines the ordering field of JobSuperVisor.
type JobSuperVisorOrderField struct {
	// Value extracts the ordering value from the given JobSuperVisor.
	Value    func(*JobSuperVisor) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobsupervisor.OrderOption
	toCursor func(*JobSuperVisor) Cursor
}

// JobSuperVisorOrder defines the ordering of JobSuperVisor.
type JobSuperVisorOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *JobSuperVisorOrderField `json:"field"`
}

// DefaultJobSuperVisorOrder is the default ordering of JobSuperVisor.
var DefaultJobSuperVisorOrder = &JobSuperVisorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobSuperVisorOrderField{
		Value: func(jsv *JobSuperVisor) (ent.Value, error) {
			return jsv.ID, nil
		},
		column: jobsupervisor.FieldID,
		toTerm: jobsupervisor.ByID,
		toCursor: func(jsv *JobSuperVisor) Cursor {
			return Cursor{ID: jsv.ID}
		},
	},
}

// ToEdge converts JobSuperVisor into JobSuperVisorEdge.
func (jsv *JobSuperVisor) ToEdge(order *JobSuperVisorOrder) *JobSuperVisorEdge {
	if order == nil {
		order = DefaultJobSuperVisorOrder
	}
	return &JobSuperVisorEdge{
		Node:   jsv,
		Cursor: order.Field.toCursor(jsv),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
