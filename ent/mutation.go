// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/polatbilal/gqlgen-ent/ent/companydetail"
	"github.com/polatbilal/gqlgen-ent/ent/companyengineer"
	"github.com/polatbilal/gqlgen-ent/ent/companytoken"
	"github.com/polatbilal/gqlgen-ent/ent/companyuser"
	"github.com/polatbilal/gqlgen-ent/ent/jobauthor"
	"github.com/polatbilal/gqlgen-ent/ent/jobcontractor"
	"github.com/polatbilal/gqlgen-ent/ent/jobdetail"
	"github.com/polatbilal/gqlgen-ent/ent/joblayer"
	"github.com/polatbilal/gqlgen-ent/ent/jobowner"
	"github.com/polatbilal/gqlgen-ent/ent/jobpayments"
	"github.com/polatbilal/gqlgen-ent/ent/jobprogress"
	"github.com/polatbilal/gqlgen-ent/ent/jobsupervisor"
	"github.com/polatbilal/gqlgen-ent/ent/predicate"
	"github.com/polatbilal/gqlgen-ent/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompanyDetail   = "CompanyDetail"
	TypeCompanyEngineer = "CompanyEngineer"
	TypeCompanyToken    = "CompanyToken"
	TypeCompanyUser     = "CompanyUser"
	TypeJobAuthor       = "JobAuthor"
	TypeJobContractor   = "JobContractor"
	TypeJobDetail       = "JobDetail"
	TypeJobLayer        = "JobLayer"
	TypeJobOwner        = "JobOwner"
	TypeJobPayments     = "JobPayments"
	TypeJobProgress     = "JobProgress"
	TypeJobSupervisor   = "JobSupervisor"
	TypeUser            = "User"
)

// CompanyDetailMutation represents an operation that mutates the CompanyDetail nodes in the graph.
type CompanyDetailMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_CompanyCode            *int
	add_CompanyCode         *int
	_Name                   *string
	_Address                *string
	_Phone                  *string
	_Fax                    *string
	_MobilePhone            *string
	_Email                  *string
	_Website                *string
	_TaxAdmin               *string
	_TaxNo                  *int
	add_TaxNo               *int
	_ChamberInfo            *string
	_ChamberRegisterNo      *string
	_VisaDate               *time.Time
	_VisaEndDate            *time.Time
	_VisaFinishedFor90Days  *bool
	_CorePersonAbsent90Days *bool
	_IsClosed               *bool
	_OwnerName              *string
	_OwnerTcNo              *int
	add_OwnerTcNo           *int
	_OwnerAddress           *string
	_OwnerPhone             *string
	_OwnerEmail             *string
	_OwnerRegisterNo        *int
	add_OwnerRegisterNo     *int
	_OwnerCareer            *string
	_CreatedAt              *time.Time
	_UpdatedAt              *time.Time
	clearedFields           map[string]struct{}
	jobs                    map[int]struct{}
	removedjobs             map[int]struct{}
	clearedjobs             bool
	users                   map[int]struct{}
	removedusers            map[int]struct{}
	clearedusers            bool
	tokens                  map[int]struct{}
	removedtokens           map[int]struct{}
	clearedtokens           bool
	engineers               map[int]struct{}
	removedengineers        map[int]struct{}
	clearedengineers        bool
	done                    bool
	oldValue                func(context.Context) (*CompanyDetail, error)
	predicates              []predicate.CompanyDetail
}

var _ ent.Mutation = (*CompanyDetailMutation)(nil)

// companydetailOption allows management of the mutation configuration using functional options.
type companydetailOption func(*CompanyDetailMutation)

// newCompanyDetailMutation creates new mutation for the CompanyDetail entity.
func newCompanyDetailMutation(c config, op Op, opts ...companydetailOption) *CompanyDetailMutation {
	m := &CompanyDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyDetailID sets the ID field of the mutation.
func withCompanyDetailID(id int) companydetailOption {
	return func(m *CompanyDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyDetail
		)
		m.oldValue = func(ctx context.Context) (*CompanyDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyDetail sets the old CompanyDetail of the mutation.
func withCompanyDetail(node *CompanyDetail) companydetailOption {
	return func(m *CompanyDetailMutation) {
		m.oldValue = func(context.Context) (*CompanyDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyCode sets the "CompanyCode" field.
func (m *CompanyDetailMutation) SetCompanyCode(i int) {
	m._CompanyCode = &i
	m.add_CompanyCode = nil
}

// CompanyCode returns the value of the "CompanyCode" field in the mutation.
func (m *CompanyDetailMutation) CompanyCode() (r int, exists bool) {
	v := m._CompanyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyCode returns the old "CompanyCode" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCompanyCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyCode: %w", err)
	}
	return oldValue.CompanyCode, nil
}

// AddCompanyCode adds i to the "CompanyCode" field.
func (m *CompanyDetailMutation) AddCompanyCode(i int) {
	if m.add_CompanyCode != nil {
		*m.add_CompanyCode += i
	} else {
		m.add_CompanyCode = &i
	}
}

// AddedCompanyCode returns the value that was added to the "CompanyCode" field in this mutation.
func (m *CompanyDetailMutation) AddedCompanyCode() (r int, exists bool) {
	v := m.add_CompanyCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyCode resets all changes to the "CompanyCode" field.
func (m *CompanyDetailMutation) ResetCompanyCode() {
	m._CompanyCode = nil
	m.add_CompanyCode = nil
}

// SetName sets the "Name" field.
func (m *CompanyDetailMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CompanyDetailMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *CompanyDetailMutation) ResetName() {
	m._Name = nil
}

// SetAddress sets the "Address" field.
func (m *CompanyDetailMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *CompanyDetailMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *CompanyDetailMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[companydetail.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *CompanyDetailMutation) AddressCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *CompanyDetailMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, companydetail.FieldAddress)
}

// SetPhone sets the "Phone" field.
func (m *CompanyDetailMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *CompanyDetailMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *CompanyDetailMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[companydetail.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *CompanyDetailMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *CompanyDetailMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, companydetail.FieldPhone)
}

// SetFax sets the "Fax" field.
func (m *CompanyDetailMutation) SetFax(s string) {
	m._Fax = &s
}

// Fax returns the value of the "Fax" field in the mutation.
func (m *CompanyDetailMutation) Fax() (r string, exists bool) {
	v := m._Fax
	if v == nil {
		return
	}
	return *v, true
}

// OldFax returns the old "Fax" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldFax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFax: %w", err)
	}
	return oldValue.Fax, nil
}

// ClearFax clears the value of the "Fax" field.
func (m *CompanyDetailMutation) ClearFax() {
	m._Fax = nil
	m.clearedFields[companydetail.FieldFax] = struct{}{}
}

// FaxCleared returns if the "Fax" field was cleared in this mutation.
func (m *CompanyDetailMutation) FaxCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldFax]
	return ok
}

// ResetFax resets all changes to the "Fax" field.
func (m *CompanyDetailMutation) ResetFax() {
	m._Fax = nil
	delete(m.clearedFields, companydetail.FieldFax)
}

// SetMobilePhone sets the "MobilePhone" field.
func (m *CompanyDetailMutation) SetMobilePhone(s string) {
	m._MobilePhone = &s
}

// MobilePhone returns the value of the "MobilePhone" field in the mutation.
func (m *CompanyDetailMutation) MobilePhone() (r string, exists bool) {
	v := m._MobilePhone
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilePhone returns the old "MobilePhone" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldMobilePhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilePhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilePhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilePhone: %w", err)
	}
	return oldValue.MobilePhone, nil
}

// ClearMobilePhone clears the value of the "MobilePhone" field.
func (m *CompanyDetailMutation) ClearMobilePhone() {
	m._MobilePhone = nil
	m.clearedFields[companydetail.FieldMobilePhone] = struct{}{}
}

// MobilePhoneCleared returns if the "MobilePhone" field was cleared in this mutation.
func (m *CompanyDetailMutation) MobilePhoneCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldMobilePhone]
	return ok
}

// ResetMobilePhone resets all changes to the "MobilePhone" field.
func (m *CompanyDetailMutation) ResetMobilePhone() {
	m._MobilePhone = nil
	delete(m.clearedFields, companydetail.FieldMobilePhone)
}

// SetEmail sets the "Email" field.
func (m *CompanyDetailMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *CompanyDetailMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *CompanyDetailMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[companydetail.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *CompanyDetailMutation) EmailCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *CompanyDetailMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, companydetail.FieldEmail)
}

// SetWebsite sets the "Website" field.
func (m *CompanyDetailMutation) SetWebsite(s string) {
	m._Website = &s
}

// Website returns the value of the "Website" field in the mutation.
func (m *CompanyDetailMutation) Website() (r string, exists bool) {
	v := m._Website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "Website" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "Website" field.
func (m *CompanyDetailMutation) ClearWebsite() {
	m._Website = nil
	m.clearedFields[companydetail.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "Website" field was cleared in this mutation.
func (m *CompanyDetailMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "Website" field.
func (m *CompanyDetailMutation) ResetWebsite() {
	m._Website = nil
	delete(m.clearedFields, companydetail.FieldWebsite)
}

// SetTaxAdmin sets the "TaxAdmin" field.
func (m *CompanyDetailMutation) SetTaxAdmin(s string) {
	m._TaxAdmin = &s
}

// TaxAdmin returns the value of the "TaxAdmin" field in the mutation.
func (m *CompanyDetailMutation) TaxAdmin() (r string, exists bool) {
	v := m._TaxAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAdmin returns the old "TaxAdmin" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldTaxAdmin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAdmin: %w", err)
	}
	return oldValue.TaxAdmin, nil
}

// ClearTaxAdmin clears the value of the "TaxAdmin" field.
func (m *CompanyDetailMutation) ClearTaxAdmin() {
	m._TaxAdmin = nil
	m.clearedFields[companydetail.FieldTaxAdmin] = struct{}{}
}

// TaxAdminCleared returns if the "TaxAdmin" field was cleared in this mutation.
func (m *CompanyDetailMutation) TaxAdminCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldTaxAdmin]
	return ok
}

// ResetTaxAdmin resets all changes to the "TaxAdmin" field.
func (m *CompanyDetailMutation) ResetTaxAdmin() {
	m._TaxAdmin = nil
	delete(m.clearedFields, companydetail.FieldTaxAdmin)
}

// SetTaxNo sets the "TaxNo" field.
func (m *CompanyDetailMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *CompanyDetailMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *CompanyDetailMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *CompanyDetailMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *CompanyDetailMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[companydetail.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *CompanyDetailMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *CompanyDetailMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, companydetail.FieldTaxNo)
}

// SetChamberInfo sets the "ChamberInfo" field.
func (m *CompanyDetailMutation) SetChamberInfo(s string) {
	m._ChamberInfo = &s
}

// ChamberInfo returns the value of the "ChamberInfo" field in the mutation.
func (m *CompanyDetailMutation) ChamberInfo() (r string, exists bool) {
	v := m._ChamberInfo
	if v == nil {
		return
	}
	return *v, true
}

// OldChamberInfo returns the old "ChamberInfo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldChamberInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChamberInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChamberInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChamberInfo: %w", err)
	}
	return oldValue.ChamberInfo, nil
}

// ClearChamberInfo clears the value of the "ChamberInfo" field.
func (m *CompanyDetailMutation) ClearChamberInfo() {
	m._ChamberInfo = nil
	m.clearedFields[companydetail.FieldChamberInfo] = struct{}{}
}

// ChamberInfoCleared returns if the "ChamberInfo" field was cleared in this mutation.
func (m *CompanyDetailMutation) ChamberInfoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldChamberInfo]
	return ok
}

// ResetChamberInfo resets all changes to the "ChamberInfo" field.
func (m *CompanyDetailMutation) ResetChamberInfo() {
	m._ChamberInfo = nil
	delete(m.clearedFields, companydetail.FieldChamberInfo)
}

// SetChamberRegisterNo sets the "ChamberRegisterNo" field.
func (m *CompanyDetailMutation) SetChamberRegisterNo(s string) {
	m._ChamberRegisterNo = &s
}

// ChamberRegisterNo returns the value of the "ChamberRegisterNo" field in the mutation.
func (m *CompanyDetailMutation) ChamberRegisterNo() (r string, exists bool) {
	v := m._ChamberRegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldChamberRegisterNo returns the old "ChamberRegisterNo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldChamberRegisterNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChamberRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChamberRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChamberRegisterNo: %w", err)
	}
	return oldValue.ChamberRegisterNo, nil
}

// ClearChamberRegisterNo clears the value of the "ChamberRegisterNo" field.
func (m *CompanyDetailMutation) ClearChamberRegisterNo() {
	m._ChamberRegisterNo = nil
	m.clearedFields[companydetail.FieldChamberRegisterNo] = struct{}{}
}

// ChamberRegisterNoCleared returns if the "ChamberRegisterNo" field was cleared in this mutation.
func (m *CompanyDetailMutation) ChamberRegisterNoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldChamberRegisterNo]
	return ok
}

// ResetChamberRegisterNo resets all changes to the "ChamberRegisterNo" field.
func (m *CompanyDetailMutation) ResetChamberRegisterNo() {
	m._ChamberRegisterNo = nil
	delete(m.clearedFields, companydetail.FieldChamberRegisterNo)
}

// SetVisaDate sets the "VisaDate" field.
func (m *CompanyDetailMutation) SetVisaDate(t time.Time) {
	m._VisaDate = &t
}

// VisaDate returns the value of the "VisaDate" field in the mutation.
func (m *CompanyDetailMutation) VisaDate() (r time.Time, exists bool) {
	v := m._VisaDate
	if v == nil {
		return
	}
	return *v, true
}

// OldVisaDate returns the old "VisaDate" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldVisaDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisaDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisaDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisaDate: %w", err)
	}
	return oldValue.VisaDate, nil
}

// ClearVisaDate clears the value of the "VisaDate" field.
func (m *CompanyDetailMutation) ClearVisaDate() {
	m._VisaDate = nil
	m.clearedFields[companydetail.FieldVisaDate] = struct{}{}
}

// VisaDateCleared returns if the "VisaDate" field was cleared in this mutation.
func (m *CompanyDetailMutation) VisaDateCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldVisaDate]
	return ok
}

// ResetVisaDate resets all changes to the "VisaDate" field.
func (m *CompanyDetailMutation) ResetVisaDate() {
	m._VisaDate = nil
	delete(m.clearedFields, companydetail.FieldVisaDate)
}

// SetVisaEndDate sets the "VisaEndDate" field.
func (m *CompanyDetailMutation) SetVisaEndDate(t time.Time) {
	m._VisaEndDate = &t
}

// VisaEndDate returns the value of the "VisaEndDate" field in the mutation.
func (m *CompanyDetailMutation) VisaEndDate() (r time.Time, exists bool) {
	v := m._VisaEndDate
	if v == nil {
		return
	}
	return *v, true
}

// OldVisaEndDate returns the old "VisaEndDate" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldVisaEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisaEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisaEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisaEndDate: %w", err)
	}
	return oldValue.VisaEndDate, nil
}

// ClearVisaEndDate clears the value of the "VisaEndDate" field.
func (m *CompanyDetailMutation) ClearVisaEndDate() {
	m._VisaEndDate = nil
	m.clearedFields[companydetail.FieldVisaEndDate] = struct{}{}
}

// VisaEndDateCleared returns if the "VisaEndDate" field was cleared in this mutation.
func (m *CompanyDetailMutation) VisaEndDateCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldVisaEndDate]
	return ok
}

// ResetVisaEndDate resets all changes to the "VisaEndDate" field.
func (m *CompanyDetailMutation) ResetVisaEndDate() {
	m._VisaEndDate = nil
	delete(m.clearedFields, companydetail.FieldVisaEndDate)
}

// SetVisaFinishedFor90Days sets the "VisaFinishedFor90Days" field.
func (m *CompanyDetailMutation) SetVisaFinishedFor90Days(b bool) {
	m._VisaFinishedFor90Days = &b
}

// VisaFinishedFor90Days returns the value of the "VisaFinishedFor90Days" field in the mutation.
func (m *CompanyDetailMutation) VisaFinishedFor90Days() (r bool, exists bool) {
	v := m._VisaFinishedFor90Days
	if v == nil {
		return
	}
	return *v, true
}

// OldVisaFinishedFor90Days returns the old "VisaFinishedFor90Days" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldVisaFinishedFor90Days(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisaFinishedFor90Days is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisaFinishedFor90Days requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisaFinishedFor90Days: %w", err)
	}
	return oldValue.VisaFinishedFor90Days, nil
}

// ClearVisaFinishedFor90Days clears the value of the "VisaFinishedFor90Days" field.
func (m *CompanyDetailMutation) ClearVisaFinishedFor90Days() {
	m._VisaFinishedFor90Days = nil
	m.clearedFields[companydetail.FieldVisaFinishedFor90Days] = struct{}{}
}

// VisaFinishedFor90DaysCleared returns if the "VisaFinishedFor90Days" field was cleared in this mutation.
func (m *CompanyDetailMutation) VisaFinishedFor90DaysCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldVisaFinishedFor90Days]
	return ok
}

// ResetVisaFinishedFor90Days resets all changes to the "VisaFinishedFor90Days" field.
func (m *CompanyDetailMutation) ResetVisaFinishedFor90Days() {
	m._VisaFinishedFor90Days = nil
	delete(m.clearedFields, companydetail.FieldVisaFinishedFor90Days)
}

// SetCorePersonAbsent90Days sets the "CorePersonAbsent90Days" field.
func (m *CompanyDetailMutation) SetCorePersonAbsent90Days(b bool) {
	m._CorePersonAbsent90Days = &b
}

// CorePersonAbsent90Days returns the value of the "CorePersonAbsent90Days" field in the mutation.
func (m *CompanyDetailMutation) CorePersonAbsent90Days() (r bool, exists bool) {
	v := m._CorePersonAbsent90Days
	if v == nil {
		return
	}
	return *v, true
}

// OldCorePersonAbsent90Days returns the old "CorePersonAbsent90Days" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCorePersonAbsent90Days(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorePersonAbsent90Days is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorePersonAbsent90Days requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorePersonAbsent90Days: %w", err)
	}
	return oldValue.CorePersonAbsent90Days, nil
}

// ClearCorePersonAbsent90Days clears the value of the "CorePersonAbsent90Days" field.
func (m *CompanyDetailMutation) ClearCorePersonAbsent90Days() {
	m._CorePersonAbsent90Days = nil
	m.clearedFields[companydetail.FieldCorePersonAbsent90Days] = struct{}{}
}

// CorePersonAbsent90DaysCleared returns if the "CorePersonAbsent90Days" field was cleared in this mutation.
func (m *CompanyDetailMutation) CorePersonAbsent90DaysCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldCorePersonAbsent90Days]
	return ok
}

// ResetCorePersonAbsent90Days resets all changes to the "CorePersonAbsent90Days" field.
func (m *CompanyDetailMutation) ResetCorePersonAbsent90Days() {
	m._CorePersonAbsent90Days = nil
	delete(m.clearedFields, companydetail.FieldCorePersonAbsent90Days)
}

// SetIsClosed sets the "IsClosed" field.
func (m *CompanyDetailMutation) SetIsClosed(b bool) {
	m._IsClosed = &b
}

// IsClosed returns the value of the "IsClosed" field in the mutation.
func (m *CompanyDetailMutation) IsClosed() (r bool, exists bool) {
	v := m._IsClosed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsClosed returns the old "IsClosed" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldIsClosed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsClosed: %w", err)
	}
	return oldValue.IsClosed, nil
}

// ResetIsClosed resets all changes to the "IsClosed" field.
func (m *CompanyDetailMutation) ResetIsClosed() {
	m._IsClosed = nil
}

// SetOwnerName sets the "OwnerName" field.
func (m *CompanyDetailMutation) SetOwnerName(s string) {
	m._OwnerName = &s
}

// OwnerName returns the value of the "OwnerName" field in the mutation.
func (m *CompanyDetailMutation) OwnerName() (r string, exists bool) {
	v := m._OwnerName
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerName returns the old "OwnerName" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerName: %w", err)
	}
	return oldValue.OwnerName, nil
}

// ClearOwnerName clears the value of the "OwnerName" field.
func (m *CompanyDetailMutation) ClearOwnerName() {
	m._OwnerName = nil
	m.clearedFields[companydetail.FieldOwnerName] = struct{}{}
}

// OwnerNameCleared returns if the "OwnerName" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerNameCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerName]
	return ok
}

// ResetOwnerName resets all changes to the "OwnerName" field.
func (m *CompanyDetailMutation) ResetOwnerName() {
	m._OwnerName = nil
	delete(m.clearedFields, companydetail.FieldOwnerName)
}

// SetOwnerTcNo sets the "OwnerTcNo" field.
func (m *CompanyDetailMutation) SetOwnerTcNo(i int) {
	m._OwnerTcNo = &i
	m.add_OwnerTcNo = nil
}

// OwnerTcNo returns the value of the "OwnerTcNo" field in the mutation.
func (m *CompanyDetailMutation) OwnerTcNo() (r int, exists bool) {
	v := m._OwnerTcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerTcNo returns the old "OwnerTcNo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerTcNo: %w", err)
	}
	return oldValue.OwnerTcNo, nil
}

// AddOwnerTcNo adds i to the "OwnerTcNo" field.
func (m *CompanyDetailMutation) AddOwnerTcNo(i int) {
	if m.add_OwnerTcNo != nil {
		*m.add_OwnerTcNo += i
	} else {
		m.add_OwnerTcNo = &i
	}
}

// AddedOwnerTcNo returns the value that was added to the "OwnerTcNo" field in this mutation.
func (m *CompanyDetailMutation) AddedOwnerTcNo() (r int, exists bool) {
	v := m.add_OwnerTcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerTcNo clears the value of the "OwnerTcNo" field.
func (m *CompanyDetailMutation) ClearOwnerTcNo() {
	m._OwnerTcNo = nil
	m.add_OwnerTcNo = nil
	m.clearedFields[companydetail.FieldOwnerTcNo] = struct{}{}
}

// OwnerTcNoCleared returns if the "OwnerTcNo" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerTcNoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerTcNo]
	return ok
}

// ResetOwnerTcNo resets all changes to the "OwnerTcNo" field.
func (m *CompanyDetailMutation) ResetOwnerTcNo() {
	m._OwnerTcNo = nil
	m.add_OwnerTcNo = nil
	delete(m.clearedFields, companydetail.FieldOwnerTcNo)
}

// SetOwnerAddress sets the "OwnerAddress" field.
func (m *CompanyDetailMutation) SetOwnerAddress(s string) {
	m._OwnerAddress = &s
}

// OwnerAddress returns the value of the "OwnerAddress" field in the mutation.
func (m *CompanyDetailMutation) OwnerAddress() (r string, exists bool) {
	v := m._OwnerAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "OwnerAddress" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ClearOwnerAddress clears the value of the "OwnerAddress" field.
func (m *CompanyDetailMutation) ClearOwnerAddress() {
	m._OwnerAddress = nil
	m.clearedFields[companydetail.FieldOwnerAddress] = struct{}{}
}

// OwnerAddressCleared returns if the "OwnerAddress" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerAddressCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerAddress]
	return ok
}

// ResetOwnerAddress resets all changes to the "OwnerAddress" field.
func (m *CompanyDetailMutation) ResetOwnerAddress() {
	m._OwnerAddress = nil
	delete(m.clearedFields, companydetail.FieldOwnerAddress)
}

// SetOwnerPhone sets the "OwnerPhone" field.
func (m *CompanyDetailMutation) SetOwnerPhone(s string) {
	m._OwnerPhone = &s
}

// OwnerPhone returns the value of the "OwnerPhone" field in the mutation.
func (m *CompanyDetailMutation) OwnerPhone() (r string, exists bool) {
	v := m._OwnerPhone
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerPhone returns the old "OwnerPhone" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerPhone: %w", err)
	}
	return oldValue.OwnerPhone, nil
}

// ClearOwnerPhone clears the value of the "OwnerPhone" field.
func (m *CompanyDetailMutation) ClearOwnerPhone() {
	m._OwnerPhone = nil
	m.clearedFields[companydetail.FieldOwnerPhone] = struct{}{}
}

// OwnerPhoneCleared returns if the "OwnerPhone" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerPhoneCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerPhone]
	return ok
}

// ResetOwnerPhone resets all changes to the "OwnerPhone" field.
func (m *CompanyDetailMutation) ResetOwnerPhone() {
	m._OwnerPhone = nil
	delete(m.clearedFields, companydetail.FieldOwnerPhone)
}

// SetOwnerEmail sets the "OwnerEmail" field.
func (m *CompanyDetailMutation) SetOwnerEmail(s string) {
	m._OwnerEmail = &s
}

// OwnerEmail returns the value of the "OwnerEmail" field in the mutation.
func (m *CompanyDetailMutation) OwnerEmail() (r string, exists bool) {
	v := m._OwnerEmail
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerEmail returns the old "OwnerEmail" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerEmail: %w", err)
	}
	return oldValue.OwnerEmail, nil
}

// ClearOwnerEmail clears the value of the "OwnerEmail" field.
func (m *CompanyDetailMutation) ClearOwnerEmail() {
	m._OwnerEmail = nil
	m.clearedFields[companydetail.FieldOwnerEmail] = struct{}{}
}

// OwnerEmailCleared returns if the "OwnerEmail" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerEmailCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerEmail]
	return ok
}

// ResetOwnerEmail resets all changes to the "OwnerEmail" field.
func (m *CompanyDetailMutation) ResetOwnerEmail() {
	m._OwnerEmail = nil
	delete(m.clearedFields, companydetail.FieldOwnerEmail)
}

// SetOwnerRegisterNo sets the "OwnerRegisterNo" field.
func (m *CompanyDetailMutation) SetOwnerRegisterNo(i int) {
	m._OwnerRegisterNo = &i
	m.add_OwnerRegisterNo = nil
}

// OwnerRegisterNo returns the value of the "OwnerRegisterNo" field in the mutation.
func (m *CompanyDetailMutation) OwnerRegisterNo() (r int, exists bool) {
	v := m._OwnerRegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerRegisterNo returns the old "OwnerRegisterNo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerRegisterNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerRegisterNo: %w", err)
	}
	return oldValue.OwnerRegisterNo, nil
}

// AddOwnerRegisterNo adds i to the "OwnerRegisterNo" field.
func (m *CompanyDetailMutation) AddOwnerRegisterNo(i int) {
	if m.add_OwnerRegisterNo != nil {
		*m.add_OwnerRegisterNo += i
	} else {
		m.add_OwnerRegisterNo = &i
	}
}

// AddedOwnerRegisterNo returns the value that was added to the "OwnerRegisterNo" field in this mutation.
func (m *CompanyDetailMutation) AddedOwnerRegisterNo() (r int, exists bool) {
	v := m.add_OwnerRegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerRegisterNo clears the value of the "OwnerRegisterNo" field.
func (m *CompanyDetailMutation) ClearOwnerRegisterNo() {
	m._OwnerRegisterNo = nil
	m.add_OwnerRegisterNo = nil
	m.clearedFields[companydetail.FieldOwnerRegisterNo] = struct{}{}
}

// OwnerRegisterNoCleared returns if the "OwnerRegisterNo" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerRegisterNoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerRegisterNo]
	return ok
}

// ResetOwnerRegisterNo resets all changes to the "OwnerRegisterNo" field.
func (m *CompanyDetailMutation) ResetOwnerRegisterNo() {
	m._OwnerRegisterNo = nil
	m.add_OwnerRegisterNo = nil
	delete(m.clearedFields, companydetail.FieldOwnerRegisterNo)
}

// SetOwnerCareer sets the "OwnerCareer" field.
func (m *CompanyDetailMutation) SetOwnerCareer(s string) {
	m._OwnerCareer = &s
}

// OwnerCareer returns the value of the "OwnerCareer" field in the mutation.
func (m *CompanyDetailMutation) OwnerCareer() (r string, exists bool) {
	v := m._OwnerCareer
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerCareer returns the old "OwnerCareer" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldOwnerCareer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerCareer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerCareer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerCareer: %w", err)
	}
	return oldValue.OwnerCareer, nil
}

// ClearOwnerCareer clears the value of the "OwnerCareer" field.
func (m *CompanyDetailMutation) ClearOwnerCareer() {
	m._OwnerCareer = nil
	m.clearedFields[companydetail.FieldOwnerCareer] = struct{}{}
}

// OwnerCareerCleared returns if the "OwnerCareer" field was cleared in this mutation.
func (m *CompanyDetailMutation) OwnerCareerCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldOwnerCareer]
	return ok
}

// ResetOwnerCareer resets all changes to the "OwnerCareer" field.
func (m *CompanyDetailMutation) ResetOwnerCareer() {
	m._OwnerCareer = nil
	delete(m.clearedFields, companydetail.FieldOwnerCareer)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CompanyDetailMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CompanyDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CompanyDetailMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CompanyDetailMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CompanyDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CompanyDetailMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddJobIDs adds the "jobs" edge to the JobDetail entity by ids.
func (m *CompanyDetailMutation) AddJobIDs(ids ...int) {
	if m.jobs == nil {
		m.jobs = make(map[int]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the JobDetail entity.
func (m *CompanyDetailMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the JobDetail entity was cleared.
func (m *CompanyDetailMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the JobDetail entity by IDs.
func (m *CompanyDetailMutation) RemoveJobIDs(ids ...int) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the JobDetail entity.
func (m *CompanyDetailMutation) RemovedJobsIDs() (ids []int) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *CompanyDetailMutation) JobsIDs() (ids []int) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *CompanyDetailMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// AddUserIDs adds the "users" edge to the CompanyUser entity by ids.
func (m *CompanyDetailMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the CompanyUser entity.
func (m *CompanyDetailMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the CompanyUser entity was cleared.
func (m *CompanyDetailMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the CompanyUser entity by IDs.
func (m *CompanyDetailMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the CompanyUser entity.
func (m *CompanyDetailMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *CompanyDetailMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *CompanyDetailMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddTokenIDs adds the "tokens" edge to the CompanyToken entity by ids.
func (m *CompanyDetailMutation) AddTokenIDs(ids ...int) {
	if m.tokens == nil {
		m.tokens = make(map[int]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the CompanyToken entity.
func (m *CompanyDetailMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the CompanyToken entity was cleared.
func (m *CompanyDetailMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the CompanyToken entity by IDs.
func (m *CompanyDetailMutation) RemoveTokenIDs(ids ...int) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the CompanyToken entity.
func (m *CompanyDetailMutation) RemovedTokensIDs() (ids []int) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *CompanyDetailMutation) TokensIDs() (ids []int) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *CompanyDetailMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddEngineerIDs adds the "engineers" edge to the CompanyEngineer entity by ids.
func (m *CompanyDetailMutation) AddEngineerIDs(ids ...int) {
	if m.engineers == nil {
		m.engineers = make(map[int]struct{})
	}
	for i := range ids {
		m.engineers[ids[i]] = struct{}{}
	}
}

// ClearEngineers clears the "engineers" edge to the CompanyEngineer entity.
func (m *CompanyDetailMutation) ClearEngineers() {
	m.clearedengineers = true
}

// EngineersCleared reports if the "engineers" edge to the CompanyEngineer entity was cleared.
func (m *CompanyDetailMutation) EngineersCleared() bool {
	return m.clearedengineers
}

// RemoveEngineerIDs removes the "engineers" edge to the CompanyEngineer entity by IDs.
func (m *CompanyDetailMutation) RemoveEngineerIDs(ids ...int) {
	if m.removedengineers == nil {
		m.removedengineers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.engineers, ids[i])
		m.removedengineers[ids[i]] = struct{}{}
	}
}

// RemovedEngineers returns the removed IDs of the "engineers" edge to the CompanyEngineer entity.
func (m *CompanyDetailMutation) RemovedEngineersIDs() (ids []int) {
	for id := range m.removedengineers {
		ids = append(ids, id)
	}
	return
}

// EngineersIDs returns the "engineers" edge IDs in the mutation.
func (m *CompanyDetailMutation) EngineersIDs() (ids []int) {
	for id := range m.engineers {
		ids = append(ids, id)
	}
	return
}

// ResetEngineers resets all changes to the "engineers" edge.
func (m *CompanyDetailMutation) ResetEngineers() {
	m.engineers = nil
	m.clearedengineers = false
	m.removedengineers = nil
}

// Where appends a list predicates to the CompanyDetailMutation builder.
func (m *CompanyDetailMutation) Where(ps ...predicate.CompanyDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyDetail).
func (m *CompanyDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyDetailMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m._CompanyCode != nil {
		fields = append(fields, companydetail.FieldCompanyCode)
	}
	if m._Name != nil {
		fields = append(fields, companydetail.FieldName)
	}
	if m._Address != nil {
		fields = append(fields, companydetail.FieldAddress)
	}
	if m._Phone != nil {
		fields = append(fields, companydetail.FieldPhone)
	}
	if m._Fax != nil {
		fields = append(fields, companydetail.FieldFax)
	}
	if m._MobilePhone != nil {
		fields = append(fields, companydetail.FieldMobilePhone)
	}
	if m._Email != nil {
		fields = append(fields, companydetail.FieldEmail)
	}
	if m._Website != nil {
		fields = append(fields, companydetail.FieldWebsite)
	}
	if m._TaxAdmin != nil {
		fields = append(fields, companydetail.FieldTaxAdmin)
	}
	if m._TaxNo != nil {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	if m._ChamberInfo != nil {
		fields = append(fields, companydetail.FieldChamberInfo)
	}
	if m._ChamberRegisterNo != nil {
		fields = append(fields, companydetail.FieldChamberRegisterNo)
	}
	if m._VisaDate != nil {
		fields = append(fields, companydetail.FieldVisaDate)
	}
	if m._VisaEndDate != nil {
		fields = append(fields, companydetail.FieldVisaEndDate)
	}
	if m._VisaFinishedFor90Days != nil {
		fields = append(fields, companydetail.FieldVisaFinishedFor90Days)
	}
	if m._CorePersonAbsent90Days != nil {
		fields = append(fields, companydetail.FieldCorePersonAbsent90Days)
	}
	if m._IsClosed != nil {
		fields = append(fields, companydetail.FieldIsClosed)
	}
	if m._OwnerName != nil {
		fields = append(fields, companydetail.FieldOwnerName)
	}
	if m._OwnerTcNo != nil {
		fields = append(fields, companydetail.FieldOwnerTcNo)
	}
	if m._OwnerAddress != nil {
		fields = append(fields, companydetail.FieldOwnerAddress)
	}
	if m._OwnerPhone != nil {
		fields = append(fields, companydetail.FieldOwnerPhone)
	}
	if m._OwnerEmail != nil {
		fields = append(fields, companydetail.FieldOwnerEmail)
	}
	if m._OwnerRegisterNo != nil {
		fields = append(fields, companydetail.FieldOwnerRegisterNo)
	}
	if m._OwnerCareer != nil {
		fields = append(fields, companydetail.FieldOwnerCareer)
	}
	if m._CreatedAt != nil {
		fields = append(fields, companydetail.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, companydetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.CompanyCode()
	case companydetail.FieldName:
		return m.Name()
	case companydetail.FieldAddress:
		return m.Address()
	case companydetail.FieldPhone:
		return m.Phone()
	case companydetail.FieldFax:
		return m.Fax()
	case companydetail.FieldMobilePhone:
		return m.MobilePhone()
	case companydetail.FieldEmail:
		return m.Email()
	case companydetail.FieldWebsite:
		return m.Website()
	case companydetail.FieldTaxAdmin:
		return m.TaxAdmin()
	case companydetail.FieldTaxNo:
		return m.TaxNo()
	case companydetail.FieldChamberInfo:
		return m.ChamberInfo()
	case companydetail.FieldChamberRegisterNo:
		return m.ChamberRegisterNo()
	case companydetail.FieldVisaDate:
		return m.VisaDate()
	case companydetail.FieldVisaEndDate:
		return m.VisaEndDate()
	case companydetail.FieldVisaFinishedFor90Days:
		return m.VisaFinishedFor90Days()
	case companydetail.FieldCorePersonAbsent90Days:
		return m.CorePersonAbsent90Days()
	case companydetail.FieldIsClosed:
		return m.IsClosed()
	case companydetail.FieldOwnerName:
		return m.OwnerName()
	case companydetail.FieldOwnerTcNo:
		return m.OwnerTcNo()
	case companydetail.FieldOwnerAddress:
		return m.OwnerAddress()
	case companydetail.FieldOwnerPhone:
		return m.OwnerPhone()
	case companydetail.FieldOwnerEmail:
		return m.OwnerEmail()
	case companydetail.FieldOwnerRegisterNo:
		return m.OwnerRegisterNo()
	case companydetail.FieldOwnerCareer:
		return m.OwnerCareer()
	case companydetail.FieldCreatedAt:
		return m.CreatedAt()
	case companydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.OldCompanyCode(ctx)
	case companydetail.FieldName:
		return m.OldName(ctx)
	case companydetail.FieldAddress:
		return m.OldAddress(ctx)
	case companydetail.FieldPhone:
		return m.OldPhone(ctx)
	case companydetail.FieldFax:
		return m.OldFax(ctx)
	case companydetail.FieldMobilePhone:
		return m.OldMobilePhone(ctx)
	case companydetail.FieldEmail:
		return m.OldEmail(ctx)
	case companydetail.FieldWebsite:
		return m.OldWebsite(ctx)
	case companydetail.FieldTaxAdmin:
		return m.OldTaxAdmin(ctx)
	case companydetail.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case companydetail.FieldChamberInfo:
		return m.OldChamberInfo(ctx)
	case companydetail.FieldChamberRegisterNo:
		return m.OldChamberRegisterNo(ctx)
	case companydetail.FieldVisaDate:
		return m.OldVisaDate(ctx)
	case companydetail.FieldVisaEndDate:
		return m.OldVisaEndDate(ctx)
	case companydetail.FieldVisaFinishedFor90Days:
		return m.OldVisaFinishedFor90Days(ctx)
	case companydetail.FieldCorePersonAbsent90Days:
		return m.OldCorePersonAbsent90Days(ctx)
	case companydetail.FieldIsClosed:
		return m.OldIsClosed(ctx)
	case companydetail.FieldOwnerName:
		return m.OldOwnerName(ctx)
	case companydetail.FieldOwnerTcNo:
		return m.OldOwnerTcNo(ctx)
	case companydetail.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case companydetail.FieldOwnerPhone:
		return m.OldOwnerPhone(ctx)
	case companydetail.FieldOwnerEmail:
		return m.OldOwnerEmail(ctx)
	case companydetail.FieldOwnerRegisterNo:
		return m.OldOwnerRegisterNo(ctx)
	case companydetail.FieldOwnerCareer:
		return m.OldOwnerCareer(ctx)
	case companydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companydetail.FieldCompanyCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyCode(v)
		return nil
	case companydetail.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case companydetail.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case companydetail.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case companydetail.FieldFax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFax(v)
		return nil
	case companydetail.FieldMobilePhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilePhone(v)
		return nil
	case companydetail.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case companydetail.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case companydetail.FieldTaxAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAdmin(v)
		return nil
	case companydetail.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case companydetail.FieldChamberInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChamberInfo(v)
		return nil
	case companydetail.FieldChamberRegisterNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChamberRegisterNo(v)
		return nil
	case companydetail.FieldVisaDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisaDate(v)
		return nil
	case companydetail.FieldVisaEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisaEndDate(v)
		return nil
	case companydetail.FieldVisaFinishedFor90Days:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisaFinishedFor90Days(v)
		return nil
	case companydetail.FieldCorePersonAbsent90Days:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorePersonAbsent90Days(v)
		return nil
	case companydetail.FieldIsClosed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsClosed(v)
		return nil
	case companydetail.FieldOwnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerName(v)
		return nil
	case companydetail.FieldOwnerTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerTcNo(v)
		return nil
	case companydetail.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case companydetail.FieldOwnerPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerPhone(v)
		return nil
	case companydetail.FieldOwnerEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerEmail(v)
		return nil
	case companydetail.FieldOwnerRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerRegisterNo(v)
		return nil
	case companydetail.FieldOwnerCareer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerCareer(v)
		return nil
	case companydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_CompanyCode != nil {
		fields = append(fields, companydetail.FieldCompanyCode)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	if m.add_OwnerTcNo != nil {
		fields = append(fields, companydetail.FieldOwnerTcNo)
	}
	if m.add_OwnerRegisterNo != nil {
		fields = append(fields, companydetail.FieldOwnerRegisterNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.AddedCompanyCode()
	case companydetail.FieldTaxNo:
		return m.AddedTaxNo()
	case companydetail.FieldOwnerTcNo:
		return m.AddedOwnerTcNo()
	case companydetail.FieldOwnerRegisterNo:
		return m.AddedOwnerRegisterNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companydetail.FieldCompanyCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyCode(v)
		return nil
	case companydetail.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	case companydetail.FieldOwnerTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerTcNo(v)
		return nil
	case companydetail.FieldOwnerRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerRegisterNo(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companydetail.FieldAddress) {
		fields = append(fields, companydetail.FieldAddress)
	}
	if m.FieldCleared(companydetail.FieldPhone) {
		fields = append(fields, companydetail.FieldPhone)
	}
	if m.FieldCleared(companydetail.FieldFax) {
		fields = append(fields, companydetail.FieldFax)
	}
	if m.FieldCleared(companydetail.FieldMobilePhone) {
		fields = append(fields, companydetail.FieldMobilePhone)
	}
	if m.FieldCleared(companydetail.FieldEmail) {
		fields = append(fields, companydetail.FieldEmail)
	}
	if m.FieldCleared(companydetail.FieldWebsite) {
		fields = append(fields, companydetail.FieldWebsite)
	}
	if m.FieldCleared(companydetail.FieldTaxAdmin) {
		fields = append(fields, companydetail.FieldTaxAdmin)
	}
	if m.FieldCleared(companydetail.FieldTaxNo) {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	if m.FieldCleared(companydetail.FieldChamberInfo) {
		fields = append(fields, companydetail.FieldChamberInfo)
	}
	if m.FieldCleared(companydetail.FieldChamberRegisterNo) {
		fields = append(fields, companydetail.FieldChamberRegisterNo)
	}
	if m.FieldCleared(companydetail.FieldVisaDate) {
		fields = append(fields, companydetail.FieldVisaDate)
	}
	if m.FieldCleared(companydetail.FieldVisaEndDate) {
		fields = append(fields, companydetail.FieldVisaEndDate)
	}
	if m.FieldCleared(companydetail.FieldVisaFinishedFor90Days) {
		fields = append(fields, companydetail.FieldVisaFinishedFor90Days)
	}
	if m.FieldCleared(companydetail.FieldCorePersonAbsent90Days) {
		fields = append(fields, companydetail.FieldCorePersonAbsent90Days)
	}
	if m.FieldCleared(companydetail.FieldOwnerName) {
		fields = append(fields, companydetail.FieldOwnerName)
	}
	if m.FieldCleared(companydetail.FieldOwnerTcNo) {
		fields = append(fields, companydetail.FieldOwnerTcNo)
	}
	if m.FieldCleared(companydetail.FieldOwnerAddress) {
		fields = append(fields, companydetail.FieldOwnerAddress)
	}
	if m.FieldCleared(companydetail.FieldOwnerPhone) {
		fields = append(fields, companydetail.FieldOwnerPhone)
	}
	if m.FieldCleared(companydetail.FieldOwnerEmail) {
		fields = append(fields, companydetail.FieldOwnerEmail)
	}
	if m.FieldCleared(companydetail.FieldOwnerRegisterNo) {
		fields = append(fields, companydetail.FieldOwnerRegisterNo)
	}
	if m.FieldCleared(companydetail.FieldOwnerCareer) {
		fields = append(fields, companydetail.FieldOwnerCareer)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyDetailMutation) ClearField(name string) error {
	switch name {
	case companydetail.FieldAddress:
		m.ClearAddress()
		return nil
	case companydetail.FieldPhone:
		m.ClearPhone()
		return nil
	case companydetail.FieldFax:
		m.ClearFax()
		return nil
	case companydetail.FieldMobilePhone:
		m.ClearMobilePhone()
		return nil
	case companydetail.FieldEmail:
		m.ClearEmail()
		return nil
	case companydetail.FieldWebsite:
		m.ClearWebsite()
		return nil
	case companydetail.FieldTaxAdmin:
		m.ClearTaxAdmin()
		return nil
	case companydetail.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case companydetail.FieldChamberInfo:
		m.ClearChamberInfo()
		return nil
	case companydetail.FieldChamberRegisterNo:
		m.ClearChamberRegisterNo()
		return nil
	case companydetail.FieldVisaDate:
		m.ClearVisaDate()
		return nil
	case companydetail.FieldVisaEndDate:
		m.ClearVisaEndDate()
		return nil
	case companydetail.FieldVisaFinishedFor90Days:
		m.ClearVisaFinishedFor90Days()
		return nil
	case companydetail.FieldCorePersonAbsent90Days:
		m.ClearCorePersonAbsent90Days()
		return nil
	case companydetail.FieldOwnerName:
		m.ClearOwnerName()
		return nil
	case companydetail.FieldOwnerTcNo:
		m.ClearOwnerTcNo()
		return nil
	case companydetail.FieldOwnerAddress:
		m.ClearOwnerAddress()
		return nil
	case companydetail.FieldOwnerPhone:
		m.ClearOwnerPhone()
		return nil
	case companydetail.FieldOwnerEmail:
		m.ClearOwnerEmail()
		return nil
	case companydetail.FieldOwnerRegisterNo:
		m.ClearOwnerRegisterNo()
		return nil
	case companydetail.FieldOwnerCareer:
		m.ClearOwnerCareer()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyDetailMutation) ResetField(name string) error {
	switch name {
	case companydetail.FieldCompanyCode:
		m.ResetCompanyCode()
		return nil
	case companydetail.FieldName:
		m.ResetName()
		return nil
	case companydetail.FieldAddress:
		m.ResetAddress()
		return nil
	case companydetail.FieldPhone:
		m.ResetPhone()
		return nil
	case companydetail.FieldFax:
		m.ResetFax()
		return nil
	case companydetail.FieldMobilePhone:
		m.ResetMobilePhone()
		return nil
	case companydetail.FieldEmail:
		m.ResetEmail()
		return nil
	case companydetail.FieldWebsite:
		m.ResetWebsite()
		return nil
	case companydetail.FieldTaxAdmin:
		m.ResetTaxAdmin()
		return nil
	case companydetail.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case companydetail.FieldChamberInfo:
		m.ResetChamberInfo()
		return nil
	case companydetail.FieldChamberRegisterNo:
		m.ResetChamberRegisterNo()
		return nil
	case companydetail.FieldVisaDate:
		m.ResetVisaDate()
		return nil
	case companydetail.FieldVisaEndDate:
		m.ResetVisaEndDate()
		return nil
	case companydetail.FieldVisaFinishedFor90Days:
		m.ResetVisaFinishedFor90Days()
		return nil
	case companydetail.FieldCorePersonAbsent90Days:
		m.ResetCorePersonAbsent90Days()
		return nil
	case companydetail.FieldIsClosed:
		m.ResetIsClosed()
		return nil
	case companydetail.FieldOwnerName:
		m.ResetOwnerName()
		return nil
	case companydetail.FieldOwnerTcNo:
		m.ResetOwnerTcNo()
		return nil
	case companydetail.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case companydetail.FieldOwnerPhone:
		m.ResetOwnerPhone()
		return nil
	case companydetail.FieldOwnerEmail:
		m.ResetOwnerEmail()
		return nil
	case companydetail.FieldOwnerRegisterNo:
		m.ResetOwnerRegisterNo()
		return nil
	case companydetail.FieldOwnerCareer:
		m.ResetOwnerCareer()
		return nil
	case companydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.jobs != nil {
		edges = append(edges, companydetail.EdgeJobs)
	}
	if m.users != nil {
		edges = append(edges, companydetail.EdgeUsers)
	}
	if m.tokens != nil {
		edges = append(edges, companydetail.EdgeTokens)
	}
	if m.engineers != nil {
		edges = append(edges, companydetail.EdgeEngineers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companydetail.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeEngineers:
		ids := make([]ent.Value, 0, len(m.engineers))
		for id := range m.engineers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedjobs != nil {
		edges = append(edges, companydetail.EdgeJobs)
	}
	if m.removedusers != nil {
		edges = append(edges, companydetail.EdgeUsers)
	}
	if m.removedtokens != nil {
		edges = append(edges, companydetail.EdgeTokens)
	}
	if m.removedengineers != nil {
		edges = append(edges, companydetail.EdgeEngineers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case companydetail.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case companydetail.EdgeEngineers:
		ids := make([]ent.Value, 0, len(m.removedengineers))
		for id := range m.removedengineers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedjobs {
		edges = append(edges, companydetail.EdgeJobs)
	}
	if m.clearedusers {
		edges = append(edges, companydetail.EdgeUsers)
	}
	if m.clearedtokens {
		edges = append(edges, companydetail.EdgeTokens)
	}
	if m.clearedengineers {
		edges = append(edges, companydetail.EdgeEngineers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case companydetail.EdgeJobs:
		return m.clearedjobs
	case companydetail.EdgeUsers:
		return m.clearedusers
	case companydetail.EdgeTokens:
		return m.clearedtokens
	case companydetail.EdgeEngineers:
		return m.clearedengineers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyDetailMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CompanyDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyDetailMutation) ResetEdge(name string) error {
	switch name {
	case companydetail.EdgeJobs:
		m.ResetJobs()
		return nil
	case companydetail.EdgeUsers:
		m.ResetUsers()
		return nil
	case companydetail.EdgeTokens:
		m.ResetTokens()
		return nil
	case companydetail.EdgeEngineers:
		m.ResetEngineers()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail edge %s", name)
}

// CompanyEngineerMutation represents an operation that mutates the CompanyEngineer nodes in the graph.
type CompanyEngineerMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Name                      *string
	_TcNo                      *int
	add_TcNo                   *int
	_Phone                     *string
	_Email                     *string
	_Address                   *string
	_Career                    *string
	_Position                  *string
	_RegisterNo                *int
	add_RegisterNo             *int
	_CertNo                    *int
	add_CertNo                 *int
	_YDSID                     *int
	add_YDSID                  *int
	_Employment                *time.Time
	_Status                    *int
	add_Status                 *int
	_Note                      *string
	_CreatedAt                 *time.Time
	_UpdatedAt                 *time.Time
	clearedFields              map[string]struct{}
	company                    *int
	clearedcompany             bool
	statics                    map[int]struct{}
	removedstatics             map[int]struct{}
	clearedstatics             bool
	mechanics                  map[int]struct{}
	removedmechanics           map[int]struct{}
	clearedmechanics           bool
	electrics                  map[int]struct{}
	removedelectrics           map[int]struct{}
	clearedelectrics           bool
	inspectors                 map[int]struct{}
	removedinspectors          map[int]struct{}
	clearedinspectors          bool
	architects                 map[int]struct{}
	removedarchitects          map[int]struct{}
	clearedarchitects          bool
	controllers                map[int]struct{}
	removedcontrollers         map[int]struct{}
	clearedcontrollers         bool
	mechaniccontrollers        map[int]struct{}
	removedmechaniccontrollers map[int]struct{}
	clearedmechaniccontrollers bool
	electriccontrollers        map[int]struct{}
	removedelectriccontrollers map[int]struct{}
	clearedelectriccontrollers bool
	done                       bool
	oldValue                   func(context.Context) (*CompanyEngineer, error)
	predicates                 []predicate.CompanyEngineer
}

var _ ent.Mutation = (*CompanyEngineerMutation)(nil)

// companyengineerOption allows management of the mutation configuration using functional options.
type companyengineerOption func(*CompanyEngineerMutation)

// newCompanyEngineerMutation creates new mutation for the CompanyEngineer entity.
func newCompanyEngineerMutation(c config, op Op, opts ...companyengineerOption) *CompanyEngineerMutation {
	m := &CompanyEngineerMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyEngineer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyEngineerID sets the ID field of the mutation.
func withCompanyEngineerID(id int) companyengineerOption {
	return func(m *CompanyEngineerMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyEngineer
		)
		m.oldValue = func(ctx context.Context) (*CompanyEngineer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyEngineer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyEngineer sets the old CompanyEngineer of the mutation.
func withCompanyEngineer(node *CompanyEngineer) companyengineerOption {
	return func(m *CompanyEngineerMutation) {
		m.oldValue = func(context.Context) (*CompanyEngineer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyEngineerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyEngineerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyEngineerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyEngineerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyEngineer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *CompanyEngineerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CompanyEngineerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *CompanyEngineerMutation) ResetName() {
	m._Name = nil
}

// SetTcNo sets the "TcNo" field.
func (m *CompanyEngineerMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *CompanyEngineerMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *CompanyEngineerMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *CompanyEngineerMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[companyengineer.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *CompanyEngineerMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, companyengineer.FieldTcNo)
}

// SetPhone sets the "Phone" field.
func (m *CompanyEngineerMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *CompanyEngineerMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *CompanyEngineerMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[companyengineer.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *CompanyEngineerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *CompanyEngineerMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, companyengineer.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *CompanyEngineerMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *CompanyEngineerMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *CompanyEngineerMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[companyengineer.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *CompanyEngineerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *CompanyEngineerMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, companyengineer.FieldEmail)
}

// SetAddress sets the "Address" field.
func (m *CompanyEngineerMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *CompanyEngineerMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *CompanyEngineerMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[companyengineer.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *CompanyEngineerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *CompanyEngineerMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, companyengineer.FieldAddress)
}

// SetCareer sets the "Career" field.
func (m *CompanyEngineerMutation) SetCareer(s string) {
	m._Career = &s
}

// Career returns the value of the "Career" field in the mutation.
func (m *CompanyEngineerMutation) Career() (r string, exists bool) {
	v := m._Career
	if v == nil {
		return
	}
	return *v, true
}

// OldCareer returns the old "Career" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCareer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCareer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCareer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCareer: %w", err)
	}
	return oldValue.Career, nil
}

// ClearCareer clears the value of the "Career" field.
func (m *CompanyEngineerMutation) ClearCareer() {
	m._Career = nil
	m.clearedFields[companyengineer.FieldCareer] = struct{}{}
}

// CareerCleared returns if the "Career" field was cleared in this mutation.
func (m *CompanyEngineerMutation) CareerCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldCareer]
	return ok
}

// ResetCareer resets all changes to the "Career" field.
func (m *CompanyEngineerMutation) ResetCareer() {
	m._Career = nil
	delete(m.clearedFields, companyengineer.FieldCareer)
}

// SetPosition sets the "Position" field.
func (m *CompanyEngineerMutation) SetPosition(s string) {
	m._Position = &s
}

// Position returns the value of the "Position" field in the mutation.
func (m *CompanyEngineerMutation) Position() (r string, exists bool) {
	v := m._Position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "Position" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "Position" field.
func (m *CompanyEngineerMutation) ClearPosition() {
	m._Position = nil
	m.clearedFields[companyengineer.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "Position" field was cleared in this mutation.
func (m *CompanyEngineerMutation) PositionCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "Position" field.
func (m *CompanyEngineerMutation) ResetPosition() {
	m._Position = nil
	delete(m.clearedFields, companyengineer.FieldPosition)
}

// SetRegisterNo sets the "RegisterNo" field.
func (m *CompanyEngineerMutation) SetRegisterNo(i int) {
	m._RegisterNo = &i
	m.add_RegisterNo = nil
}

// RegisterNo returns the value of the "RegisterNo" field in the mutation.
func (m *CompanyEngineerMutation) RegisterNo() (r int, exists bool) {
	v := m._RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterNo returns the old "RegisterNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldRegisterNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterNo: %w", err)
	}
	return oldValue.RegisterNo, nil
}

// AddRegisterNo adds i to the "RegisterNo" field.
func (m *CompanyEngineerMutation) AddRegisterNo(i int) {
	if m.add_RegisterNo != nil {
		*m.add_RegisterNo += i
	} else {
		m.add_RegisterNo = &i
	}
}

// AddedRegisterNo returns the value that was added to the "RegisterNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedRegisterNo() (r int, exists bool) {
	v := m.add_RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegisterNo clears the value of the "RegisterNo" field.
func (m *CompanyEngineerMutation) ClearRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	m.clearedFields[companyengineer.FieldRegisterNo] = struct{}{}
}

// RegisterNoCleared returns if the "RegisterNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) RegisterNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldRegisterNo]
	return ok
}

// ResetRegisterNo resets all changes to the "RegisterNo" field.
func (m *CompanyEngineerMutation) ResetRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	delete(m.clearedFields, companyengineer.FieldRegisterNo)
}

// SetCertNo sets the "CertNo" field.
func (m *CompanyEngineerMutation) SetCertNo(i int) {
	m._CertNo = &i
	m.add_CertNo = nil
}

// CertNo returns the value of the "CertNo" field in the mutation.
func (m *CompanyEngineerMutation) CertNo() (r int, exists bool) {
	v := m._CertNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCertNo returns the old "CertNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCertNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertNo: %w", err)
	}
	return oldValue.CertNo, nil
}

// AddCertNo adds i to the "CertNo" field.
func (m *CompanyEngineerMutation) AddCertNo(i int) {
	if m.add_CertNo != nil {
		*m.add_CertNo += i
	} else {
		m.add_CertNo = &i
	}
}

// AddedCertNo returns the value that was added to the "CertNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedCertNo() (r int, exists bool) {
	v := m.add_CertNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearCertNo clears the value of the "CertNo" field.
func (m *CompanyEngineerMutation) ClearCertNo() {
	m._CertNo = nil
	m.add_CertNo = nil
	m.clearedFields[companyengineer.FieldCertNo] = struct{}{}
}

// CertNoCleared returns if the "CertNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) CertNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldCertNo]
	return ok
}

// ResetCertNo resets all changes to the "CertNo" field.
func (m *CompanyEngineerMutation) ResetCertNo() {
	m._CertNo = nil
	m.add_CertNo = nil
	delete(m.clearedFields, companyengineer.FieldCertNo)
}

// SetYDSID sets the "YDSID" field.
func (m *CompanyEngineerMutation) SetYDSID(i int) {
	m._YDSID = &i
	m.add_YDSID = nil
}

// YDSID returns the value of the "YDSID" field in the mutation.
func (m *CompanyEngineerMutation) YDSID() (r int, exists bool) {
	v := m._YDSID
	if v == nil {
		return
	}
	return *v, true
}

// OldYDSID returns the old "YDSID" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldYDSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYDSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYDSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYDSID: %w", err)
	}
	return oldValue.YDSID, nil
}

// AddYDSID adds i to the "YDSID" field.
func (m *CompanyEngineerMutation) AddYDSID(i int) {
	if m.add_YDSID != nil {
		*m.add_YDSID += i
	} else {
		m.add_YDSID = &i
	}
}

// AddedYDSID returns the value that was added to the "YDSID" field in this mutation.
func (m *CompanyEngineerMutation) AddedYDSID() (r int, exists bool) {
	v := m.add_YDSID
	if v == nil {
		return
	}
	return *v, true
}

// ClearYDSID clears the value of the "YDSID" field.
func (m *CompanyEngineerMutation) ClearYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	m.clearedFields[companyengineer.FieldYDSID] = struct{}{}
}

// YDSIDCleared returns if the "YDSID" field was cleared in this mutation.
func (m *CompanyEngineerMutation) YDSIDCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldYDSID]
	return ok
}

// ResetYDSID resets all changes to the "YDSID" field.
func (m *CompanyEngineerMutation) ResetYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	delete(m.clearedFields, companyengineer.FieldYDSID)
}

// SetEmployment sets the "Employment" field.
func (m *CompanyEngineerMutation) SetEmployment(t time.Time) {
	m._Employment = &t
}

// Employment returns the value of the "Employment" field in the mutation.
func (m *CompanyEngineerMutation) Employment() (r time.Time, exists bool) {
	v := m._Employment
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployment returns the old "Employment" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldEmployment(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployment: %w", err)
	}
	return oldValue.Employment, nil
}

// ClearEmployment clears the value of the "Employment" field.
func (m *CompanyEngineerMutation) ClearEmployment() {
	m._Employment = nil
	m.clearedFields[companyengineer.FieldEmployment] = struct{}{}
}

// EmploymentCleared returns if the "Employment" field was cleared in this mutation.
func (m *CompanyEngineerMutation) EmploymentCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldEmployment]
	return ok
}

// ResetEmployment resets all changes to the "Employment" field.
func (m *CompanyEngineerMutation) ResetEmployment() {
	m._Employment = nil
	delete(m.clearedFields, companyengineer.FieldEmployment)
}

// SetStatus sets the "Status" field.
func (m *CompanyEngineerMutation) SetStatus(i int) {
	m._Status = &i
	m.add_Status = nil
}

// Status returns the value of the "Status" field in the mutation.
func (m *CompanyEngineerMutation) Status() (r int, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "Status" field.
func (m *CompanyEngineerMutation) AddStatus(i int) {
	if m.add_Status != nil {
		*m.add_Status += i
	} else {
		m.add_Status = &i
	}
}

// AddedStatus returns the value that was added to the "Status" field in this mutation.
func (m *CompanyEngineerMutation) AddedStatus() (r int, exists bool) {
	v := m.add_Status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "Status" field.
func (m *CompanyEngineerMutation) ResetStatus() {
	m._Status = nil
	m.add_Status = nil
}

// SetNote sets the "Note" field.
func (m *CompanyEngineerMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *CompanyEngineerMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *CompanyEngineerMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[companyengineer.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *CompanyEngineerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *CompanyEngineerMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, companyengineer.FieldNote)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CompanyEngineerMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CompanyEngineerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CompanyEngineerMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CompanyEngineerMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CompanyEngineerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CompanyEngineerMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetCompanyID sets the "company" edge to the CompanyDetail entity by id.
func (m *CompanyEngineerMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the CompanyDetail entity.
func (m *CompanyEngineerMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the CompanyDetail entity was cleared.
func (m *CompanyEngineerMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyEngineerMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyEngineerMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyEngineerMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddStaticIDs adds the "statics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddStaticIDs(ids ...int) {
	if m.statics == nil {
		m.statics = make(map[int]struct{})
	}
	for i := range ids {
		m.statics[ids[i]] = struct{}{}
	}
}

// ClearStatics clears the "statics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearStatics() {
	m.clearedstatics = true
}

// StaticsCleared reports if the "statics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) StaticsCleared() bool {
	return m.clearedstatics
}

// RemoveStaticIDs removes the "statics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveStaticIDs(ids ...int) {
	if m.removedstatics == nil {
		m.removedstatics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.statics, ids[i])
		m.removedstatics[ids[i]] = struct{}{}
	}
}

// RemovedStatics returns the removed IDs of the "statics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedStaticsIDs() (ids []int) {
	for id := range m.removedstatics {
		ids = append(ids, id)
	}
	return
}

// StaticsIDs returns the "statics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) StaticsIDs() (ids []int) {
	for id := range m.statics {
		ids = append(ids, id)
	}
	return
}

// ResetStatics resets all changes to the "statics" edge.
func (m *CompanyEngineerMutation) ResetStatics() {
	m.statics = nil
	m.clearedstatics = false
	m.removedstatics = nil
}

// AddMechanicIDs adds the "mechanics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddMechanicIDs(ids ...int) {
	if m.mechanics == nil {
		m.mechanics = make(map[int]struct{})
	}
	for i := range ids {
		m.mechanics[ids[i]] = struct{}{}
	}
}

// ClearMechanics clears the "mechanics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearMechanics() {
	m.clearedmechanics = true
}

// MechanicsCleared reports if the "mechanics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) MechanicsCleared() bool {
	return m.clearedmechanics
}

// RemoveMechanicIDs removes the "mechanics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveMechanicIDs(ids ...int) {
	if m.removedmechanics == nil {
		m.removedmechanics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mechanics, ids[i])
		m.removedmechanics[ids[i]] = struct{}{}
	}
}

// RemovedMechanics returns the removed IDs of the "mechanics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedMechanicsIDs() (ids []int) {
	for id := range m.removedmechanics {
		ids = append(ids, id)
	}
	return
}

// MechanicsIDs returns the "mechanics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) MechanicsIDs() (ids []int) {
	for id := range m.mechanics {
		ids = append(ids, id)
	}
	return
}

// ResetMechanics resets all changes to the "mechanics" edge.
func (m *CompanyEngineerMutation) ResetMechanics() {
	m.mechanics = nil
	m.clearedmechanics = false
	m.removedmechanics = nil
}

// AddElectricIDs adds the "electrics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddElectricIDs(ids ...int) {
	if m.electrics == nil {
		m.electrics = make(map[int]struct{})
	}
	for i := range ids {
		m.electrics[ids[i]] = struct{}{}
	}
}

// ClearElectrics clears the "electrics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearElectrics() {
	m.clearedelectrics = true
}

// ElectricsCleared reports if the "electrics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ElectricsCleared() bool {
	return m.clearedelectrics
}

// RemoveElectricIDs removes the "electrics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveElectricIDs(ids ...int) {
	if m.removedelectrics == nil {
		m.removedelectrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.electrics, ids[i])
		m.removedelectrics[ids[i]] = struct{}{}
	}
}

// RemovedElectrics returns the removed IDs of the "electrics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedElectricsIDs() (ids []int) {
	for id := range m.removedelectrics {
		ids = append(ids, id)
	}
	return
}

// ElectricsIDs returns the "electrics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ElectricsIDs() (ids []int) {
	for id := range m.electrics {
		ids = append(ids, id)
	}
	return
}

// ResetElectrics resets all changes to the "electrics" edge.
func (m *CompanyEngineerMutation) ResetElectrics() {
	m.electrics = nil
	m.clearedelectrics = false
	m.removedelectrics = nil
}

// AddInspectorIDs adds the "inspectors" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddInspectorIDs(ids ...int) {
	if m.inspectors == nil {
		m.inspectors = make(map[int]struct{})
	}
	for i := range ids {
		m.inspectors[ids[i]] = struct{}{}
	}
}

// ClearInspectors clears the "inspectors" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearInspectors() {
	m.clearedinspectors = true
}

// InspectorsCleared reports if the "inspectors" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) InspectorsCleared() bool {
	return m.clearedinspectors
}

// RemoveInspectorIDs removes the "inspectors" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveInspectorIDs(ids ...int) {
	if m.removedinspectors == nil {
		m.removedinspectors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inspectors, ids[i])
		m.removedinspectors[ids[i]] = struct{}{}
	}
}

// RemovedInspectors returns the removed IDs of the "inspectors" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedInspectorsIDs() (ids []int) {
	for id := range m.removedinspectors {
		ids = append(ids, id)
	}
	return
}

// InspectorsIDs returns the "inspectors" edge IDs in the mutation.
func (m *CompanyEngineerMutation) InspectorsIDs() (ids []int) {
	for id := range m.inspectors {
		ids = append(ids, id)
	}
	return
}

// ResetInspectors resets all changes to the "inspectors" edge.
func (m *CompanyEngineerMutation) ResetInspectors() {
	m.inspectors = nil
	m.clearedinspectors = false
	m.removedinspectors = nil
}

// AddArchitectIDs adds the "architects" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddArchitectIDs(ids ...int) {
	if m.architects == nil {
		m.architects = make(map[int]struct{})
	}
	for i := range ids {
		m.architects[ids[i]] = struct{}{}
	}
}

// ClearArchitects clears the "architects" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearArchitects() {
	m.clearedarchitects = true
}

// ArchitectsCleared reports if the "architects" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ArchitectsCleared() bool {
	return m.clearedarchitects
}

// RemoveArchitectIDs removes the "architects" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveArchitectIDs(ids ...int) {
	if m.removedarchitects == nil {
		m.removedarchitects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.architects, ids[i])
		m.removedarchitects[ids[i]] = struct{}{}
	}
}

// RemovedArchitects returns the removed IDs of the "architects" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedArchitectsIDs() (ids []int) {
	for id := range m.removedarchitects {
		ids = append(ids, id)
	}
	return
}

// ArchitectsIDs returns the "architects" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ArchitectsIDs() (ids []int) {
	for id := range m.architects {
		ids = append(ids, id)
	}
	return
}

// ResetArchitects resets all changes to the "architects" edge.
func (m *CompanyEngineerMutation) ResetArchitects() {
	m.architects = nil
	m.clearedarchitects = false
	m.removedarchitects = nil
}

// AddControllerIDs adds the "controllers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddControllerIDs(ids ...int) {
	if m.controllers == nil {
		m.controllers = make(map[int]struct{})
	}
	for i := range ids {
		m.controllers[ids[i]] = struct{}{}
	}
}

// ClearControllers clears the "controllers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearControllers() {
	m.clearedcontrollers = true
}

// ControllersCleared reports if the "controllers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ControllersCleared() bool {
	return m.clearedcontrollers
}

// RemoveControllerIDs removes the "controllers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveControllerIDs(ids ...int) {
	if m.removedcontrollers == nil {
		m.removedcontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.controllers, ids[i])
		m.removedcontrollers[ids[i]] = struct{}{}
	}
}

// RemovedControllers returns the removed IDs of the "controllers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedControllersIDs() (ids []int) {
	for id := range m.removedcontrollers {
		ids = append(ids, id)
	}
	return
}

// ControllersIDs returns the "controllers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ControllersIDs() (ids []int) {
	for id := range m.controllers {
		ids = append(ids, id)
	}
	return
}

// ResetControllers resets all changes to the "controllers" edge.
func (m *CompanyEngineerMutation) ResetControllers() {
	m.controllers = nil
	m.clearedcontrollers = false
	m.removedcontrollers = nil
}

// AddMechaniccontrollerIDs adds the "mechaniccontrollers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddMechaniccontrollerIDs(ids ...int) {
	if m.mechaniccontrollers == nil {
		m.mechaniccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		m.mechaniccontrollers[ids[i]] = struct{}{}
	}
}

// ClearMechaniccontrollers clears the "mechaniccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearMechaniccontrollers() {
	m.clearedmechaniccontrollers = true
}

// MechaniccontrollersCleared reports if the "mechaniccontrollers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) MechaniccontrollersCleared() bool {
	return m.clearedmechaniccontrollers
}

// RemoveMechaniccontrollerIDs removes the "mechaniccontrollers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveMechaniccontrollerIDs(ids ...int) {
	if m.removedmechaniccontrollers == nil {
		m.removedmechaniccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mechaniccontrollers, ids[i])
		m.removedmechaniccontrollers[ids[i]] = struct{}{}
	}
}

// RemovedMechaniccontrollers returns the removed IDs of the "mechaniccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedMechaniccontrollersIDs() (ids []int) {
	for id := range m.removedmechaniccontrollers {
		ids = append(ids, id)
	}
	return
}

// MechaniccontrollersIDs returns the "mechaniccontrollers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) MechaniccontrollersIDs() (ids []int) {
	for id := range m.mechaniccontrollers {
		ids = append(ids, id)
	}
	return
}

// ResetMechaniccontrollers resets all changes to the "mechaniccontrollers" edge.
func (m *CompanyEngineerMutation) ResetMechaniccontrollers() {
	m.mechaniccontrollers = nil
	m.clearedmechaniccontrollers = false
	m.removedmechaniccontrollers = nil
}

// AddElectriccontrollerIDs adds the "electriccontrollers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddElectriccontrollerIDs(ids ...int) {
	if m.electriccontrollers == nil {
		m.electriccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		m.electriccontrollers[ids[i]] = struct{}{}
	}
}

// ClearElectriccontrollers clears the "electriccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearElectriccontrollers() {
	m.clearedelectriccontrollers = true
}

// ElectriccontrollersCleared reports if the "electriccontrollers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ElectriccontrollersCleared() bool {
	return m.clearedelectriccontrollers
}

// RemoveElectriccontrollerIDs removes the "electriccontrollers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveElectriccontrollerIDs(ids ...int) {
	if m.removedelectriccontrollers == nil {
		m.removedelectriccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.electriccontrollers, ids[i])
		m.removedelectriccontrollers[ids[i]] = struct{}{}
	}
}

// RemovedElectriccontrollers returns the removed IDs of the "electriccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedElectriccontrollersIDs() (ids []int) {
	for id := range m.removedelectriccontrollers {
		ids = append(ids, id)
	}
	return
}

// ElectriccontrollersIDs returns the "electriccontrollers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ElectriccontrollersIDs() (ids []int) {
	for id := range m.electriccontrollers {
		ids = append(ids, id)
	}
	return
}

// ResetElectriccontrollers resets all changes to the "electriccontrollers" edge.
func (m *CompanyEngineerMutation) ResetElectriccontrollers() {
	m.electriccontrollers = nil
	m.clearedelectriccontrollers = false
	m.removedelectriccontrollers = nil
}

// Where appends a list predicates to the CompanyEngineerMutation builder.
func (m *CompanyEngineerMutation) Where(ps ...predicate.CompanyEngineer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyEngineerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyEngineerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyEngineer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyEngineerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyEngineerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyEngineer).
func (m *CompanyEngineerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyEngineerMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m._Name != nil {
		fields = append(fields, companyengineer.FieldName)
	}
	if m._TcNo != nil {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m._Phone != nil {
		fields = append(fields, companyengineer.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, companyengineer.FieldEmail)
	}
	if m._Address != nil {
		fields = append(fields, companyengineer.FieldAddress)
	}
	if m._Career != nil {
		fields = append(fields, companyengineer.FieldCareer)
	}
	if m._Position != nil {
		fields = append(fields, companyengineer.FieldPosition)
	}
	if m._RegisterNo != nil {
		fields = append(fields, companyengineer.FieldRegisterNo)
	}
	if m._CertNo != nil {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m._YDSID != nil {
		fields = append(fields, companyengineer.FieldYDSID)
	}
	if m._Employment != nil {
		fields = append(fields, companyengineer.FieldEmployment)
	}
	if m._Status != nil {
		fields = append(fields, companyengineer.FieldStatus)
	}
	if m._Note != nil {
		fields = append(fields, companyengineer.FieldNote)
	}
	if m._CreatedAt != nil {
		fields = append(fields, companyengineer.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, companyengineer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyEngineerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companyengineer.FieldName:
		return m.Name()
	case companyengineer.FieldTcNo:
		return m.TcNo()
	case companyengineer.FieldPhone:
		return m.Phone()
	case companyengineer.FieldEmail:
		return m.Email()
	case companyengineer.FieldAddress:
		return m.Address()
	case companyengineer.FieldCareer:
		return m.Career()
	case companyengineer.FieldPosition:
		return m.Position()
	case companyengineer.FieldRegisterNo:
		return m.RegisterNo()
	case companyengineer.FieldCertNo:
		return m.CertNo()
	case companyengineer.FieldYDSID:
		return m.YDSID()
	case companyengineer.FieldEmployment:
		return m.Employment()
	case companyengineer.FieldStatus:
		return m.Status()
	case companyengineer.FieldNote:
		return m.Note()
	case companyengineer.FieldCreatedAt:
		return m.CreatedAt()
	case companyengineer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyEngineerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companyengineer.FieldName:
		return m.OldName(ctx)
	case companyengineer.FieldTcNo:
		return m.OldTcNo(ctx)
	case companyengineer.FieldPhone:
		return m.OldPhone(ctx)
	case companyengineer.FieldEmail:
		return m.OldEmail(ctx)
	case companyengineer.FieldAddress:
		return m.OldAddress(ctx)
	case companyengineer.FieldCareer:
		return m.OldCareer(ctx)
	case companyengineer.FieldPosition:
		return m.OldPosition(ctx)
	case companyengineer.FieldRegisterNo:
		return m.OldRegisterNo(ctx)
	case companyengineer.FieldCertNo:
		return m.OldCertNo(ctx)
	case companyengineer.FieldYDSID:
		return m.OldYDSID(ctx)
	case companyengineer.FieldEmployment:
		return m.OldEmployment(ctx)
	case companyengineer.FieldStatus:
		return m.OldStatus(ctx)
	case companyengineer.FieldNote:
		return m.OldNote(ctx)
	case companyengineer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companyengineer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyEngineerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companyengineer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case companyengineer.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case companyengineer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case companyengineer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case companyengineer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case companyengineer.FieldCareer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCareer(v)
		return nil
	case companyengineer.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case companyengineer.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterNo(v)
		return nil
	case companyengineer.FieldCertNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertNo(v)
		return nil
	case companyengineer.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYDSID(v)
		return nil
	case companyengineer.FieldEmployment:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployment(v)
		return nil
	case companyengineer.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case companyengineer.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case companyengineer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companyengineer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyEngineerMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m.add_RegisterNo != nil {
		fields = append(fields, companyengineer.FieldRegisterNo)
	}
	if m.add_CertNo != nil {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m.add_YDSID != nil {
		fields = append(fields, companyengineer.FieldYDSID)
	}
	if m.add_Status != nil {
		fields = append(fields, companyengineer.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyEngineerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companyengineer.FieldTcNo:
		return m.AddedTcNo()
	case companyengineer.FieldRegisterNo:
		return m.AddedRegisterNo()
	case companyengineer.FieldCertNo:
		return m.AddedCertNo()
	case companyengineer.FieldYDSID:
		return m.AddedYDSID()
	case companyengineer.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyEngineerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companyengineer.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case companyengineer.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterNo(v)
		return nil
	case companyengineer.FieldCertNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCertNo(v)
		return nil
	case companyengineer.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYDSID(v)
		return nil
	case companyengineer.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyEngineerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companyengineer.FieldTcNo) {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m.FieldCleared(companyengineer.FieldPhone) {
		fields = append(fields, companyengineer.FieldPhone)
	}
	if m.FieldCleared(companyengineer.FieldEmail) {
		fields = append(fields, companyengineer.FieldEmail)
	}
	if m.FieldCleared(companyengineer.FieldAddress) {
		fields = append(fields, companyengineer.FieldAddress)
	}
	if m.FieldCleared(companyengineer.FieldCareer) {
		fields = append(fields, companyengineer.FieldCareer)
	}
	if m.FieldCleared(companyengineer.FieldPosition) {
		fields = append(fields, companyengineer.FieldPosition)
	}
	if m.FieldCleared(companyengineer.FieldRegisterNo) {
		fields = append(fields, companyengineer.FieldRegisterNo)
	}
	if m.FieldCleared(companyengineer.FieldCertNo) {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m.FieldCleared(companyengineer.FieldYDSID) {
		fields = append(fields, companyengineer.FieldYDSID)
	}
	if m.FieldCleared(companyengineer.FieldEmployment) {
		fields = append(fields, companyengineer.FieldEmployment)
	}
	if m.FieldCleared(companyengineer.FieldNote) {
		fields = append(fields, companyengineer.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyEngineerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyEngineerMutation) ClearField(name string) error {
	switch name {
	case companyengineer.FieldTcNo:
		m.ClearTcNo()
		return nil
	case companyengineer.FieldPhone:
		m.ClearPhone()
		return nil
	case companyengineer.FieldEmail:
		m.ClearEmail()
		return nil
	case companyengineer.FieldAddress:
		m.ClearAddress()
		return nil
	case companyengineer.FieldCareer:
		m.ClearCareer()
		return nil
	case companyengineer.FieldPosition:
		m.ClearPosition()
		return nil
	case companyengineer.FieldRegisterNo:
		m.ClearRegisterNo()
		return nil
	case companyengineer.FieldCertNo:
		m.ClearCertNo()
		return nil
	case companyengineer.FieldYDSID:
		m.ClearYDSID()
		return nil
	case companyengineer.FieldEmployment:
		m.ClearEmployment()
		return nil
	case companyengineer.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyEngineerMutation) ResetField(name string) error {
	switch name {
	case companyengineer.FieldName:
		m.ResetName()
		return nil
	case companyengineer.FieldTcNo:
		m.ResetTcNo()
		return nil
	case companyengineer.FieldPhone:
		m.ResetPhone()
		return nil
	case companyengineer.FieldEmail:
		m.ResetEmail()
		return nil
	case companyengineer.FieldAddress:
		m.ResetAddress()
		return nil
	case companyengineer.FieldCareer:
		m.ResetCareer()
		return nil
	case companyengineer.FieldPosition:
		m.ResetPosition()
		return nil
	case companyengineer.FieldRegisterNo:
		m.ResetRegisterNo()
		return nil
	case companyengineer.FieldCertNo:
		m.ResetCertNo()
		return nil
	case companyengineer.FieldYDSID:
		m.ResetYDSID()
		return nil
	case companyengineer.FieldEmployment:
		m.ResetEmployment()
		return nil
	case companyengineer.FieldStatus:
		m.ResetStatus()
		return nil
	case companyengineer.FieldNote:
		m.ResetNote()
		return nil
	case companyengineer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companyengineer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyEngineerMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.company != nil {
		edges = append(edges, companyengineer.EdgeCompany)
	}
	if m.statics != nil {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.mechanics != nil {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.electrics != nil {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.inspectors != nil {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.architects != nil {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.controllers != nil {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.mechaniccontrollers != nil {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.electriccontrollers != nil {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyEngineerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companyengineer.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case companyengineer.EdgeStatics:
		ids := make([]ent.Value, 0, len(m.statics))
		for id := range m.statics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechanics:
		ids := make([]ent.Value, 0, len(m.mechanics))
		for id := range m.mechanics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectrics:
		ids := make([]ent.Value, 0, len(m.electrics))
		for id := range m.electrics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeInspectors:
		ids := make([]ent.Value, 0, len(m.inspectors))
		for id := range m.inspectors {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeArchitects:
		ids := make([]ent.Value, 0, len(m.architects))
		for id := range m.architects {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeControllers:
		ids := make([]ent.Value, 0, len(m.controllers))
		for id := range m.controllers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechaniccontrollers:
		ids := make([]ent.Value, 0, len(m.mechaniccontrollers))
		for id := range m.mechaniccontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectriccontrollers:
		ids := make([]ent.Value, 0, len(m.electriccontrollers))
		for id := range m.electriccontrollers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyEngineerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedstatics != nil {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.removedmechanics != nil {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.removedelectrics != nil {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.removedinspectors != nil {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.removedarchitects != nil {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.removedcontrollers != nil {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.removedmechaniccontrollers != nil {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.removedelectriccontrollers != nil {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyEngineerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case companyengineer.EdgeStatics:
		ids := make([]ent.Value, 0, len(m.removedstatics))
		for id := range m.removedstatics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechanics:
		ids := make([]ent.Value, 0, len(m.removedmechanics))
		for id := range m.removedmechanics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectrics:
		ids := make([]ent.Value, 0, len(m.removedelectrics))
		for id := range m.removedelectrics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeInspectors:
		ids := make([]ent.Value, 0, len(m.removedinspectors))
		for id := range m.removedinspectors {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeArchitects:
		ids := make([]ent.Value, 0, len(m.removedarchitects))
		for id := range m.removedarchitects {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeControllers:
		ids := make([]ent.Value, 0, len(m.removedcontrollers))
		for id := range m.removedcontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechaniccontrollers:
		ids := make([]ent.Value, 0, len(m.removedmechaniccontrollers))
		for id := range m.removedmechaniccontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectriccontrollers:
		ids := make([]ent.Value, 0, len(m.removedelectriccontrollers))
		for id := range m.removedelectriccontrollers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyEngineerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcompany {
		edges = append(edges, companyengineer.EdgeCompany)
	}
	if m.clearedstatics {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.clearedmechanics {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.clearedelectrics {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.clearedinspectors {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.clearedarchitects {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.clearedcontrollers {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.clearedmechaniccontrollers {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.clearedelectriccontrollers {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyEngineerMutation) EdgeCleared(name string) bool {
	switch name {
	case companyengineer.EdgeCompany:
		return m.clearedcompany
	case companyengineer.EdgeStatics:
		return m.clearedstatics
	case companyengineer.EdgeMechanics:
		return m.clearedmechanics
	case companyengineer.EdgeElectrics:
		return m.clearedelectrics
	case companyengineer.EdgeInspectors:
		return m.clearedinspectors
	case companyengineer.EdgeArchitects:
		return m.clearedarchitects
	case companyengineer.EdgeControllers:
		return m.clearedcontrollers
	case companyengineer.EdgeMechaniccontrollers:
		return m.clearedmechaniccontrollers
	case companyengineer.EdgeElectriccontrollers:
		return m.clearedelectriccontrollers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyEngineerMutation) ClearEdge(name string) error {
	switch name {
	case companyengineer.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyEngineerMutation) ResetEdge(name string) error {
	switch name {
	case companyengineer.EdgeCompany:
		m.ResetCompany()
		return nil
	case companyengineer.EdgeStatics:
		m.ResetStatics()
		return nil
	case companyengineer.EdgeMechanics:
		m.ResetMechanics()
		return nil
	case companyengineer.EdgeElectrics:
		m.ResetElectrics()
		return nil
	case companyengineer.EdgeInspectors:
		m.ResetInspectors()
		return nil
	case companyengineer.EdgeArchitects:
		m.ResetArchitects()
		return nil
	case companyengineer.EdgeControllers:
		m.ResetControllers()
		return nil
	case companyengineer.EdgeMechaniccontrollers:
		m.ResetMechaniccontrollers()
		return nil
	case companyengineer.EdgeElectriccontrollers:
		m.ResetElectriccontrollers()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer edge %s", name)
}

// CompanyTokenMutation represents an operation that mutates the CompanyToken nodes in the graph.
type CompanyTokenMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Token           *string
	_DepartmentId    *int
	add_DepartmentId *int
	_Expire          *int
	add_Expire       *int
	_RefreshToken    *string
	_SecretKey       *string
	_SecureSecretKey *string
	_OtpUri          *string
	createdAt        *time.Time
	updatedAt        *time.Time
	clearedFields    map[string]struct{}
	company          *int
	clearedcompany   bool
	done             bool
	oldValue         func(context.Context) (*CompanyToken, error)
	predicates       []predicate.CompanyToken
}

var _ ent.Mutation = (*CompanyTokenMutation)(nil)

// companytokenOption allows management of the mutation configuration using functional options.
type companytokenOption func(*CompanyTokenMutation)

// newCompanyTokenMutation creates new mutation for the CompanyToken entity.
func newCompanyTokenMutation(c config, op Op, opts ...companytokenOption) *CompanyTokenMutation {
	m := &CompanyTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyTokenID sets the ID field of the mutation.
func withCompanyTokenID(id int) companytokenOption {
	return func(m *CompanyTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyToken
		)
		m.oldValue = func(ctx context.Context) (*CompanyToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyToken sets the old CompanyToken of the mutation.
func withCompanyToken(node *CompanyToken) companytokenOption {
	return func(m *CompanyTokenMutation) {
		m.oldValue = func(context.Context) (*CompanyToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "Token" field.
func (m *CompanyTokenMutation) SetToken(s string) {
	m._Token = &s
}

// Token returns the value of the "Token" field in the mutation.
func (m *CompanyTokenMutation) Token() (r string, exists bool) {
	v := m._Token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "Token" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "Token" field.
func (m *CompanyTokenMutation) ClearToken() {
	m._Token = nil
	m.clearedFields[companytoken.FieldToken] = struct{}{}
}

// TokenCleared returns if the "Token" field was cleared in this mutation.
func (m *CompanyTokenMutation) TokenCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldToken]
	return ok
}

// ResetToken resets all changes to the "Token" field.
func (m *CompanyTokenMutation) ResetToken() {
	m._Token = nil
	delete(m.clearedFields, companytoken.FieldToken)
}

// SetDepartmentId sets the "DepartmentId" field.
func (m *CompanyTokenMutation) SetDepartmentId(i int) {
	m._DepartmentId = &i
	m.add_DepartmentId = nil
}

// DepartmentId returns the value of the "DepartmentId" field in the mutation.
func (m *CompanyTokenMutation) DepartmentId() (r int, exists bool) {
	v := m._DepartmentId
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentId returns the old "DepartmentId" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldDepartmentId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentId: %w", err)
	}
	return oldValue.DepartmentId, nil
}

// AddDepartmentId adds i to the "DepartmentId" field.
func (m *CompanyTokenMutation) AddDepartmentId(i int) {
	if m.add_DepartmentId != nil {
		*m.add_DepartmentId += i
	} else {
		m.add_DepartmentId = &i
	}
}

// AddedDepartmentId returns the value that was added to the "DepartmentId" field in this mutation.
func (m *CompanyTokenMutation) AddedDepartmentId() (r int, exists bool) {
	v := m.add_DepartmentId
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepartmentId clears the value of the "DepartmentId" field.
func (m *CompanyTokenMutation) ClearDepartmentId() {
	m._DepartmentId = nil
	m.add_DepartmentId = nil
	m.clearedFields[companytoken.FieldDepartmentId] = struct{}{}
}

// DepartmentIdCleared returns if the "DepartmentId" field was cleared in this mutation.
func (m *CompanyTokenMutation) DepartmentIdCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldDepartmentId]
	return ok
}

// ResetDepartmentId resets all changes to the "DepartmentId" field.
func (m *CompanyTokenMutation) ResetDepartmentId() {
	m._DepartmentId = nil
	m.add_DepartmentId = nil
	delete(m.clearedFields, companytoken.FieldDepartmentId)
}

// SetExpire sets the "Expire" field.
func (m *CompanyTokenMutation) SetExpire(i int) {
	m._Expire = &i
	m.add_Expire = nil
}

// Expire returns the value of the "Expire" field in the mutation.
func (m *CompanyTokenMutation) Expire() (r int, exists bool) {
	v := m._Expire
	if v == nil {
		return
	}
	return *v, true
}

// OldExpire returns the old "Expire" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldExpire(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpire: %w", err)
	}
	return oldValue.Expire, nil
}

// AddExpire adds i to the "Expire" field.
func (m *CompanyTokenMutation) AddExpire(i int) {
	if m.add_Expire != nil {
		*m.add_Expire += i
	} else {
		m.add_Expire = &i
	}
}

// AddedExpire returns the value that was added to the "Expire" field in this mutation.
func (m *CompanyTokenMutation) AddedExpire() (r int, exists bool) {
	v := m.add_Expire
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpire clears the value of the "Expire" field.
func (m *CompanyTokenMutation) ClearExpire() {
	m._Expire = nil
	m.add_Expire = nil
	m.clearedFields[companytoken.FieldExpire] = struct{}{}
}

// ExpireCleared returns if the "Expire" field was cleared in this mutation.
func (m *CompanyTokenMutation) ExpireCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldExpire]
	return ok
}

// ResetExpire resets all changes to the "Expire" field.
func (m *CompanyTokenMutation) ResetExpire() {
	m._Expire = nil
	m.add_Expire = nil
	delete(m.clearedFields, companytoken.FieldExpire)
}

// SetRefreshToken sets the "RefreshToken" field.
func (m *CompanyTokenMutation) SetRefreshToken(s string) {
	m._RefreshToken = &s
}

// RefreshToken returns the value of the "RefreshToken" field in the mutation.
func (m *CompanyTokenMutation) RefreshToken() (r string, exists bool) {
	v := m._RefreshToken
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "RefreshToken" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "RefreshToken" field.
func (m *CompanyTokenMutation) ClearRefreshToken() {
	m._RefreshToken = nil
	m.clearedFields[companytoken.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "RefreshToken" field was cleared in this mutation.
func (m *CompanyTokenMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "RefreshToken" field.
func (m *CompanyTokenMutation) ResetRefreshToken() {
	m._RefreshToken = nil
	delete(m.clearedFields, companytoken.FieldRefreshToken)
}

// SetSecretKey sets the "SecretKey" field.
func (m *CompanyTokenMutation) SetSecretKey(s string) {
	m._SecretKey = &s
}

// SecretKey returns the value of the "SecretKey" field in the mutation.
func (m *CompanyTokenMutation) SecretKey() (r string, exists bool) {
	v := m._SecretKey
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretKey returns the old "SecretKey" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretKey: %w", err)
	}
	return oldValue.SecretKey, nil
}

// ClearSecretKey clears the value of the "SecretKey" field.
func (m *CompanyTokenMutation) ClearSecretKey() {
	m._SecretKey = nil
	m.clearedFields[companytoken.FieldSecretKey] = struct{}{}
}

// SecretKeyCleared returns if the "SecretKey" field was cleared in this mutation.
func (m *CompanyTokenMutation) SecretKeyCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldSecretKey]
	return ok
}

// ResetSecretKey resets all changes to the "SecretKey" field.
func (m *CompanyTokenMutation) ResetSecretKey() {
	m._SecretKey = nil
	delete(m.clearedFields, companytoken.FieldSecretKey)
}

// SetSecureSecretKey sets the "SecureSecretKey" field.
func (m *CompanyTokenMutation) SetSecureSecretKey(s string) {
	m._SecureSecretKey = &s
}

// SecureSecretKey returns the value of the "SecureSecretKey" field in the mutation.
func (m *CompanyTokenMutation) SecureSecretKey() (r string, exists bool) {
	v := m._SecureSecretKey
	if v == nil {
		return
	}
	return *v, true
}

// OldSecureSecretKey returns the old "SecureSecretKey" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldSecureSecretKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecureSecretKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecureSecretKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecureSecretKey: %w", err)
	}
	return oldValue.SecureSecretKey, nil
}

// ClearSecureSecretKey clears the value of the "SecureSecretKey" field.
func (m *CompanyTokenMutation) ClearSecureSecretKey() {
	m._SecureSecretKey = nil
	m.clearedFields[companytoken.FieldSecureSecretKey] = struct{}{}
}

// SecureSecretKeyCleared returns if the "SecureSecretKey" field was cleared in this mutation.
func (m *CompanyTokenMutation) SecureSecretKeyCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldSecureSecretKey]
	return ok
}

// ResetSecureSecretKey resets all changes to the "SecureSecretKey" field.
func (m *CompanyTokenMutation) ResetSecureSecretKey() {
	m._SecureSecretKey = nil
	delete(m.clearedFields, companytoken.FieldSecureSecretKey)
}

// SetOtpUri sets the "OtpUri" field.
func (m *CompanyTokenMutation) SetOtpUri(s string) {
	m._OtpUri = &s
}

// OtpUri returns the value of the "OtpUri" field in the mutation.
func (m *CompanyTokenMutation) OtpUri() (r string, exists bool) {
	v := m._OtpUri
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpUri returns the old "OtpUri" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldOtpUri(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpUri is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpUri requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpUri: %w", err)
	}
	return oldValue.OtpUri, nil
}

// ClearOtpUri clears the value of the "OtpUri" field.
func (m *CompanyTokenMutation) ClearOtpUri() {
	m._OtpUri = nil
	m.clearedFields[companytoken.FieldOtpUri] = struct{}{}
}

// OtpUriCleared returns if the "OtpUri" field was cleared in this mutation.
func (m *CompanyTokenMutation) OtpUriCleared() bool {
	_, ok := m.clearedFields[companytoken.FieldOtpUri]
	return ok
}

// ResetOtpUri resets all changes to the "OtpUri" field.
func (m *CompanyTokenMutation) ResetOtpUri() {
	m._OtpUri = nil
	delete(m.clearedFields, companytoken.FieldOtpUri)
}

// SetCreatedAt sets the "createdAt" field.
func (m *CompanyTokenMutation) SetCreatedAt(t time.Time) {
	m.createdAt = &t
}

// CreatedAt returns the value of the "createdAt" field in the mutation.
func (m *CompanyTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.createdAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "createdAt" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "createdAt" field.
func (m *CompanyTokenMutation) ResetCreatedAt() {
	m.createdAt = nil
}

// SetUpdatedAt sets the "updatedAt" field.
func (m *CompanyTokenMutation) SetUpdatedAt(t time.Time) {
	m.updatedAt = &t
}

// UpdatedAt returns the value of the "updatedAt" field in the mutation.
func (m *CompanyTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updatedAt" field's value of the CompanyToken entity.
// If the CompanyToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updatedAt" field.
func (m *CompanyTokenMutation) ResetUpdatedAt() {
	m.updatedAt = nil
}

// SetCompanyID sets the "company" edge to the CompanyDetail entity by id.
func (m *CompanyTokenMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the CompanyDetail entity.
func (m *CompanyTokenMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the CompanyDetail entity was cleared.
func (m *CompanyTokenMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyTokenMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyTokenMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyTokenMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the CompanyTokenMutation builder.
func (m *CompanyTokenMutation) Where(ps ...predicate.CompanyToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyToken).
func (m *CompanyTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Token != nil {
		fields = append(fields, companytoken.FieldToken)
	}
	if m._DepartmentId != nil {
		fields = append(fields, companytoken.FieldDepartmentId)
	}
	if m._Expire != nil {
		fields = append(fields, companytoken.FieldExpire)
	}
	if m._RefreshToken != nil {
		fields = append(fields, companytoken.FieldRefreshToken)
	}
	if m._SecretKey != nil {
		fields = append(fields, companytoken.FieldSecretKey)
	}
	if m._SecureSecretKey != nil {
		fields = append(fields, companytoken.FieldSecureSecretKey)
	}
	if m._OtpUri != nil {
		fields = append(fields, companytoken.FieldOtpUri)
	}
	if m.createdAt != nil {
		fields = append(fields, companytoken.FieldCreatedAt)
	}
	if m.updatedAt != nil {
		fields = append(fields, companytoken.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companytoken.FieldToken:
		return m.Token()
	case companytoken.FieldDepartmentId:
		return m.DepartmentId()
	case companytoken.FieldExpire:
		return m.Expire()
	case companytoken.FieldRefreshToken:
		return m.RefreshToken()
	case companytoken.FieldSecretKey:
		return m.SecretKey()
	case companytoken.FieldSecureSecretKey:
		return m.SecureSecretKey()
	case companytoken.FieldOtpUri:
		return m.OtpUri()
	case companytoken.FieldCreatedAt:
		return m.CreatedAt()
	case companytoken.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companytoken.FieldToken:
		return m.OldToken(ctx)
	case companytoken.FieldDepartmentId:
		return m.OldDepartmentId(ctx)
	case companytoken.FieldExpire:
		return m.OldExpire(ctx)
	case companytoken.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case companytoken.FieldSecretKey:
		return m.OldSecretKey(ctx)
	case companytoken.FieldSecureSecretKey:
		return m.OldSecureSecretKey(ctx)
	case companytoken.FieldOtpUri:
		return m.OldOtpUri(ctx)
	case companytoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companytoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companytoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case companytoken.FieldDepartmentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentId(v)
		return nil
	case companytoken.FieldExpire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpire(v)
		return nil
	case companytoken.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case companytoken.FieldSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretKey(v)
		return nil
	case companytoken.FieldSecureSecretKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecureSecretKey(v)
		return nil
	case companytoken.FieldOtpUri:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpUri(v)
		return nil
	case companytoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companytoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyTokenMutation) AddedFields() []string {
	var fields []string
	if m.add_DepartmentId != nil {
		fields = append(fields, companytoken.FieldDepartmentId)
	}
	if m.add_Expire != nil {
		fields = append(fields, companytoken.FieldExpire)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companytoken.FieldDepartmentId:
		return m.AddedDepartmentId()
	case companytoken.FieldExpire:
		return m.AddedExpire()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companytoken.FieldDepartmentId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepartmentId(v)
		return nil
	case companytoken.FieldExpire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpire(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companytoken.FieldToken) {
		fields = append(fields, companytoken.FieldToken)
	}
	if m.FieldCleared(companytoken.FieldDepartmentId) {
		fields = append(fields, companytoken.FieldDepartmentId)
	}
	if m.FieldCleared(companytoken.FieldExpire) {
		fields = append(fields, companytoken.FieldExpire)
	}
	if m.FieldCleared(companytoken.FieldRefreshToken) {
		fields = append(fields, companytoken.FieldRefreshToken)
	}
	if m.FieldCleared(companytoken.FieldSecretKey) {
		fields = append(fields, companytoken.FieldSecretKey)
	}
	if m.FieldCleared(companytoken.FieldSecureSecretKey) {
		fields = append(fields, companytoken.FieldSecureSecretKey)
	}
	if m.FieldCleared(companytoken.FieldOtpUri) {
		fields = append(fields, companytoken.FieldOtpUri)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyTokenMutation) ClearField(name string) error {
	switch name {
	case companytoken.FieldToken:
		m.ClearToken()
		return nil
	case companytoken.FieldDepartmentId:
		m.ClearDepartmentId()
		return nil
	case companytoken.FieldExpire:
		m.ClearExpire()
		return nil
	case companytoken.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case companytoken.FieldSecretKey:
		m.ClearSecretKey()
		return nil
	case companytoken.FieldSecureSecretKey:
		m.ClearSecureSecretKey()
		return nil
	case companytoken.FieldOtpUri:
		m.ClearOtpUri()
		return nil
	}
	return fmt.Errorf("unknown CompanyToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyTokenMutation) ResetField(name string) error {
	switch name {
	case companytoken.FieldToken:
		m.ResetToken()
		return nil
	case companytoken.FieldDepartmentId:
		m.ResetDepartmentId()
		return nil
	case companytoken.FieldExpire:
		m.ResetExpire()
		return nil
	case companytoken.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case companytoken.FieldSecretKey:
		m.ResetSecretKey()
		return nil
	case companytoken.FieldSecureSecretKey:
		m.ResetSecureSecretKey()
		return nil
	case companytoken.FieldOtpUri:
		m.ResetOtpUri()
		return nil
	case companytoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companytoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompanyToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.company != nil {
		edges = append(edges, companytoken.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companytoken.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompany {
		edges = append(edges, companytoken.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case companytoken.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyTokenMutation) ClearEdge(name string) error {
	switch name {
	case companytoken.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyTokenMutation) ResetEdge(name string) error {
	switch name {
	case companytoken.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyToken edge %s", name)
}

// CompanyUserMutation represents an operation that mutates the CompanyUser nodes in the graph.
type CompanyUserMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	company        *int
	clearedcompany bool
	user           *int
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*CompanyUser, error)
	predicates     []predicate.CompanyUser
}

var _ ent.Mutation = (*CompanyUserMutation)(nil)

// companyuserOption allows management of the mutation configuration using functional options.
type companyuserOption func(*CompanyUserMutation)

// newCompanyUserMutation creates new mutation for the CompanyUser entity.
func newCompanyUserMutation(c config, op Op, opts ...companyuserOption) *CompanyUserMutation {
	m := &CompanyUserMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyUserID sets the ID field of the mutation.
func withCompanyUserID(id int) companyuserOption {
	return func(m *CompanyUserMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyUser
		)
		m.oldValue = func(ctx context.Context) (*CompanyUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyUser sets the old CompanyUser of the mutation.
func withCompanyUser(node *CompanyUser) companyuserOption {
	return func(m *CompanyUserMutation) {
		m.oldValue = func(context.Context) (*CompanyUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyUserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyUserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company" edge to the CompanyDetail entity by id.
func (m *CompanyUserMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the CompanyDetail entity.
func (m *CompanyUserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the CompanyDetail entity was cleared.
func (m *CompanyUserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *CompanyUserMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyUserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CompanyUserMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CompanyUserMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CompanyUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CompanyUserMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CompanyUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CompanyUserMutation builder.
func (m *CompanyUserMutation) Where(ps ...predicate.CompanyUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyUser).
func (m *CompanyUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyUserMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyUserMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CompanyUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CompanyUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompanyUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyUserMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, companyuser.EdgeCompany)
	}
	if m.user != nil {
		edges = append(edges, companyuser.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companyuser.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case companyuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, companyuser.EdgeCompany)
	}
	if m.cleareduser {
		edges = append(edges, companyuser.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyUserMutation) EdgeCleared(name string) bool {
	switch name {
	case companyuser.EdgeCompany:
		return m.clearedcompany
	case companyuser.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyUserMutation) ClearEdge(name string) error {
	switch name {
	case companyuser.EdgeCompany:
		m.ClearCompany()
		return nil
	case companyuser.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyUserMutation) ResetEdge(name string) error {
	switch name {
	case companyuser.EdgeCompany:
		m.ResetCompany()
		return nil
	case companyuser.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser edge %s", name)
}

// JobAuthorMutation represents an operation that mutates the JobAuthor nodes in the graph.
type JobAuthorMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_Static                   *string
	_Mechanic                 *string
	_Electric                 *string
	_Architect                *string
	_GeotechnicalEngineer     *string
	_GeotechnicalGeologist    *string
	_GeotechnicalGeophysicist *string
	_CreatedAt                *time.Time
	_UpdatedAt                *time.Time
	clearedFields             map[string]struct{}
	authors                   map[int]struct{}
	removedauthors            map[int]struct{}
	clearedauthors            bool
	done                      bool
	oldValue                  func(context.Context) (*JobAuthor, error)
	predicates                []predicate.JobAuthor
}

var _ ent.Mutation = (*JobAuthorMutation)(nil)

// jobauthorOption allows management of the mutation configuration using functional options.
type jobauthorOption func(*JobAuthorMutation)

// newJobAuthorMutation creates new mutation for the JobAuthor entity.
func newJobAuthorMutation(c config, op Op, opts ...jobauthorOption) *JobAuthorMutation {
	m := &JobAuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeJobAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobAuthorID sets the ID field of the mutation.
func withJobAuthorID(id int) jobauthorOption {
	return func(m *JobAuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *JobAuthor
		)
		m.oldValue = func(ctx context.Context) (*JobAuthor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobAuthor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobAuthor sets the old JobAuthor of the mutation.
func withJobAuthor(node *JobAuthor) jobauthorOption {
	return func(m *JobAuthorMutation) {
		m.oldValue = func(context.Context) (*JobAuthor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobAuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobAuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobAuthorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobAuthorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobAuthor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatic sets the "Static" field.
func (m *JobAuthorMutation) SetStatic(s string) {
	m._Static = &s
}

// Static returns the value of the "Static" field in the mutation.
func (m *JobAuthorMutation) Static() (r string, exists bool) {
	v := m._Static
	if v == nil {
		return
	}
	return *v, true
}

// OldStatic returns the old "Static" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldStatic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatic: %w", err)
	}
	return oldValue.Static, nil
}

// ClearStatic clears the value of the "Static" field.
func (m *JobAuthorMutation) ClearStatic() {
	m._Static = nil
	m.clearedFields[jobauthor.FieldStatic] = struct{}{}
}

// StaticCleared returns if the "Static" field was cleared in this mutation.
func (m *JobAuthorMutation) StaticCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldStatic]
	return ok
}

// ResetStatic resets all changes to the "Static" field.
func (m *JobAuthorMutation) ResetStatic() {
	m._Static = nil
	delete(m.clearedFields, jobauthor.FieldStatic)
}

// SetMechanic sets the "Mechanic" field.
func (m *JobAuthorMutation) SetMechanic(s string) {
	m._Mechanic = &s
}

// Mechanic returns the value of the "Mechanic" field in the mutation.
func (m *JobAuthorMutation) Mechanic() (r string, exists bool) {
	v := m._Mechanic
	if v == nil {
		return
	}
	return *v, true
}

// OldMechanic returns the old "Mechanic" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldMechanic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMechanic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMechanic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMechanic: %w", err)
	}
	return oldValue.Mechanic, nil
}

// ClearMechanic clears the value of the "Mechanic" field.
func (m *JobAuthorMutation) ClearMechanic() {
	m._Mechanic = nil
	m.clearedFields[jobauthor.FieldMechanic] = struct{}{}
}

// MechanicCleared returns if the "Mechanic" field was cleared in this mutation.
func (m *JobAuthorMutation) MechanicCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldMechanic]
	return ok
}

// ResetMechanic resets all changes to the "Mechanic" field.
func (m *JobAuthorMutation) ResetMechanic() {
	m._Mechanic = nil
	delete(m.clearedFields, jobauthor.FieldMechanic)
}

// SetElectric sets the "Electric" field.
func (m *JobAuthorMutation) SetElectric(s string) {
	m._Electric = &s
}

// Electric returns the value of the "Electric" field in the mutation.
func (m *JobAuthorMutation) Electric() (r string, exists bool) {
	v := m._Electric
	if v == nil {
		return
	}
	return *v, true
}

// OldElectric returns the old "Electric" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldElectric(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectric: %w", err)
	}
	return oldValue.Electric, nil
}

// ClearElectric clears the value of the "Electric" field.
func (m *JobAuthorMutation) ClearElectric() {
	m._Electric = nil
	m.clearedFields[jobauthor.FieldElectric] = struct{}{}
}

// ElectricCleared returns if the "Electric" field was cleared in this mutation.
func (m *JobAuthorMutation) ElectricCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldElectric]
	return ok
}

// ResetElectric resets all changes to the "Electric" field.
func (m *JobAuthorMutation) ResetElectric() {
	m._Electric = nil
	delete(m.clearedFields, jobauthor.FieldElectric)
}

// SetArchitect sets the "Architect" field.
func (m *JobAuthorMutation) SetArchitect(s string) {
	m._Architect = &s
}

// Architect returns the value of the "Architect" field in the mutation.
func (m *JobAuthorMutation) Architect() (r string, exists bool) {
	v := m._Architect
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitect returns the old "Architect" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldArchitect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitect: %w", err)
	}
	return oldValue.Architect, nil
}

// ClearArchitect clears the value of the "Architect" field.
func (m *JobAuthorMutation) ClearArchitect() {
	m._Architect = nil
	m.clearedFields[jobauthor.FieldArchitect] = struct{}{}
}

// ArchitectCleared returns if the "Architect" field was cleared in this mutation.
func (m *JobAuthorMutation) ArchitectCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldArchitect]
	return ok
}

// ResetArchitect resets all changes to the "Architect" field.
func (m *JobAuthorMutation) ResetArchitect() {
	m._Architect = nil
	delete(m.clearedFields, jobauthor.FieldArchitect)
}

// SetGeotechnicalEngineer sets the "GeotechnicalEngineer" field.
func (m *JobAuthorMutation) SetGeotechnicalEngineer(s string) {
	m._GeotechnicalEngineer = &s
}

// GeotechnicalEngineer returns the value of the "GeotechnicalEngineer" field in the mutation.
func (m *JobAuthorMutation) GeotechnicalEngineer() (r string, exists bool) {
	v := m._GeotechnicalEngineer
	if v == nil {
		return
	}
	return *v, true
}

// OldGeotechnicalEngineer returns the old "GeotechnicalEngineer" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldGeotechnicalEngineer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeotechnicalEngineer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeotechnicalEngineer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeotechnicalEngineer: %w", err)
	}
	return oldValue.GeotechnicalEngineer, nil
}

// ClearGeotechnicalEngineer clears the value of the "GeotechnicalEngineer" field.
func (m *JobAuthorMutation) ClearGeotechnicalEngineer() {
	m._GeotechnicalEngineer = nil
	m.clearedFields[jobauthor.FieldGeotechnicalEngineer] = struct{}{}
}

// GeotechnicalEngineerCleared returns if the "GeotechnicalEngineer" field was cleared in this mutation.
func (m *JobAuthorMutation) GeotechnicalEngineerCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldGeotechnicalEngineer]
	return ok
}

// ResetGeotechnicalEngineer resets all changes to the "GeotechnicalEngineer" field.
func (m *JobAuthorMutation) ResetGeotechnicalEngineer() {
	m._GeotechnicalEngineer = nil
	delete(m.clearedFields, jobauthor.FieldGeotechnicalEngineer)
}

// SetGeotechnicalGeologist sets the "GeotechnicalGeologist" field.
func (m *JobAuthorMutation) SetGeotechnicalGeologist(s string) {
	m._GeotechnicalGeologist = &s
}

// GeotechnicalGeologist returns the value of the "GeotechnicalGeologist" field in the mutation.
func (m *JobAuthorMutation) GeotechnicalGeologist() (r string, exists bool) {
	v := m._GeotechnicalGeologist
	if v == nil {
		return
	}
	return *v, true
}

// OldGeotechnicalGeologist returns the old "GeotechnicalGeologist" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldGeotechnicalGeologist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeotechnicalGeologist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeotechnicalGeologist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeotechnicalGeologist: %w", err)
	}
	return oldValue.GeotechnicalGeologist, nil
}

// ClearGeotechnicalGeologist clears the value of the "GeotechnicalGeologist" field.
func (m *JobAuthorMutation) ClearGeotechnicalGeologist() {
	m._GeotechnicalGeologist = nil
	m.clearedFields[jobauthor.FieldGeotechnicalGeologist] = struct{}{}
}

// GeotechnicalGeologistCleared returns if the "GeotechnicalGeologist" field was cleared in this mutation.
func (m *JobAuthorMutation) GeotechnicalGeologistCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldGeotechnicalGeologist]
	return ok
}

// ResetGeotechnicalGeologist resets all changes to the "GeotechnicalGeologist" field.
func (m *JobAuthorMutation) ResetGeotechnicalGeologist() {
	m._GeotechnicalGeologist = nil
	delete(m.clearedFields, jobauthor.FieldGeotechnicalGeologist)
}

// SetGeotechnicalGeophysicist sets the "GeotechnicalGeophysicist" field.
func (m *JobAuthorMutation) SetGeotechnicalGeophysicist(s string) {
	m._GeotechnicalGeophysicist = &s
}

// GeotechnicalGeophysicist returns the value of the "GeotechnicalGeophysicist" field in the mutation.
func (m *JobAuthorMutation) GeotechnicalGeophysicist() (r string, exists bool) {
	v := m._GeotechnicalGeophysicist
	if v == nil {
		return
	}
	return *v, true
}

// OldGeotechnicalGeophysicist returns the old "GeotechnicalGeophysicist" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldGeotechnicalGeophysicist(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeotechnicalGeophysicist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeotechnicalGeophysicist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeotechnicalGeophysicist: %w", err)
	}
	return oldValue.GeotechnicalGeophysicist, nil
}

// ClearGeotechnicalGeophysicist clears the value of the "GeotechnicalGeophysicist" field.
func (m *JobAuthorMutation) ClearGeotechnicalGeophysicist() {
	m._GeotechnicalGeophysicist = nil
	m.clearedFields[jobauthor.FieldGeotechnicalGeophysicist] = struct{}{}
}

// GeotechnicalGeophysicistCleared returns if the "GeotechnicalGeophysicist" field was cleared in this mutation.
func (m *JobAuthorMutation) GeotechnicalGeophysicistCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldGeotechnicalGeophysicist]
	return ok
}

// ResetGeotechnicalGeophysicist resets all changes to the "GeotechnicalGeophysicist" field.
func (m *JobAuthorMutation) ResetGeotechnicalGeophysicist() {
	m._GeotechnicalGeophysicist = nil
	delete(m.clearedFields, jobauthor.FieldGeotechnicalGeophysicist)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobAuthorMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobAuthorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobAuthorMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobAuthorMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobAuthorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobAuthorMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddAuthorIDs adds the "authors" edge to the JobDetail entity by ids.
func (m *JobAuthorMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the JobDetail entity.
func (m *JobAuthorMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the JobDetail entity was cleared.
func (m *JobAuthorMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the JobDetail entity by IDs.
func (m *JobAuthorMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the JobDetail entity.
func (m *JobAuthorMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *JobAuthorMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *JobAuthorMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the JobAuthorMutation builder.
func (m *JobAuthorMutation) Where(ps ...predicate.JobAuthor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobAuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobAuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobAuthor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobAuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobAuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobAuthor).
func (m *JobAuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobAuthorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Static != nil {
		fields = append(fields, jobauthor.FieldStatic)
	}
	if m._Mechanic != nil {
		fields = append(fields, jobauthor.FieldMechanic)
	}
	if m._Electric != nil {
		fields = append(fields, jobauthor.FieldElectric)
	}
	if m._Architect != nil {
		fields = append(fields, jobauthor.FieldArchitect)
	}
	if m._GeotechnicalEngineer != nil {
		fields = append(fields, jobauthor.FieldGeotechnicalEngineer)
	}
	if m._GeotechnicalGeologist != nil {
		fields = append(fields, jobauthor.FieldGeotechnicalGeologist)
	}
	if m._GeotechnicalGeophysicist != nil {
		fields = append(fields, jobauthor.FieldGeotechnicalGeophysicist)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobauthor.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobauthor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobAuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobauthor.FieldStatic:
		return m.Static()
	case jobauthor.FieldMechanic:
		return m.Mechanic()
	case jobauthor.FieldElectric:
		return m.Electric()
	case jobauthor.FieldArchitect:
		return m.Architect()
	case jobauthor.FieldGeotechnicalEngineer:
		return m.GeotechnicalEngineer()
	case jobauthor.FieldGeotechnicalGeologist:
		return m.GeotechnicalGeologist()
	case jobauthor.FieldGeotechnicalGeophysicist:
		return m.GeotechnicalGeophysicist()
	case jobauthor.FieldCreatedAt:
		return m.CreatedAt()
	case jobauthor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobAuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobauthor.FieldStatic:
		return m.OldStatic(ctx)
	case jobauthor.FieldMechanic:
		return m.OldMechanic(ctx)
	case jobauthor.FieldElectric:
		return m.OldElectric(ctx)
	case jobauthor.FieldArchitect:
		return m.OldArchitect(ctx)
	case jobauthor.FieldGeotechnicalEngineer:
		return m.OldGeotechnicalEngineer(ctx)
	case jobauthor.FieldGeotechnicalGeologist:
		return m.OldGeotechnicalGeologist(ctx)
	case jobauthor.FieldGeotechnicalGeophysicist:
		return m.OldGeotechnicalGeophysicist(ctx)
	case jobauthor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobauthor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobAuthor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobauthor.FieldStatic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatic(v)
		return nil
	case jobauthor.FieldMechanic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMechanic(v)
		return nil
	case jobauthor.FieldElectric:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectric(v)
		return nil
	case jobauthor.FieldArchitect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitect(v)
		return nil
	case jobauthor.FieldGeotechnicalEngineer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeotechnicalEngineer(v)
		return nil
	case jobauthor.FieldGeotechnicalGeologist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeotechnicalGeologist(v)
		return nil
	case jobauthor.FieldGeotechnicalGeophysicist:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeotechnicalGeophysicist(v)
		return nil
	case jobauthor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobauthor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobAuthor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobAuthorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobAuthorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobAuthor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobAuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobauthor.FieldStatic) {
		fields = append(fields, jobauthor.FieldStatic)
	}
	if m.FieldCleared(jobauthor.FieldMechanic) {
		fields = append(fields, jobauthor.FieldMechanic)
	}
	if m.FieldCleared(jobauthor.FieldElectric) {
		fields = append(fields, jobauthor.FieldElectric)
	}
	if m.FieldCleared(jobauthor.FieldArchitect) {
		fields = append(fields, jobauthor.FieldArchitect)
	}
	if m.FieldCleared(jobauthor.FieldGeotechnicalEngineer) {
		fields = append(fields, jobauthor.FieldGeotechnicalEngineer)
	}
	if m.FieldCleared(jobauthor.FieldGeotechnicalGeologist) {
		fields = append(fields, jobauthor.FieldGeotechnicalGeologist)
	}
	if m.FieldCleared(jobauthor.FieldGeotechnicalGeophysicist) {
		fields = append(fields, jobauthor.FieldGeotechnicalGeophysicist)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobAuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobAuthorMutation) ClearField(name string) error {
	switch name {
	case jobauthor.FieldStatic:
		m.ClearStatic()
		return nil
	case jobauthor.FieldMechanic:
		m.ClearMechanic()
		return nil
	case jobauthor.FieldElectric:
		m.ClearElectric()
		return nil
	case jobauthor.FieldArchitect:
		m.ClearArchitect()
		return nil
	case jobauthor.FieldGeotechnicalEngineer:
		m.ClearGeotechnicalEngineer()
		return nil
	case jobauthor.FieldGeotechnicalGeologist:
		m.ClearGeotechnicalGeologist()
		return nil
	case jobauthor.FieldGeotechnicalGeophysicist:
		m.ClearGeotechnicalGeophysicist()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobAuthorMutation) ResetField(name string) error {
	switch name {
	case jobauthor.FieldStatic:
		m.ResetStatic()
		return nil
	case jobauthor.FieldMechanic:
		m.ResetMechanic()
		return nil
	case jobauthor.FieldElectric:
		m.ResetElectric()
		return nil
	case jobauthor.FieldArchitect:
		m.ResetArchitect()
		return nil
	case jobauthor.FieldGeotechnicalEngineer:
		m.ResetGeotechnicalEngineer()
		return nil
	case jobauthor.FieldGeotechnicalGeologist:
		m.ResetGeotechnicalGeologist()
		return nil
	case jobauthor.FieldGeotechnicalGeophysicist:
		m.ResetGeotechnicalGeophysicist()
		return nil
	case jobauthor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobauthor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobAuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.authors != nil {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobAuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobauthor.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobAuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedauthors != nil {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobAuthorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobauthor.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobAuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthors {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobAuthorMutation) EdgeCleared(name string) bool {
	switch name {
	case jobauthor.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobAuthorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobAuthor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobAuthorMutation) ResetEdge(name string) error {
	switch name {
	case jobauthor.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor edge %s", name)
}

// JobContractorMutation represents an operation that mutates the JobContractor nodes in the graph.
type JobContractorMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Name              *string
	_TcNo              *int
	add_TcNo           *int
	_RegisterNo        *int
	add_RegisterNo     *int
	_Address           *string
	_TaxNo             *int
	add_TaxNo          *int
	_MobilePhone       *string
	_Phone             *string
	_Email             *string
	_PersonType        *string
	_YDSID             *int
	add_YDSID          *int
	_Note              *string
	_CreatedAt         *time.Time
	_UpdatedAt         *time.Time
	clearedFields      map[string]struct{}
	contractors        map[int]struct{}
	removedcontractors map[int]struct{}
	clearedcontractors bool
	done               bool
	oldValue           func(context.Context) (*JobContractor, error)
	predicates         []predicate.JobContractor
}

var _ ent.Mutation = (*JobContractorMutation)(nil)

// jobcontractorOption allows management of the mutation configuration using functional options.
type jobcontractorOption func(*JobContractorMutation)

// newJobContractorMutation creates new mutation for the JobContractor entity.
func newJobContractorMutation(c config, op Op, opts ...jobcontractorOption) *JobContractorMutation {
	m := &JobContractorMutation{
		config:        c,
		op:            op,
		typ:           TypeJobContractor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobContractorID sets the ID field of the mutation.
func withJobContractorID(id int) jobcontractorOption {
	return func(m *JobContractorMutation) {
		var (
			err   error
			once  sync.Once
			value *JobContractor
		)
		m.oldValue = func(ctx context.Context) (*JobContractor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobContractor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobContractor sets the old JobContractor of the mutation.
func withJobContractor(node *JobContractor) jobcontractorOption {
	return func(m *JobContractorMutation) {
		m.oldValue = func(context.Context) (*JobContractor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobContractorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobContractorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobContractorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobContractorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobContractor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobContractorMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobContractorMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobContractorMutation) ResetName() {
	m._Name = nil
}

// SetTcNo sets the "TcNo" field.
func (m *JobContractorMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *JobContractorMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *JobContractorMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *JobContractorMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *JobContractorMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[jobcontractor.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *JobContractorMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *JobContractorMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, jobcontractor.FieldTcNo)
}

// SetRegisterNo sets the "RegisterNo" field.
func (m *JobContractorMutation) SetRegisterNo(i int) {
	m._RegisterNo = &i
	m.add_RegisterNo = nil
}

// RegisterNo returns the value of the "RegisterNo" field in the mutation.
func (m *JobContractorMutation) RegisterNo() (r int, exists bool) {
	v := m._RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterNo returns the old "RegisterNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldRegisterNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterNo: %w", err)
	}
	return oldValue.RegisterNo, nil
}

// AddRegisterNo adds i to the "RegisterNo" field.
func (m *JobContractorMutation) AddRegisterNo(i int) {
	if m.add_RegisterNo != nil {
		*m.add_RegisterNo += i
	} else {
		m.add_RegisterNo = &i
	}
}

// AddedRegisterNo returns the value that was added to the "RegisterNo" field in this mutation.
func (m *JobContractorMutation) AddedRegisterNo() (r int, exists bool) {
	v := m.add_RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegisterNo clears the value of the "RegisterNo" field.
func (m *JobContractorMutation) ClearRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	m.clearedFields[jobcontractor.FieldRegisterNo] = struct{}{}
}

// RegisterNoCleared returns if the "RegisterNo" field was cleared in this mutation.
func (m *JobContractorMutation) RegisterNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldRegisterNo]
	return ok
}

// ResetRegisterNo resets all changes to the "RegisterNo" field.
func (m *JobContractorMutation) ResetRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	delete(m.clearedFields, jobcontractor.FieldRegisterNo)
}

// SetAddress sets the "Address" field.
func (m *JobContractorMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobContractorMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobContractorMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobcontractor.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobContractorMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobContractorMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobcontractor.FieldAddress)
}

// SetTaxNo sets the "TaxNo" field.
func (m *JobContractorMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *JobContractorMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *JobContractorMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *JobContractorMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *JobContractorMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[jobcontractor.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *JobContractorMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *JobContractorMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, jobcontractor.FieldTaxNo)
}

// SetMobilePhone sets the "MobilePhone" field.
func (m *JobContractorMutation) SetMobilePhone(s string) {
	m._MobilePhone = &s
}

// MobilePhone returns the value of the "MobilePhone" field in the mutation.
func (m *JobContractorMutation) MobilePhone() (r string, exists bool) {
	v := m._MobilePhone
	if v == nil {
		return
	}
	return *v, true
}

// OldMobilePhone returns the old "MobilePhone" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldMobilePhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobilePhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobilePhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobilePhone: %w", err)
	}
	return oldValue.MobilePhone, nil
}

// ClearMobilePhone clears the value of the "MobilePhone" field.
func (m *JobContractorMutation) ClearMobilePhone() {
	m._MobilePhone = nil
	m.clearedFields[jobcontractor.FieldMobilePhone] = struct{}{}
}

// MobilePhoneCleared returns if the "MobilePhone" field was cleared in this mutation.
func (m *JobContractorMutation) MobilePhoneCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldMobilePhone]
	return ok
}

// ResetMobilePhone resets all changes to the "MobilePhone" field.
func (m *JobContractorMutation) ResetMobilePhone() {
	m._MobilePhone = nil
	delete(m.clearedFields, jobcontractor.FieldMobilePhone)
}

// SetPhone sets the "Phone" field.
func (m *JobContractorMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *JobContractorMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *JobContractorMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[jobcontractor.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *JobContractorMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *JobContractorMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, jobcontractor.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *JobContractorMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *JobContractorMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *JobContractorMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[jobcontractor.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *JobContractorMutation) EmailCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *JobContractorMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, jobcontractor.FieldEmail)
}

// SetPersonType sets the "PersonType" field.
func (m *JobContractorMutation) SetPersonType(s string) {
	m._PersonType = &s
}

// PersonType returns the value of the "PersonType" field in the mutation.
func (m *JobContractorMutation) PersonType() (r string, exists bool) {
	v := m._PersonType
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonType returns the old "PersonType" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldPersonType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonType: %w", err)
	}
	return oldValue.PersonType, nil
}

// ClearPersonType clears the value of the "PersonType" field.
func (m *JobContractorMutation) ClearPersonType() {
	m._PersonType = nil
	m.clearedFields[jobcontractor.FieldPersonType] = struct{}{}
}

// PersonTypeCleared returns if the "PersonType" field was cleared in this mutation.
func (m *JobContractorMutation) PersonTypeCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldPersonType]
	return ok
}

// ResetPersonType resets all changes to the "PersonType" field.
func (m *JobContractorMutation) ResetPersonType() {
	m._PersonType = nil
	delete(m.clearedFields, jobcontractor.FieldPersonType)
}

// SetYDSID sets the "YDSID" field.
func (m *JobContractorMutation) SetYDSID(i int) {
	m._YDSID = &i
	m.add_YDSID = nil
}

// YDSID returns the value of the "YDSID" field in the mutation.
func (m *JobContractorMutation) YDSID() (r int, exists bool) {
	v := m._YDSID
	if v == nil {
		return
	}
	return *v, true
}

// OldYDSID returns the old "YDSID" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldYDSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYDSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYDSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYDSID: %w", err)
	}
	return oldValue.YDSID, nil
}

// AddYDSID adds i to the "YDSID" field.
func (m *JobContractorMutation) AddYDSID(i int) {
	if m.add_YDSID != nil {
		*m.add_YDSID += i
	} else {
		m.add_YDSID = &i
	}
}

// AddedYDSID returns the value that was added to the "YDSID" field in this mutation.
func (m *JobContractorMutation) AddedYDSID() (r int, exists bool) {
	v := m.add_YDSID
	if v == nil {
		return
	}
	return *v, true
}

// ClearYDSID clears the value of the "YDSID" field.
func (m *JobContractorMutation) ClearYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	m.clearedFields[jobcontractor.FieldYDSID] = struct{}{}
}

// YDSIDCleared returns if the "YDSID" field was cleared in this mutation.
func (m *JobContractorMutation) YDSIDCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldYDSID]
	return ok
}

// ResetYDSID resets all changes to the "YDSID" field.
func (m *JobContractorMutation) ResetYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	delete(m.clearedFields, jobcontractor.FieldYDSID)
}

// SetNote sets the "Note" field.
func (m *JobContractorMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobContractorMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobContractorMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobcontractor.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobContractorMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobContractorMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobcontractor.FieldNote)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobContractorMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobContractorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobContractorMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobContractorMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobContractorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobContractorMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddContractorIDs adds the "contractors" edge to the JobDetail entity by ids.
func (m *JobContractorMutation) AddContractorIDs(ids ...int) {
	if m.contractors == nil {
		m.contractors = make(map[int]struct{})
	}
	for i := range ids {
		m.contractors[ids[i]] = struct{}{}
	}
}

// ClearContractors clears the "contractors" edge to the JobDetail entity.
func (m *JobContractorMutation) ClearContractors() {
	m.clearedcontractors = true
}

// ContractorsCleared reports if the "contractors" edge to the JobDetail entity was cleared.
func (m *JobContractorMutation) ContractorsCleared() bool {
	return m.clearedcontractors
}

// RemoveContractorIDs removes the "contractors" edge to the JobDetail entity by IDs.
func (m *JobContractorMutation) RemoveContractorIDs(ids ...int) {
	if m.removedcontractors == nil {
		m.removedcontractors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contractors, ids[i])
		m.removedcontractors[ids[i]] = struct{}{}
	}
}

// RemovedContractors returns the removed IDs of the "contractors" edge to the JobDetail entity.
func (m *JobContractorMutation) RemovedContractorsIDs() (ids []int) {
	for id := range m.removedcontractors {
		ids = append(ids, id)
	}
	return
}

// ContractorsIDs returns the "contractors" edge IDs in the mutation.
func (m *JobContractorMutation) ContractorsIDs() (ids []int) {
	for id := range m.contractors {
		ids = append(ids, id)
	}
	return
}

// ResetContractors resets all changes to the "contractors" edge.
func (m *JobContractorMutation) ResetContractors() {
	m.contractors = nil
	m.clearedcontractors = false
	m.removedcontractors = nil
}

// Where appends a list predicates to the JobContractorMutation builder.
func (m *JobContractorMutation) Where(ps ...predicate.JobContractor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobContractorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobContractorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobContractor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobContractorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobContractorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobContractor).
func (m *JobContractorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobContractorMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._Name != nil {
		fields = append(fields, jobcontractor.FieldName)
	}
	if m._TcNo != nil {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m._RegisterNo != nil {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m._Address != nil {
		fields = append(fields, jobcontractor.FieldAddress)
	}
	if m._TaxNo != nil {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	if m._MobilePhone != nil {
		fields = append(fields, jobcontractor.FieldMobilePhone)
	}
	if m._Phone != nil {
		fields = append(fields, jobcontractor.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, jobcontractor.FieldEmail)
	}
	if m._PersonType != nil {
		fields = append(fields, jobcontractor.FieldPersonType)
	}
	if m._YDSID != nil {
		fields = append(fields, jobcontractor.FieldYDSID)
	}
	if m._Note != nil {
		fields = append(fields, jobcontractor.FieldNote)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobcontractor.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobcontractor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobContractorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobcontractor.FieldName:
		return m.Name()
	case jobcontractor.FieldTcNo:
		return m.TcNo()
	case jobcontractor.FieldRegisterNo:
		return m.RegisterNo()
	case jobcontractor.FieldAddress:
		return m.Address()
	case jobcontractor.FieldTaxNo:
		return m.TaxNo()
	case jobcontractor.FieldMobilePhone:
		return m.MobilePhone()
	case jobcontractor.FieldPhone:
		return m.Phone()
	case jobcontractor.FieldEmail:
		return m.Email()
	case jobcontractor.FieldPersonType:
		return m.PersonType()
	case jobcontractor.FieldYDSID:
		return m.YDSID()
	case jobcontractor.FieldNote:
		return m.Note()
	case jobcontractor.FieldCreatedAt:
		return m.CreatedAt()
	case jobcontractor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobContractorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobcontractor.FieldName:
		return m.OldName(ctx)
	case jobcontractor.FieldTcNo:
		return m.OldTcNo(ctx)
	case jobcontractor.FieldRegisterNo:
		return m.OldRegisterNo(ctx)
	case jobcontractor.FieldAddress:
		return m.OldAddress(ctx)
	case jobcontractor.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case jobcontractor.FieldMobilePhone:
		return m.OldMobilePhone(ctx)
	case jobcontractor.FieldPhone:
		return m.OldPhone(ctx)
	case jobcontractor.FieldEmail:
		return m.OldEmail(ctx)
	case jobcontractor.FieldPersonType:
		return m.OldPersonType(ctx)
	case jobcontractor.FieldYDSID:
		return m.OldYDSID(ctx)
	case jobcontractor.FieldNote:
		return m.OldNote(ctx)
	case jobcontractor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobcontractor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobContractor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobContractorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobcontractor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobcontractor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case jobcontractor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterNo(v)
		return nil
	case jobcontractor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobcontractor.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case jobcontractor.FieldMobilePhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobilePhone(v)
		return nil
	case jobcontractor.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case jobcontractor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case jobcontractor.FieldPersonType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonType(v)
		return nil
	case jobcontractor.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYDSID(v)
		return nil
	case jobcontractor.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobcontractor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobcontractor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobContractor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobContractorMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m.add_RegisterNo != nil {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	if m.add_YDSID != nil {
		fields = append(fields, jobcontractor.FieldYDSID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobContractorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobcontractor.FieldTcNo:
		return m.AddedTcNo()
	case jobcontractor.FieldRegisterNo:
		return m.AddedRegisterNo()
	case jobcontractor.FieldTaxNo:
		return m.AddedTaxNo()
	case jobcontractor.FieldYDSID:
		return m.AddedYDSID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobContractorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobcontractor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case jobcontractor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterNo(v)
		return nil
	case jobcontractor.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	case jobcontractor.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYDSID(v)
		return nil
	}
	return fmt.Errorf("unknown JobContractor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobContractorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobcontractor.FieldTcNo) {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m.FieldCleared(jobcontractor.FieldRegisterNo) {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m.FieldCleared(jobcontractor.FieldAddress) {
		fields = append(fields, jobcontractor.FieldAddress)
	}
	if m.FieldCleared(jobcontractor.FieldTaxNo) {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	if m.FieldCleared(jobcontractor.FieldMobilePhone) {
		fields = append(fields, jobcontractor.FieldMobilePhone)
	}
	if m.FieldCleared(jobcontractor.FieldPhone) {
		fields = append(fields, jobcontractor.FieldPhone)
	}
	if m.FieldCleared(jobcontractor.FieldEmail) {
		fields = append(fields, jobcontractor.FieldEmail)
	}
	if m.FieldCleared(jobcontractor.FieldPersonType) {
		fields = append(fields, jobcontractor.FieldPersonType)
	}
	if m.FieldCleared(jobcontractor.FieldYDSID) {
		fields = append(fields, jobcontractor.FieldYDSID)
	}
	if m.FieldCleared(jobcontractor.FieldNote) {
		fields = append(fields, jobcontractor.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobContractorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobContractorMutation) ClearField(name string) error {
	switch name {
	case jobcontractor.FieldTcNo:
		m.ClearTcNo()
		return nil
	case jobcontractor.FieldRegisterNo:
		m.ClearRegisterNo()
		return nil
	case jobcontractor.FieldAddress:
		m.ClearAddress()
		return nil
	case jobcontractor.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case jobcontractor.FieldMobilePhone:
		m.ClearMobilePhone()
		return nil
	case jobcontractor.FieldPhone:
		m.ClearPhone()
		return nil
	case jobcontractor.FieldEmail:
		m.ClearEmail()
		return nil
	case jobcontractor.FieldPersonType:
		m.ClearPersonType()
		return nil
	case jobcontractor.FieldYDSID:
		m.ClearYDSID()
		return nil
	case jobcontractor.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobContractor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobContractorMutation) ResetField(name string) error {
	switch name {
	case jobcontractor.FieldName:
		m.ResetName()
		return nil
	case jobcontractor.FieldTcNo:
		m.ResetTcNo()
		return nil
	case jobcontractor.FieldRegisterNo:
		m.ResetRegisterNo()
		return nil
	case jobcontractor.FieldAddress:
		m.ResetAddress()
		return nil
	case jobcontractor.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case jobcontractor.FieldMobilePhone:
		m.ResetMobilePhone()
		return nil
	case jobcontractor.FieldPhone:
		m.ResetPhone()
		return nil
	case jobcontractor.FieldEmail:
		m.ResetEmail()
		return nil
	case jobcontractor.FieldPersonType:
		m.ResetPersonType()
		return nil
	case jobcontractor.FieldYDSID:
		m.ResetYDSID()
		return nil
	case jobcontractor.FieldNote:
		m.ResetNote()
		return nil
	case jobcontractor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobcontractor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobContractor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobContractorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contractors != nil {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobContractorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobcontractor.EdgeContractors:
		ids := make([]ent.Value, 0, len(m.contractors))
		for id := range m.contractors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobContractorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcontractors != nil {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobContractorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobcontractor.EdgeContractors:
		ids := make([]ent.Value, 0, len(m.removedcontractors))
		for id := range m.removedcontractors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobContractorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontractors {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobContractorMutation) EdgeCleared(name string) bool {
	switch name {
	case jobcontractor.EdgeContractors:
		return m.clearedcontractors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobContractorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobContractor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobContractorMutation) ResetEdge(name string) error {
	switch name {
	case jobcontractor.EdgeContractors:
		m.ResetContractors()
		return nil
	}
	return fmt.Errorf("unknown JobContractor edge %s", name)
}

// JobDetailMutation represents an operation that mutates the JobDetail nodes in the graph.
type JobDetailMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_YibfNo                   *int
	add_YibfNo                *int
	_Title                    *string
	_Administration           *string
	_State                    *string
	_Island                   *string
	_Parcel                   *string
	_Sheet                    *string
	_ContractDate             *time.Time
	_StartDate                *time.Time
	_LicenseDate              *time.Time
	_LicenseNo                *string
	_DistributionDate         *time.Time
	_CompletionDate           *time.Time
	_LandArea                 *float64
	add_LandArea              *float64
	_TotalArea                *float64
	add_TotalArea             *float64
	_ConstructionArea         *float64
	add_ConstructionArea      *float64
	_LeftArea                 *float64
	add_LeftArea              *float64
	_YDSAddress               *string
	_Address                  *string
	_BuildingClass            *string
	_BuildingType             *string
	_Level                    *float64
	add_Level                 *float64
	_UnitPrice                *float64
	add_UnitPrice             *float64
	_FloorCount               *int
	add_FloorCount            *int
	_BKSReferenceNo           *int
	add_BKSReferenceNo        *int
	_Coordinates              *string
	_FolderNo                 *string
	_UploadedFile             *bool
	_IndustryArea             *bool
	_ClusterStructure         *bool
	_IsLicenseExpired         *bool
	_IsCompleted              *bool
	_Note                     *string
	_CreatedAt                *time.Time
	_UpdatedAt                *time.Time
	clearedFields             map[string]struct{}
	owner                     *int
	clearedowner              bool
	author                    *int
	clearedauthor             bool
	company                   *int
	clearedcompany            bool
	progress                  *int
	clearedprogress           bool
	contractor                *int
	clearedcontractor         bool
	supervisor                *int
	clearedsupervisor         bool
	static                    *int
	clearedstatic             bool
	mechanic                  *int
	clearedmechanic           bool
	electric                  *int
	clearedelectric           bool
	inspector                 *int
	clearedinspector          bool
	architect                 *int
	clearedarchitect          bool
	controller                *int
	clearedcontroller         bool
	mechaniccontroller        *int
	clearedmechaniccontroller bool
	electriccontroller        *int
	clearedelectriccontroller bool
	layers                    map[int]struct{}
	removedlayers             map[int]struct{}
	clearedlayers             bool
	payments                  map[int]struct{}
	removedpayments           map[int]struct{}
	clearedpayments           bool
	done                      bool
	oldValue                  func(context.Context) (*JobDetail, error)
	predicates                []predicate.JobDetail
}

var _ ent.Mutation = (*JobDetailMutation)(nil)

// jobdetailOption allows management of the mutation configuration using functional options.
type jobdetailOption func(*JobDetailMutation)

// newJobDetailMutation creates new mutation for the JobDetail entity.
func newJobDetailMutation(c config, op Op, opts ...jobdetailOption) *JobDetailMutation {
	m := &JobDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeJobDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobDetailID sets the ID field of the mutation.
func withJobDetailID(id int) jobdetailOption {
	return func(m *JobDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *JobDetail
		)
		m.oldValue = func(ctx context.Context) (*JobDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobDetail sets the old JobDetail of the mutation.
func withJobDetail(node *JobDetail) jobdetailOption {
	return func(m *JobDetailMutation) {
		m.oldValue = func(context.Context) (*JobDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYibfNo sets the "YibfNo" field.
func (m *JobDetailMutation) SetYibfNo(i int) {
	m._YibfNo = &i
	m.add_YibfNo = nil
}

// YibfNo returns the value of the "YibfNo" field in the mutation.
func (m *JobDetailMutation) YibfNo() (r int, exists bool) {
	v := m._YibfNo
	if v == nil {
		return
	}
	return *v, true
}

// OldYibfNo returns the old "YibfNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldYibfNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYibfNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYibfNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYibfNo: %w", err)
	}
	return oldValue.YibfNo, nil
}

// AddYibfNo adds i to the "YibfNo" field.
func (m *JobDetailMutation) AddYibfNo(i int) {
	if m.add_YibfNo != nil {
		*m.add_YibfNo += i
	} else {
		m.add_YibfNo = &i
	}
}

// AddedYibfNo returns the value that was added to the "YibfNo" field in this mutation.
func (m *JobDetailMutation) AddedYibfNo() (r int, exists bool) {
	v := m.add_YibfNo
	if v == nil {
		return
	}
	return *v, true
}

// ResetYibfNo resets all changes to the "YibfNo" field.
func (m *JobDetailMutation) ResetYibfNo() {
	m._YibfNo = nil
	m.add_YibfNo = nil
}

// SetTitle sets the "Title" field.
func (m *JobDetailMutation) SetTitle(s string) {
	m._Title = &s
}

// Title returns the value of the "Title" field in the mutation.
func (m *JobDetailMutation) Title() (r string, exists bool) {
	v := m._Title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "Title" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "Title" field.
func (m *JobDetailMutation) ClearTitle() {
	m._Title = nil
	m.clearedFields[jobdetail.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "Title" field was cleared in this mutation.
func (m *JobDetailMutation) TitleCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "Title" field.
func (m *JobDetailMutation) ResetTitle() {
	m._Title = nil
	delete(m.clearedFields, jobdetail.FieldTitle)
}

// SetAdministration sets the "Administration" field.
func (m *JobDetailMutation) SetAdministration(s string) {
	m._Administration = &s
}

// Administration returns the value of the "Administration" field in the mutation.
func (m *JobDetailMutation) Administration() (r string, exists bool) {
	v := m._Administration
	if v == nil {
		return
	}
	return *v, true
}

// OldAdministration returns the old "Administration" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldAdministration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdministration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdministration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdministration: %w", err)
	}
	return oldValue.Administration, nil
}

// ClearAdministration clears the value of the "Administration" field.
func (m *JobDetailMutation) ClearAdministration() {
	m._Administration = nil
	m.clearedFields[jobdetail.FieldAdministration] = struct{}{}
}

// AdministrationCleared returns if the "Administration" field was cleared in this mutation.
func (m *JobDetailMutation) AdministrationCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldAdministration]
	return ok
}

// ResetAdministration resets all changes to the "Administration" field.
func (m *JobDetailMutation) ResetAdministration() {
	m._Administration = nil
	delete(m.clearedFields, jobdetail.FieldAdministration)
}

// SetState sets the "State" field.
func (m *JobDetailMutation) SetState(s string) {
	m._State = &s
}

// State returns the value of the "State" field in the mutation.
func (m *JobDetailMutation) State() (r string, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "State" field.
func (m *JobDetailMutation) ClearState() {
	m._State = nil
	m.clearedFields[jobdetail.FieldState] = struct{}{}
}

// StateCleared returns if the "State" field was cleared in this mutation.
func (m *JobDetailMutation) StateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldState]
	return ok
}

// ResetState resets all changes to the "State" field.
func (m *JobDetailMutation) ResetState() {
	m._State = nil
	delete(m.clearedFields, jobdetail.FieldState)
}

// SetIsland sets the "Island" field.
func (m *JobDetailMutation) SetIsland(s string) {
	m._Island = &s
}

// Island returns the value of the "Island" field in the mutation.
func (m *JobDetailMutation) Island() (r string, exists bool) {
	v := m._Island
	if v == nil {
		return
	}
	return *v, true
}

// OldIsland returns the old "Island" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldIsland(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsland is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsland requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsland: %w", err)
	}
	return oldValue.Island, nil
}

// ClearIsland clears the value of the "Island" field.
func (m *JobDetailMutation) ClearIsland() {
	m._Island = nil
	m.clearedFields[jobdetail.FieldIsland] = struct{}{}
}

// IslandCleared returns if the "Island" field was cleared in this mutation.
func (m *JobDetailMutation) IslandCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldIsland]
	return ok
}

// ResetIsland resets all changes to the "Island" field.
func (m *JobDetailMutation) ResetIsland() {
	m._Island = nil
	delete(m.clearedFields, jobdetail.FieldIsland)
}

// SetParcel sets the "Parcel" field.
func (m *JobDetailMutation) SetParcel(s string) {
	m._Parcel = &s
}

// Parcel returns the value of the "Parcel" field in the mutation.
func (m *JobDetailMutation) Parcel() (r string, exists bool) {
	v := m._Parcel
	if v == nil {
		return
	}
	return *v, true
}

// OldParcel returns the old "Parcel" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldParcel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParcel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParcel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParcel: %w", err)
	}
	return oldValue.Parcel, nil
}

// ClearParcel clears the value of the "Parcel" field.
func (m *JobDetailMutation) ClearParcel() {
	m._Parcel = nil
	m.clearedFields[jobdetail.FieldParcel] = struct{}{}
}

// ParcelCleared returns if the "Parcel" field was cleared in this mutation.
func (m *JobDetailMutation) ParcelCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldParcel]
	return ok
}

// ResetParcel resets all changes to the "Parcel" field.
func (m *JobDetailMutation) ResetParcel() {
	m._Parcel = nil
	delete(m.clearedFields, jobdetail.FieldParcel)
}

// SetSheet sets the "Sheet" field.
func (m *JobDetailMutation) SetSheet(s string) {
	m._Sheet = &s
}

// Sheet returns the value of the "Sheet" field in the mutation.
func (m *JobDetailMutation) Sheet() (r string, exists bool) {
	v := m._Sheet
	if v == nil {
		return
	}
	return *v, true
}

// OldSheet returns the old "Sheet" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldSheet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSheet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSheet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSheet: %w", err)
	}
	return oldValue.Sheet, nil
}

// ClearSheet clears the value of the "Sheet" field.
func (m *JobDetailMutation) ClearSheet() {
	m._Sheet = nil
	m.clearedFields[jobdetail.FieldSheet] = struct{}{}
}

// SheetCleared returns if the "Sheet" field was cleared in this mutation.
func (m *JobDetailMutation) SheetCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldSheet]
	return ok
}

// ResetSheet resets all changes to the "Sheet" field.
func (m *JobDetailMutation) ResetSheet() {
	m._Sheet = nil
	delete(m.clearedFields, jobdetail.FieldSheet)
}

// SetContractDate sets the "ContractDate" field.
func (m *JobDetailMutation) SetContractDate(t time.Time) {
	m._ContractDate = &t
}

// ContractDate returns the value of the "ContractDate" field in the mutation.
func (m *JobDetailMutation) ContractDate() (r time.Time, exists bool) {
	v := m._ContractDate
	if v == nil {
		return
	}
	return *v, true
}

// OldContractDate returns the old "ContractDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldContractDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractDate: %w", err)
	}
	return oldValue.ContractDate, nil
}

// ClearContractDate clears the value of the "ContractDate" field.
func (m *JobDetailMutation) ClearContractDate() {
	m._ContractDate = nil
	m.clearedFields[jobdetail.FieldContractDate] = struct{}{}
}

// ContractDateCleared returns if the "ContractDate" field was cleared in this mutation.
func (m *JobDetailMutation) ContractDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldContractDate]
	return ok
}

// ResetContractDate resets all changes to the "ContractDate" field.
func (m *JobDetailMutation) ResetContractDate() {
	m._ContractDate = nil
	delete(m.clearedFields, jobdetail.FieldContractDate)
}

// SetStartDate sets the "StartDate" field.
func (m *JobDetailMutation) SetStartDate(t time.Time) {
	m._StartDate = &t
}

// StartDate returns the value of the "StartDate" field in the mutation.
func (m *JobDetailMutation) StartDate() (r time.Time, exists bool) {
	v := m._StartDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "StartDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "StartDate" field.
func (m *JobDetailMutation) ClearStartDate() {
	m._StartDate = nil
	m.clearedFields[jobdetail.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "StartDate" field was cleared in this mutation.
func (m *JobDetailMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "StartDate" field.
func (m *JobDetailMutation) ResetStartDate() {
	m._StartDate = nil
	delete(m.clearedFields, jobdetail.FieldStartDate)
}

// SetLicenseDate sets the "LicenseDate" field.
func (m *JobDetailMutation) SetLicenseDate(t time.Time) {
	m._LicenseDate = &t
}

// LicenseDate returns the value of the "LicenseDate" field in the mutation.
func (m *JobDetailMutation) LicenseDate() (r time.Time, exists bool) {
	v := m._LicenseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseDate returns the old "LicenseDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLicenseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseDate: %w", err)
	}
	return oldValue.LicenseDate, nil
}

// ClearLicenseDate clears the value of the "LicenseDate" field.
func (m *JobDetailMutation) ClearLicenseDate() {
	m._LicenseDate = nil
	m.clearedFields[jobdetail.FieldLicenseDate] = struct{}{}
}

// LicenseDateCleared returns if the "LicenseDate" field was cleared in this mutation.
func (m *JobDetailMutation) LicenseDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLicenseDate]
	return ok
}

// ResetLicenseDate resets all changes to the "LicenseDate" field.
func (m *JobDetailMutation) ResetLicenseDate() {
	m._LicenseDate = nil
	delete(m.clearedFields, jobdetail.FieldLicenseDate)
}

// SetLicenseNo sets the "LicenseNo" field.
func (m *JobDetailMutation) SetLicenseNo(s string) {
	m._LicenseNo = &s
}

// LicenseNo returns the value of the "LicenseNo" field in the mutation.
func (m *JobDetailMutation) LicenseNo() (r string, exists bool) {
	v := m._LicenseNo
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNo returns the old "LicenseNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLicenseNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNo: %w", err)
	}
	return oldValue.LicenseNo, nil
}

// ClearLicenseNo clears the value of the "LicenseNo" field.
func (m *JobDetailMutation) ClearLicenseNo() {
	m._LicenseNo = nil
	m.clearedFields[jobdetail.FieldLicenseNo] = struct{}{}
}

// LicenseNoCleared returns if the "LicenseNo" field was cleared in this mutation.
func (m *JobDetailMutation) LicenseNoCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLicenseNo]
	return ok
}

// ResetLicenseNo resets all changes to the "LicenseNo" field.
func (m *JobDetailMutation) ResetLicenseNo() {
	m._LicenseNo = nil
	delete(m.clearedFields, jobdetail.FieldLicenseNo)
}

// SetDistributionDate sets the "DistributionDate" field.
func (m *JobDetailMutation) SetDistributionDate(t time.Time) {
	m._DistributionDate = &t
}

// DistributionDate returns the value of the "DistributionDate" field in the mutation.
func (m *JobDetailMutation) DistributionDate() (r time.Time, exists bool) {
	v := m._DistributionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldDistributionDate returns the old "DistributionDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldDistributionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistributionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistributionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistributionDate: %w", err)
	}
	return oldValue.DistributionDate, nil
}

// ClearDistributionDate clears the value of the "DistributionDate" field.
func (m *JobDetailMutation) ClearDistributionDate() {
	m._DistributionDate = nil
	m.clearedFields[jobdetail.FieldDistributionDate] = struct{}{}
}

// DistributionDateCleared returns if the "DistributionDate" field was cleared in this mutation.
func (m *JobDetailMutation) DistributionDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldDistributionDate]
	return ok
}

// ResetDistributionDate resets all changes to the "DistributionDate" field.
func (m *JobDetailMutation) ResetDistributionDate() {
	m._DistributionDate = nil
	delete(m.clearedFields, jobdetail.FieldDistributionDate)
}

// SetCompletionDate sets the "CompletionDate" field.
func (m *JobDetailMutation) SetCompletionDate(t time.Time) {
	m._CompletionDate = &t
}

// CompletionDate returns the value of the "CompletionDate" field in the mutation.
func (m *JobDetailMutation) CompletionDate() (r time.Time, exists bool) {
	v := m._CompletionDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionDate returns the old "CompletionDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionDate: %w", err)
	}
	return oldValue.CompletionDate, nil
}

// ClearCompletionDate clears the value of the "CompletionDate" field.
func (m *JobDetailMutation) ClearCompletionDate() {
	m._CompletionDate = nil
	m.clearedFields[jobdetail.FieldCompletionDate] = struct{}{}
}

// CompletionDateCleared returns if the "CompletionDate" field was cleared in this mutation.
func (m *JobDetailMutation) CompletionDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldCompletionDate]
	return ok
}

// ResetCompletionDate resets all changes to the "CompletionDate" field.
func (m *JobDetailMutation) ResetCompletionDate() {
	m._CompletionDate = nil
	delete(m.clearedFields, jobdetail.FieldCompletionDate)
}

// SetLandArea sets the "LandArea" field.
func (m *JobDetailMutation) SetLandArea(f float64) {
	m._LandArea = &f
	m.add_LandArea = nil
}

// LandArea returns the value of the "LandArea" field in the mutation.
func (m *JobDetailMutation) LandArea() (r float64, exists bool) {
	v := m._LandArea
	if v == nil {
		return
	}
	return *v, true
}

// OldLandArea returns the old "LandArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLandArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandArea: %w", err)
	}
	return oldValue.LandArea, nil
}

// AddLandArea adds f to the "LandArea" field.
func (m *JobDetailMutation) AddLandArea(f float64) {
	if m.add_LandArea != nil {
		*m.add_LandArea += f
	} else {
		m.add_LandArea = &f
	}
}

// AddedLandArea returns the value that was added to the "LandArea" field in this mutation.
func (m *JobDetailMutation) AddedLandArea() (r float64, exists bool) {
	v := m.add_LandArea
	if v == nil {
		return
	}
	return *v, true
}

// ClearLandArea clears the value of the "LandArea" field.
func (m *JobDetailMutation) ClearLandArea() {
	m._LandArea = nil
	m.add_LandArea = nil
	m.clearedFields[jobdetail.FieldLandArea] = struct{}{}
}

// LandAreaCleared returns if the "LandArea" field was cleared in this mutation.
func (m *JobDetailMutation) LandAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLandArea]
	return ok
}

// ResetLandArea resets all changes to the "LandArea" field.
func (m *JobDetailMutation) ResetLandArea() {
	m._LandArea = nil
	m.add_LandArea = nil
	delete(m.clearedFields, jobdetail.FieldLandArea)
}

// SetTotalArea sets the "TotalArea" field.
func (m *JobDetailMutation) SetTotalArea(f float64) {
	m._TotalArea = &f
	m.add_TotalArea = nil
}

// TotalArea returns the value of the "TotalArea" field in the mutation.
func (m *JobDetailMutation) TotalArea() (r float64, exists bool) {
	v := m._TotalArea
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalArea returns the old "TotalArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldTotalArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalArea: %w", err)
	}
	return oldValue.TotalArea, nil
}

// AddTotalArea adds f to the "TotalArea" field.
func (m *JobDetailMutation) AddTotalArea(f float64) {
	if m.add_TotalArea != nil {
		*m.add_TotalArea += f
	} else {
		m.add_TotalArea = &f
	}
}

// AddedTotalArea returns the value that was added to the "TotalArea" field in this mutation.
func (m *JobDetailMutation) AddedTotalArea() (r float64, exists bool) {
	v := m.add_TotalArea
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalArea clears the value of the "TotalArea" field.
func (m *JobDetailMutation) ClearTotalArea() {
	m._TotalArea = nil
	m.add_TotalArea = nil
	m.clearedFields[jobdetail.FieldTotalArea] = struct{}{}
}

// TotalAreaCleared returns if the "TotalArea" field was cleared in this mutation.
func (m *JobDetailMutation) TotalAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldTotalArea]
	return ok
}

// ResetTotalArea resets all changes to the "TotalArea" field.
func (m *JobDetailMutation) ResetTotalArea() {
	m._TotalArea = nil
	m.add_TotalArea = nil
	delete(m.clearedFields, jobdetail.FieldTotalArea)
}

// SetConstructionArea sets the "ConstructionArea" field.
func (m *JobDetailMutation) SetConstructionArea(f float64) {
	m._ConstructionArea = &f
	m.add_ConstructionArea = nil
}

// ConstructionArea returns the value of the "ConstructionArea" field in the mutation.
func (m *JobDetailMutation) ConstructionArea() (r float64, exists bool) {
	v := m._ConstructionArea
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionArea returns the old "ConstructionArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldConstructionArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionArea: %w", err)
	}
	return oldValue.ConstructionArea, nil
}

// AddConstructionArea adds f to the "ConstructionArea" field.
func (m *JobDetailMutation) AddConstructionArea(f float64) {
	if m.add_ConstructionArea != nil {
		*m.add_ConstructionArea += f
	} else {
		m.add_ConstructionArea = &f
	}
}

// AddedConstructionArea returns the value that was added to the "ConstructionArea" field in this mutation.
func (m *JobDetailMutation) AddedConstructionArea() (r float64, exists bool) {
	v := m.add_ConstructionArea
	if v == nil {
		return
	}
	return *v, true
}

// ClearConstructionArea clears the value of the "ConstructionArea" field.
func (m *JobDetailMutation) ClearConstructionArea() {
	m._ConstructionArea = nil
	m.add_ConstructionArea = nil
	m.clearedFields[jobdetail.FieldConstructionArea] = struct{}{}
}

// ConstructionAreaCleared returns if the "ConstructionArea" field was cleared in this mutation.
func (m *JobDetailMutation) ConstructionAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldConstructionArea]
	return ok
}

// ResetConstructionArea resets all changes to the "ConstructionArea" field.
func (m *JobDetailMutation) ResetConstructionArea() {
	m._ConstructionArea = nil
	m.add_ConstructionArea = nil
	delete(m.clearedFields, jobdetail.FieldConstructionArea)
}

// SetLeftArea sets the "LeftArea" field.
func (m *JobDetailMutation) SetLeftArea(f float64) {
	m._LeftArea = &f
	m.add_LeftArea = nil
}

// LeftArea returns the value of the "LeftArea" field in the mutation.
func (m *JobDetailMutation) LeftArea() (r float64, exists bool) {
	v := m._LeftArea
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftArea returns the old "LeftArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLeftArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftArea: %w", err)
	}
	return oldValue.LeftArea, nil
}

// AddLeftArea adds f to the "LeftArea" field.
func (m *JobDetailMutation) AddLeftArea(f float64) {
	if m.add_LeftArea != nil {
		*m.add_LeftArea += f
	} else {
		m.add_LeftArea = &f
	}
}

// AddedLeftArea returns the value that was added to the "LeftArea" field in this mutation.
func (m *JobDetailMutation) AddedLeftArea() (r float64, exists bool) {
	v := m.add_LeftArea
	if v == nil {
		return
	}
	return *v, true
}

// ClearLeftArea clears the value of the "LeftArea" field.
func (m *JobDetailMutation) ClearLeftArea() {
	m._LeftArea = nil
	m.add_LeftArea = nil
	m.clearedFields[jobdetail.FieldLeftArea] = struct{}{}
}

// LeftAreaCleared returns if the "LeftArea" field was cleared in this mutation.
func (m *JobDetailMutation) LeftAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLeftArea]
	return ok
}

// ResetLeftArea resets all changes to the "LeftArea" field.
func (m *JobDetailMutation) ResetLeftArea() {
	m._LeftArea = nil
	m.add_LeftArea = nil
	delete(m.clearedFields, jobdetail.FieldLeftArea)
}

// SetYDSAddress sets the "YDSAddress" field.
func (m *JobDetailMutation) SetYDSAddress(s string) {
	m._YDSAddress = &s
}

// YDSAddress returns the value of the "YDSAddress" field in the mutation.
func (m *JobDetailMutation) YDSAddress() (r string, exists bool) {
	v := m._YDSAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldYDSAddress returns the old "YDSAddress" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldYDSAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYDSAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYDSAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYDSAddress: %w", err)
	}
	return oldValue.YDSAddress, nil
}

// ClearYDSAddress clears the value of the "YDSAddress" field.
func (m *JobDetailMutation) ClearYDSAddress() {
	m._YDSAddress = nil
	m.clearedFields[jobdetail.FieldYDSAddress] = struct{}{}
}

// YDSAddressCleared returns if the "YDSAddress" field was cleared in this mutation.
func (m *JobDetailMutation) YDSAddressCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldYDSAddress]
	return ok
}

// ResetYDSAddress resets all changes to the "YDSAddress" field.
func (m *JobDetailMutation) ResetYDSAddress() {
	m._YDSAddress = nil
	delete(m.clearedFields, jobdetail.FieldYDSAddress)
}

// SetAddress sets the "Address" field.
func (m *JobDetailMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobDetailMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobDetailMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobdetail.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobDetailMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobDetailMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobdetail.FieldAddress)
}

// SetBuildingClass sets the "BuildingClass" field.
func (m *JobDetailMutation) SetBuildingClass(s string) {
	m._BuildingClass = &s
}

// BuildingClass returns the value of the "BuildingClass" field in the mutation.
func (m *JobDetailMutation) BuildingClass() (r string, exists bool) {
	v := m._BuildingClass
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingClass returns the old "BuildingClass" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBuildingClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingClass: %w", err)
	}
	return oldValue.BuildingClass, nil
}

// ClearBuildingClass clears the value of the "BuildingClass" field.
func (m *JobDetailMutation) ClearBuildingClass() {
	m._BuildingClass = nil
	m.clearedFields[jobdetail.FieldBuildingClass] = struct{}{}
}

// BuildingClassCleared returns if the "BuildingClass" field was cleared in this mutation.
func (m *JobDetailMutation) BuildingClassCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBuildingClass]
	return ok
}

// ResetBuildingClass resets all changes to the "BuildingClass" field.
func (m *JobDetailMutation) ResetBuildingClass() {
	m._BuildingClass = nil
	delete(m.clearedFields, jobdetail.FieldBuildingClass)
}

// SetBuildingType sets the "BuildingType" field.
func (m *JobDetailMutation) SetBuildingType(s string) {
	m._BuildingType = &s
}

// BuildingType returns the value of the "BuildingType" field in the mutation.
func (m *JobDetailMutation) BuildingType() (r string, exists bool) {
	v := m._BuildingType
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingType returns the old "BuildingType" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBuildingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingType: %w", err)
	}
	return oldValue.BuildingType, nil
}

// ClearBuildingType clears the value of the "BuildingType" field.
func (m *JobDetailMutation) ClearBuildingType() {
	m._BuildingType = nil
	m.clearedFields[jobdetail.FieldBuildingType] = struct{}{}
}

// BuildingTypeCleared returns if the "BuildingType" field was cleared in this mutation.
func (m *JobDetailMutation) BuildingTypeCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBuildingType]
	return ok
}

// ResetBuildingType resets all changes to the "BuildingType" field.
func (m *JobDetailMutation) ResetBuildingType() {
	m._BuildingType = nil
	delete(m.clearedFields, jobdetail.FieldBuildingType)
}

// SetLevel sets the "Level" field.
func (m *JobDetailMutation) SetLevel(f float64) {
	m._Level = &f
	m.add_Level = nil
}

// Level returns the value of the "Level" field in the mutation.
func (m *JobDetailMutation) Level() (r float64, exists bool) {
	v := m._Level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "Level" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLevel(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds f to the "Level" field.
func (m *JobDetailMutation) AddLevel(f float64) {
	if m.add_Level != nil {
		*m.add_Level += f
	} else {
		m.add_Level = &f
	}
}

// AddedLevel returns the value that was added to the "Level" field in this mutation.
func (m *JobDetailMutation) AddedLevel() (r float64, exists bool) {
	v := m.add_Level
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "Level" field.
func (m *JobDetailMutation) ClearLevel() {
	m._Level = nil
	m.add_Level = nil
	m.clearedFields[jobdetail.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "Level" field was cleared in this mutation.
func (m *JobDetailMutation) LevelCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "Level" field.
func (m *JobDetailMutation) ResetLevel() {
	m._Level = nil
	m.add_Level = nil
	delete(m.clearedFields, jobdetail.FieldLevel)
}

// SetUnitPrice sets the "UnitPrice" field.
func (m *JobDetailMutation) SetUnitPrice(f float64) {
	m._UnitPrice = &f
	m.add_UnitPrice = nil
}

// UnitPrice returns the value of the "UnitPrice" field in the mutation.
func (m *JobDetailMutation) UnitPrice() (r float64, exists bool) {
	v := m._UnitPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "UnitPrice" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "UnitPrice" field.
func (m *JobDetailMutation) AddUnitPrice(f float64) {
	if m.add_UnitPrice != nil {
		*m.add_UnitPrice += f
	} else {
		m.add_UnitPrice = &f
	}
}

// AddedUnitPrice returns the value that was added to the "UnitPrice" field in this mutation.
func (m *JobDetailMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.add_UnitPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitPrice clears the value of the "UnitPrice" field.
func (m *JobDetailMutation) ClearUnitPrice() {
	m._UnitPrice = nil
	m.add_UnitPrice = nil
	m.clearedFields[jobdetail.FieldUnitPrice] = struct{}{}
}

// UnitPriceCleared returns if the "UnitPrice" field was cleared in this mutation.
func (m *JobDetailMutation) UnitPriceCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldUnitPrice]
	return ok
}

// ResetUnitPrice resets all changes to the "UnitPrice" field.
func (m *JobDetailMutation) ResetUnitPrice() {
	m._UnitPrice = nil
	m.add_UnitPrice = nil
	delete(m.clearedFields, jobdetail.FieldUnitPrice)
}

// SetFloorCount sets the "FloorCount" field.
func (m *JobDetailMutation) SetFloorCount(i int) {
	m._FloorCount = &i
	m.add_FloorCount = nil
}

// FloorCount returns the value of the "FloorCount" field in the mutation.
func (m *JobDetailMutation) FloorCount() (r int, exists bool) {
	v := m._FloorCount
	if v == nil {
		return
	}
	return *v, true
}

// OldFloorCount returns the old "FloorCount" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldFloorCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloorCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloorCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloorCount: %w", err)
	}
	return oldValue.FloorCount, nil
}

// AddFloorCount adds i to the "FloorCount" field.
func (m *JobDetailMutation) AddFloorCount(i int) {
	if m.add_FloorCount != nil {
		*m.add_FloorCount += i
	} else {
		m.add_FloorCount = &i
	}
}

// AddedFloorCount returns the value that was added to the "FloorCount" field in this mutation.
func (m *JobDetailMutation) AddedFloorCount() (r int, exists bool) {
	v := m.add_FloorCount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloorCount clears the value of the "FloorCount" field.
func (m *JobDetailMutation) ClearFloorCount() {
	m._FloorCount = nil
	m.add_FloorCount = nil
	m.clearedFields[jobdetail.FieldFloorCount] = struct{}{}
}

// FloorCountCleared returns if the "FloorCount" field was cleared in this mutation.
func (m *JobDetailMutation) FloorCountCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldFloorCount]
	return ok
}

// ResetFloorCount resets all changes to the "FloorCount" field.
func (m *JobDetailMutation) ResetFloorCount() {
	m._FloorCount = nil
	m.add_FloorCount = nil
	delete(m.clearedFields, jobdetail.FieldFloorCount)
}

// SetBKSReferenceNo sets the "BKSReferenceNo" field.
func (m *JobDetailMutation) SetBKSReferenceNo(i int) {
	m._BKSReferenceNo = &i
	m.add_BKSReferenceNo = nil
}

// BKSReferenceNo returns the value of the "BKSReferenceNo" field in the mutation.
func (m *JobDetailMutation) BKSReferenceNo() (r int, exists bool) {
	v := m._BKSReferenceNo
	if v == nil {
		return
	}
	return *v, true
}

// OldBKSReferenceNo returns the old "BKSReferenceNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBKSReferenceNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBKSReferenceNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBKSReferenceNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBKSReferenceNo: %w", err)
	}
	return oldValue.BKSReferenceNo, nil
}

// AddBKSReferenceNo adds i to the "BKSReferenceNo" field.
func (m *JobDetailMutation) AddBKSReferenceNo(i int) {
	if m.add_BKSReferenceNo != nil {
		*m.add_BKSReferenceNo += i
	} else {
		m.add_BKSReferenceNo = &i
	}
}

// AddedBKSReferenceNo returns the value that was added to the "BKSReferenceNo" field in this mutation.
func (m *JobDetailMutation) AddedBKSReferenceNo() (r int, exists bool) {
	v := m.add_BKSReferenceNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearBKSReferenceNo clears the value of the "BKSReferenceNo" field.
func (m *JobDetailMutation) ClearBKSReferenceNo() {
	m._BKSReferenceNo = nil
	m.add_BKSReferenceNo = nil
	m.clearedFields[jobdetail.FieldBKSReferenceNo] = struct{}{}
}

// BKSReferenceNoCleared returns if the "BKSReferenceNo" field was cleared in this mutation.
func (m *JobDetailMutation) BKSReferenceNoCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBKSReferenceNo]
	return ok
}

// ResetBKSReferenceNo resets all changes to the "BKSReferenceNo" field.
func (m *JobDetailMutation) ResetBKSReferenceNo() {
	m._BKSReferenceNo = nil
	m.add_BKSReferenceNo = nil
	delete(m.clearedFields, jobdetail.FieldBKSReferenceNo)
}

// SetCoordinates sets the "Coordinates" field.
func (m *JobDetailMutation) SetCoordinates(s string) {
	m._Coordinates = &s
}

// Coordinates returns the value of the "Coordinates" field in the mutation.
func (m *JobDetailMutation) Coordinates() (r string, exists bool) {
	v := m._Coordinates
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinates returns the old "Coordinates" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldCoordinates(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinates: %w", err)
	}
	return oldValue.Coordinates, nil
}

// ClearCoordinates clears the value of the "Coordinates" field.
func (m *JobDetailMutation) ClearCoordinates() {
	m._Coordinates = nil
	m.clearedFields[jobdetail.FieldCoordinates] = struct{}{}
}

// CoordinatesCleared returns if the "Coordinates" field was cleared in this mutation.
func (m *JobDetailMutation) CoordinatesCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldCoordinates]
	return ok
}

// ResetCoordinates resets all changes to the "Coordinates" field.
func (m *JobDetailMutation) ResetCoordinates() {
	m._Coordinates = nil
	delete(m.clearedFields, jobdetail.FieldCoordinates)
}

// SetFolderNo sets the "FolderNo" field.
func (m *JobDetailMutation) SetFolderNo(s string) {
	m._FolderNo = &s
}

// FolderNo returns the value of the "FolderNo" field in the mutation.
func (m *JobDetailMutation) FolderNo() (r string, exists bool) {
	v := m._FolderNo
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderNo returns the old "FolderNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldFolderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderNo: %w", err)
	}
	return oldValue.FolderNo, nil
}

// ClearFolderNo clears the value of the "FolderNo" field.
func (m *JobDetailMutation) ClearFolderNo() {
	m._FolderNo = nil
	m.clearedFields[jobdetail.FieldFolderNo] = struct{}{}
}

// FolderNoCleared returns if the "FolderNo" field was cleared in this mutation.
func (m *JobDetailMutation) FolderNoCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldFolderNo]
	return ok
}

// ResetFolderNo resets all changes to the "FolderNo" field.
func (m *JobDetailMutation) ResetFolderNo() {
	m._FolderNo = nil
	delete(m.clearedFields, jobdetail.FieldFolderNo)
}

// SetUploadedFile sets the "UploadedFile" field.
func (m *JobDetailMutation) SetUploadedFile(b bool) {
	m._UploadedFile = &b
}

// UploadedFile returns the value of the "UploadedFile" field in the mutation.
func (m *JobDetailMutation) UploadedFile() (r bool, exists bool) {
	v := m._UploadedFile
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadedFile returns the old "UploadedFile" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldUploadedFile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadedFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadedFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadedFile: %w", err)
	}
	return oldValue.UploadedFile, nil
}

// ClearUploadedFile clears the value of the "UploadedFile" field.
func (m *JobDetailMutation) ClearUploadedFile() {
	m._UploadedFile = nil
	m.clearedFields[jobdetail.FieldUploadedFile] = struct{}{}
}

// UploadedFileCleared returns if the "UploadedFile" field was cleared in this mutation.
func (m *JobDetailMutation) UploadedFileCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldUploadedFile]
	return ok
}

// ResetUploadedFile resets all changes to the "UploadedFile" field.
func (m *JobDetailMutation) ResetUploadedFile() {
	m._UploadedFile = nil
	delete(m.clearedFields, jobdetail.FieldUploadedFile)
}

// SetIndustryArea sets the "IndustryArea" field.
func (m *JobDetailMutation) SetIndustryArea(b bool) {
	m._IndustryArea = &b
}

// IndustryArea returns the value of the "IndustryArea" field in the mutation.
func (m *JobDetailMutation) IndustryArea() (r bool, exists bool) {
	v := m._IndustryArea
	if v == nil {
		return
	}
	return *v, true
}

// OldIndustryArea returns the old "IndustryArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldIndustryArea(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndustryArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndustryArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndustryArea: %w", err)
	}
	return oldValue.IndustryArea, nil
}

// ClearIndustryArea clears the value of the "IndustryArea" field.
func (m *JobDetailMutation) ClearIndustryArea() {
	m._IndustryArea = nil
	m.clearedFields[jobdetail.FieldIndustryArea] = struct{}{}
}

// IndustryAreaCleared returns if the "IndustryArea" field was cleared in this mutation.
func (m *JobDetailMutation) IndustryAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldIndustryArea]
	return ok
}

// ResetIndustryArea resets all changes to the "IndustryArea" field.
func (m *JobDetailMutation) ResetIndustryArea() {
	m._IndustryArea = nil
	delete(m.clearedFields, jobdetail.FieldIndustryArea)
}

// SetClusterStructure sets the "ClusterStructure" field.
func (m *JobDetailMutation) SetClusterStructure(b bool) {
	m._ClusterStructure = &b
}

// ClusterStructure returns the value of the "ClusterStructure" field in the mutation.
func (m *JobDetailMutation) ClusterStructure() (r bool, exists bool) {
	v := m._ClusterStructure
	if v == nil {
		return
	}
	return *v, true
}

// OldClusterStructure returns the old "ClusterStructure" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldClusterStructure(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClusterStructure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClusterStructure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClusterStructure: %w", err)
	}
	return oldValue.ClusterStructure, nil
}

// ClearClusterStructure clears the value of the "ClusterStructure" field.
func (m *JobDetailMutation) ClearClusterStructure() {
	m._ClusterStructure = nil
	m.clearedFields[jobdetail.FieldClusterStructure] = struct{}{}
}

// ClusterStructureCleared returns if the "ClusterStructure" field was cleared in this mutation.
func (m *JobDetailMutation) ClusterStructureCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldClusterStructure]
	return ok
}

// ResetClusterStructure resets all changes to the "ClusterStructure" field.
func (m *JobDetailMutation) ResetClusterStructure() {
	m._ClusterStructure = nil
	delete(m.clearedFields, jobdetail.FieldClusterStructure)
}

// SetIsLicenseExpired sets the "IsLicenseExpired" field.
func (m *JobDetailMutation) SetIsLicenseExpired(b bool) {
	m._IsLicenseExpired = &b
}

// IsLicenseExpired returns the value of the "IsLicenseExpired" field in the mutation.
func (m *JobDetailMutation) IsLicenseExpired() (r bool, exists bool) {
	v := m._IsLicenseExpired
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLicenseExpired returns the old "IsLicenseExpired" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldIsLicenseExpired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLicenseExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLicenseExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLicenseExpired: %w", err)
	}
	return oldValue.IsLicenseExpired, nil
}

// ClearIsLicenseExpired clears the value of the "IsLicenseExpired" field.
func (m *JobDetailMutation) ClearIsLicenseExpired() {
	m._IsLicenseExpired = nil
	m.clearedFields[jobdetail.FieldIsLicenseExpired] = struct{}{}
}

// IsLicenseExpiredCleared returns if the "IsLicenseExpired" field was cleared in this mutation.
func (m *JobDetailMutation) IsLicenseExpiredCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldIsLicenseExpired]
	return ok
}

// ResetIsLicenseExpired resets all changes to the "IsLicenseExpired" field.
func (m *JobDetailMutation) ResetIsLicenseExpired() {
	m._IsLicenseExpired = nil
	delete(m.clearedFields, jobdetail.FieldIsLicenseExpired)
}

// SetIsCompleted sets the "IsCompleted" field.
func (m *JobDetailMutation) SetIsCompleted(b bool) {
	m._IsCompleted = &b
}

// IsCompleted returns the value of the "IsCompleted" field in the mutation.
func (m *JobDetailMutation) IsCompleted() (r bool, exists bool) {
	v := m._IsCompleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCompleted returns the old "IsCompleted" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldIsCompleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCompleted: %w", err)
	}
	return oldValue.IsCompleted, nil
}

// ClearIsCompleted clears the value of the "IsCompleted" field.
func (m *JobDetailMutation) ClearIsCompleted() {
	m._IsCompleted = nil
	m.clearedFields[jobdetail.FieldIsCompleted] = struct{}{}
}

// IsCompletedCleared returns if the "IsCompleted" field was cleared in this mutation.
func (m *JobDetailMutation) IsCompletedCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldIsCompleted]
	return ok
}

// ResetIsCompleted resets all changes to the "IsCompleted" field.
func (m *JobDetailMutation) ResetIsCompleted() {
	m._IsCompleted = nil
	delete(m.clearedFields, jobdetail.FieldIsCompleted)
}

// SetNote sets the "Note" field.
func (m *JobDetailMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobDetailMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobDetailMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobdetail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobDetailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobDetailMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobdetail.FieldNote)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobDetailMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobDetailMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobDetailMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobDetailMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetOwnerID sets the "owner" edge to the JobOwner entity by id.
func (m *JobDetailMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the JobOwner entity.
func (m *JobDetailMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the JobOwner entity was cleared.
func (m *JobDetailMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *JobDetailMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *JobDetailMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetAuthorID sets the "author" edge to the JobAuthor entity by id.
func (m *JobDetailMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the JobAuthor entity.
func (m *JobDetailMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the JobAuthor entity was cleared.
func (m *JobDetailMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *JobDetailMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *JobDetailMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetCompanyID sets the "company" edge to the CompanyDetail entity by id.
func (m *JobDetailMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the CompanyDetail entity.
func (m *JobDetailMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the CompanyDetail entity was cleared.
func (m *JobDetailMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *JobDetailMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *JobDetailMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetProgressID sets the "progress" edge to the JobProgress entity by id.
func (m *JobDetailMutation) SetProgressID(id int) {
	m.progress = &id
}

// ClearProgress clears the "progress" edge to the JobProgress entity.
func (m *JobDetailMutation) ClearProgress() {
	m.clearedprogress = true
}

// ProgressCleared reports if the "progress" edge to the JobProgress entity was cleared.
func (m *JobDetailMutation) ProgressCleared() bool {
	return m.clearedprogress
}

// ProgressID returns the "progress" edge ID in the mutation.
func (m *JobDetailMutation) ProgressID() (id int, exists bool) {
	if m.progress != nil {
		return *m.progress, true
	}
	return
}

// ProgressIDs returns the "progress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgressID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ProgressIDs() (ids []int) {
	if id := m.progress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgress resets all changes to the "progress" edge.
func (m *JobDetailMutation) ResetProgress() {
	m.progress = nil
	m.clearedprogress = false
}

// SetContractorID sets the "contractor" edge to the JobContractor entity by id.
func (m *JobDetailMutation) SetContractorID(id int) {
	m.contractor = &id
}

// ClearContractor clears the "contractor" edge to the JobContractor entity.
func (m *JobDetailMutation) ClearContractor() {
	m.clearedcontractor = true
}

// ContractorCleared reports if the "contractor" edge to the JobContractor entity was cleared.
func (m *JobDetailMutation) ContractorCleared() bool {
	return m.clearedcontractor
}

// ContractorID returns the "contractor" edge ID in the mutation.
func (m *JobDetailMutation) ContractorID() (id int, exists bool) {
	if m.contractor != nil {
		return *m.contractor, true
	}
	return
}

// ContractorIDs returns the "contractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ContractorIDs() (ids []int) {
	if id := m.contractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContractor resets all changes to the "contractor" edge.
func (m *JobDetailMutation) ResetContractor() {
	m.contractor = nil
	m.clearedcontractor = false
}

// SetSupervisorID sets the "supervisor" edge to the JobSupervisor entity by id.
func (m *JobDetailMutation) SetSupervisorID(id int) {
	m.supervisor = &id
}

// ClearSupervisor clears the "supervisor" edge to the JobSupervisor entity.
func (m *JobDetailMutation) ClearSupervisor() {
	m.clearedsupervisor = true
}

// SupervisorCleared reports if the "supervisor" edge to the JobSupervisor entity was cleared.
func (m *JobDetailMutation) SupervisorCleared() bool {
	return m.clearedsupervisor
}

// SupervisorID returns the "supervisor" edge ID in the mutation.
func (m *JobDetailMutation) SupervisorID() (id int, exists bool) {
	if m.supervisor != nil {
		return *m.supervisor, true
	}
	return
}

// SupervisorIDs returns the "supervisor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SupervisorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) SupervisorIDs() (ids []int) {
	if id := m.supervisor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSupervisor resets all changes to the "supervisor" edge.
func (m *JobDetailMutation) ResetSupervisor() {
	m.supervisor = nil
	m.clearedsupervisor = false
}

// SetStaticID sets the "static" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetStaticID(id int) {
	m.static = &id
}

// ClearStatic clears the "static" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearStatic() {
	m.clearedstatic = true
}

// StaticCleared reports if the "static" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) StaticCleared() bool {
	return m.clearedstatic
}

// StaticID returns the "static" edge ID in the mutation.
func (m *JobDetailMutation) StaticID() (id int, exists bool) {
	if m.static != nil {
		return *m.static, true
	}
	return
}

// StaticIDs returns the "static" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaticID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) StaticIDs() (ids []int) {
	if id := m.static; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatic resets all changes to the "static" edge.
func (m *JobDetailMutation) ResetStatic() {
	m.static = nil
	m.clearedstatic = false
}

// SetMechanicID sets the "mechanic" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetMechanicID(id int) {
	m.mechanic = &id
}

// ClearMechanic clears the "mechanic" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearMechanic() {
	m.clearedmechanic = true
}

// MechanicCleared reports if the "mechanic" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) MechanicCleared() bool {
	return m.clearedmechanic
}

// MechanicID returns the "mechanic" edge ID in the mutation.
func (m *JobDetailMutation) MechanicID() (id int, exists bool) {
	if m.mechanic != nil {
		return *m.mechanic, true
	}
	return
}

// MechanicIDs returns the "mechanic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MechanicID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) MechanicIDs() (ids []int) {
	if id := m.mechanic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMechanic resets all changes to the "mechanic" edge.
func (m *JobDetailMutation) ResetMechanic() {
	m.mechanic = nil
	m.clearedmechanic = false
}

// SetElectricID sets the "electric" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetElectricID(id int) {
	m.electric = &id
}

// ClearElectric clears the "electric" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearElectric() {
	m.clearedelectric = true
}

// ElectricCleared reports if the "electric" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ElectricCleared() bool {
	return m.clearedelectric
}

// ElectricID returns the "electric" edge ID in the mutation.
func (m *JobDetailMutation) ElectricID() (id int, exists bool) {
	if m.electric != nil {
		return *m.electric, true
	}
	return
}

// ElectricIDs returns the "electric" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectricID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ElectricIDs() (ids []int) {
	if id := m.electric; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElectric resets all changes to the "electric" edge.
func (m *JobDetailMutation) ResetElectric() {
	m.electric = nil
	m.clearedelectric = false
}

// SetInspectorID sets the "inspector" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetInspectorID(id int) {
	m.inspector = &id
}

// ClearInspector clears the "inspector" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearInspector() {
	m.clearedinspector = true
}

// InspectorCleared reports if the "inspector" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) InspectorCleared() bool {
	return m.clearedinspector
}

// InspectorID returns the "inspector" edge ID in the mutation.
func (m *JobDetailMutation) InspectorID() (id int, exists bool) {
	if m.inspector != nil {
		return *m.inspector, true
	}
	return
}

// InspectorIDs returns the "inspector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InspectorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) InspectorIDs() (ids []int) {
	if id := m.inspector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspector resets all changes to the "inspector" edge.
func (m *JobDetailMutation) ResetInspector() {
	m.inspector = nil
	m.clearedinspector = false
}

// SetArchitectID sets the "architect" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetArchitectID(id int) {
	m.architect = &id
}

// ClearArchitect clears the "architect" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearArchitect() {
	m.clearedarchitect = true
}

// ArchitectCleared reports if the "architect" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ArchitectCleared() bool {
	return m.clearedarchitect
}

// ArchitectID returns the "architect" edge ID in the mutation.
func (m *JobDetailMutation) ArchitectID() (id int, exists bool) {
	if m.architect != nil {
		return *m.architect, true
	}
	return
}

// ArchitectIDs returns the "architect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArchitectID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ArchitectIDs() (ids []int) {
	if id := m.architect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArchitect resets all changes to the "architect" edge.
func (m *JobDetailMutation) ResetArchitect() {
	m.architect = nil
	m.clearedarchitect = false
}

// SetControllerID sets the "controller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetControllerID(id int) {
	m.controller = &id
}

// ClearController clears the "controller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearController() {
	m.clearedcontroller = true
}

// ControllerCleared reports if the "controller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ControllerCleared() bool {
	return m.clearedcontroller
}

// ControllerID returns the "controller" edge ID in the mutation.
func (m *JobDetailMutation) ControllerID() (id int, exists bool) {
	if m.controller != nil {
		return *m.controller, true
	}
	return
}

// ControllerIDs returns the "controller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ControllerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ControllerIDs() (ids []int) {
	if id := m.controller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetController resets all changes to the "controller" edge.
func (m *JobDetailMutation) ResetController() {
	m.controller = nil
	m.clearedcontroller = false
}

// SetMechaniccontrollerID sets the "mechaniccontroller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetMechaniccontrollerID(id int) {
	m.mechaniccontroller = &id
}

// ClearMechaniccontroller clears the "mechaniccontroller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearMechaniccontroller() {
	m.clearedmechaniccontroller = true
}

// MechaniccontrollerCleared reports if the "mechaniccontroller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) MechaniccontrollerCleared() bool {
	return m.clearedmechaniccontroller
}

// MechaniccontrollerID returns the "mechaniccontroller" edge ID in the mutation.
func (m *JobDetailMutation) MechaniccontrollerID() (id int, exists bool) {
	if m.mechaniccontroller != nil {
		return *m.mechaniccontroller, true
	}
	return
}

// MechaniccontrollerIDs returns the "mechaniccontroller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MechaniccontrollerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) MechaniccontrollerIDs() (ids []int) {
	if id := m.mechaniccontroller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMechaniccontroller resets all changes to the "mechaniccontroller" edge.
func (m *JobDetailMutation) ResetMechaniccontroller() {
	m.mechaniccontroller = nil
	m.clearedmechaniccontroller = false
}

// SetElectriccontrollerID sets the "electriccontroller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetElectriccontrollerID(id int) {
	m.electriccontroller = &id
}

// ClearElectriccontroller clears the "electriccontroller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearElectriccontroller() {
	m.clearedelectriccontroller = true
}

// ElectriccontrollerCleared reports if the "electriccontroller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ElectriccontrollerCleared() bool {
	return m.clearedelectriccontroller
}

// ElectriccontrollerID returns the "electriccontroller" edge ID in the mutation.
func (m *JobDetailMutation) ElectriccontrollerID() (id int, exists bool) {
	if m.electriccontroller != nil {
		return *m.electriccontroller, true
	}
	return
}

// ElectriccontrollerIDs returns the "electriccontroller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectriccontrollerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ElectriccontrollerIDs() (ids []int) {
	if id := m.electriccontroller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElectriccontroller resets all changes to the "electriccontroller" edge.
func (m *JobDetailMutation) ResetElectriccontroller() {
	m.electriccontroller = nil
	m.clearedelectriccontroller = false
}

// AddLayerIDs adds the "layers" edge to the JobLayer entity by ids.
func (m *JobDetailMutation) AddLayerIDs(ids ...int) {
	if m.layers == nil {
		m.layers = make(map[int]struct{})
	}
	for i := range ids {
		m.layers[ids[i]] = struct{}{}
	}
}

// ClearLayers clears the "layers" edge to the JobLayer entity.
func (m *JobDetailMutation) ClearLayers() {
	m.clearedlayers = true
}

// LayersCleared reports if the "layers" edge to the JobLayer entity was cleared.
func (m *JobDetailMutation) LayersCleared() bool {
	return m.clearedlayers
}

// RemoveLayerIDs removes the "layers" edge to the JobLayer entity by IDs.
func (m *JobDetailMutation) RemoveLayerIDs(ids ...int) {
	if m.removedlayers == nil {
		m.removedlayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.layers, ids[i])
		m.removedlayers[ids[i]] = struct{}{}
	}
}

// RemovedLayers returns the removed IDs of the "layers" edge to the JobLayer entity.
func (m *JobDetailMutation) RemovedLayersIDs() (ids []int) {
	for id := range m.removedlayers {
		ids = append(ids, id)
	}
	return
}

// LayersIDs returns the "layers" edge IDs in the mutation.
func (m *JobDetailMutation) LayersIDs() (ids []int) {
	for id := range m.layers {
		ids = append(ids, id)
	}
	return
}

// ResetLayers resets all changes to the "layers" edge.
func (m *JobDetailMutation) ResetLayers() {
	m.layers = nil
	m.clearedlayers = false
	m.removedlayers = nil
}

// AddPaymentIDs adds the "payments" edge to the JobPayments entity by ids.
func (m *JobDetailMutation) AddPaymentIDs(ids ...int) {
	if m.payments == nil {
		m.payments = make(map[int]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the JobPayments entity.
func (m *JobDetailMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the JobPayments entity was cleared.
func (m *JobDetailMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the JobPayments entity by IDs.
func (m *JobDetailMutation) RemovePaymentIDs(ids ...int) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the JobPayments entity.
func (m *JobDetailMutation) RemovedPaymentsIDs() (ids []int) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *JobDetailMutation) PaymentsIDs() (ids []int) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *JobDetailMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// Where appends a list predicates to the JobDetailMutation builder.
func (m *JobDetailMutation) Where(ps ...predicate.JobDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobDetail).
func (m *JobDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobDetailMutation) Fields() []string {
	fields := make([]string, 0, 35)
	if m._YibfNo != nil {
		fields = append(fields, jobdetail.FieldYibfNo)
	}
	if m._Title != nil {
		fields = append(fields, jobdetail.FieldTitle)
	}
	if m._Administration != nil {
		fields = append(fields, jobdetail.FieldAdministration)
	}
	if m._State != nil {
		fields = append(fields, jobdetail.FieldState)
	}
	if m._Island != nil {
		fields = append(fields, jobdetail.FieldIsland)
	}
	if m._Parcel != nil {
		fields = append(fields, jobdetail.FieldParcel)
	}
	if m._Sheet != nil {
		fields = append(fields, jobdetail.FieldSheet)
	}
	if m._ContractDate != nil {
		fields = append(fields, jobdetail.FieldContractDate)
	}
	if m._StartDate != nil {
		fields = append(fields, jobdetail.FieldStartDate)
	}
	if m._LicenseDate != nil {
		fields = append(fields, jobdetail.FieldLicenseDate)
	}
	if m._LicenseNo != nil {
		fields = append(fields, jobdetail.FieldLicenseNo)
	}
	if m._DistributionDate != nil {
		fields = append(fields, jobdetail.FieldDistributionDate)
	}
	if m._CompletionDate != nil {
		fields = append(fields, jobdetail.FieldCompletionDate)
	}
	if m._LandArea != nil {
		fields = append(fields, jobdetail.FieldLandArea)
	}
	if m._TotalArea != nil {
		fields = append(fields, jobdetail.FieldTotalArea)
	}
	if m._ConstructionArea != nil {
		fields = append(fields, jobdetail.FieldConstructionArea)
	}
	if m._LeftArea != nil {
		fields = append(fields, jobdetail.FieldLeftArea)
	}
	if m._YDSAddress != nil {
		fields = append(fields, jobdetail.FieldYDSAddress)
	}
	if m._Address != nil {
		fields = append(fields, jobdetail.FieldAddress)
	}
	if m._BuildingClass != nil {
		fields = append(fields, jobdetail.FieldBuildingClass)
	}
	if m._BuildingType != nil {
		fields = append(fields, jobdetail.FieldBuildingType)
	}
	if m._Level != nil {
		fields = append(fields, jobdetail.FieldLevel)
	}
	if m._UnitPrice != nil {
		fields = append(fields, jobdetail.FieldUnitPrice)
	}
	if m._FloorCount != nil {
		fields = append(fields, jobdetail.FieldFloorCount)
	}
	if m._BKSReferenceNo != nil {
		fields = append(fields, jobdetail.FieldBKSReferenceNo)
	}
	if m._Coordinates != nil {
		fields = append(fields, jobdetail.FieldCoordinates)
	}
	if m._FolderNo != nil {
		fields = append(fields, jobdetail.FieldFolderNo)
	}
	if m._UploadedFile != nil {
		fields = append(fields, jobdetail.FieldUploadedFile)
	}
	if m._IndustryArea != nil {
		fields = append(fields, jobdetail.FieldIndustryArea)
	}
	if m._ClusterStructure != nil {
		fields = append(fields, jobdetail.FieldClusterStructure)
	}
	if m._IsLicenseExpired != nil {
		fields = append(fields, jobdetail.FieldIsLicenseExpired)
	}
	if m._IsCompleted != nil {
		fields = append(fields, jobdetail.FieldIsCompleted)
	}
	if m._Note != nil {
		fields = append(fields, jobdetail.FieldNote)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobdetail.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.YibfNo()
	case jobdetail.FieldTitle:
		return m.Title()
	case jobdetail.FieldAdministration:
		return m.Administration()
	case jobdetail.FieldState:
		return m.State()
	case jobdetail.FieldIsland:
		return m.Island()
	case jobdetail.FieldParcel:
		return m.Parcel()
	case jobdetail.FieldSheet:
		return m.Sheet()
	case jobdetail.FieldContractDate:
		return m.ContractDate()
	case jobdetail.FieldStartDate:
		return m.StartDate()
	case jobdetail.FieldLicenseDate:
		return m.LicenseDate()
	case jobdetail.FieldLicenseNo:
		return m.LicenseNo()
	case jobdetail.FieldDistributionDate:
		return m.DistributionDate()
	case jobdetail.FieldCompletionDate:
		return m.CompletionDate()
	case jobdetail.FieldLandArea:
		return m.LandArea()
	case jobdetail.FieldTotalArea:
		return m.TotalArea()
	case jobdetail.FieldConstructionArea:
		return m.ConstructionArea()
	case jobdetail.FieldLeftArea:
		return m.LeftArea()
	case jobdetail.FieldYDSAddress:
		return m.YDSAddress()
	case jobdetail.FieldAddress:
		return m.Address()
	case jobdetail.FieldBuildingClass:
		return m.BuildingClass()
	case jobdetail.FieldBuildingType:
		return m.BuildingType()
	case jobdetail.FieldLevel:
		return m.Level()
	case jobdetail.FieldUnitPrice:
		return m.UnitPrice()
	case jobdetail.FieldFloorCount:
		return m.FloorCount()
	case jobdetail.FieldBKSReferenceNo:
		return m.BKSReferenceNo()
	case jobdetail.FieldCoordinates:
		return m.Coordinates()
	case jobdetail.FieldFolderNo:
		return m.FolderNo()
	case jobdetail.FieldUploadedFile:
		return m.UploadedFile()
	case jobdetail.FieldIndustryArea:
		return m.IndustryArea()
	case jobdetail.FieldClusterStructure:
		return m.ClusterStructure()
	case jobdetail.FieldIsLicenseExpired:
		return m.IsLicenseExpired()
	case jobdetail.FieldIsCompleted:
		return m.IsCompleted()
	case jobdetail.FieldNote:
		return m.Note()
	case jobdetail.FieldCreatedAt:
		return m.CreatedAt()
	case jobdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.OldYibfNo(ctx)
	case jobdetail.FieldTitle:
		return m.OldTitle(ctx)
	case jobdetail.FieldAdministration:
		return m.OldAdministration(ctx)
	case jobdetail.FieldState:
		return m.OldState(ctx)
	case jobdetail.FieldIsland:
		return m.OldIsland(ctx)
	case jobdetail.FieldParcel:
		return m.OldParcel(ctx)
	case jobdetail.FieldSheet:
		return m.OldSheet(ctx)
	case jobdetail.FieldContractDate:
		return m.OldContractDate(ctx)
	case jobdetail.FieldStartDate:
		return m.OldStartDate(ctx)
	case jobdetail.FieldLicenseDate:
		return m.OldLicenseDate(ctx)
	case jobdetail.FieldLicenseNo:
		return m.OldLicenseNo(ctx)
	case jobdetail.FieldDistributionDate:
		return m.OldDistributionDate(ctx)
	case jobdetail.FieldCompletionDate:
		return m.OldCompletionDate(ctx)
	case jobdetail.FieldLandArea:
		return m.OldLandArea(ctx)
	case jobdetail.FieldTotalArea:
		return m.OldTotalArea(ctx)
	case jobdetail.FieldConstructionArea:
		return m.OldConstructionArea(ctx)
	case jobdetail.FieldLeftArea:
		return m.OldLeftArea(ctx)
	case jobdetail.FieldYDSAddress:
		return m.OldYDSAddress(ctx)
	case jobdetail.FieldAddress:
		return m.OldAddress(ctx)
	case jobdetail.FieldBuildingClass:
		return m.OldBuildingClass(ctx)
	case jobdetail.FieldBuildingType:
		return m.OldBuildingType(ctx)
	case jobdetail.FieldLevel:
		return m.OldLevel(ctx)
	case jobdetail.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case jobdetail.FieldFloorCount:
		return m.OldFloorCount(ctx)
	case jobdetail.FieldBKSReferenceNo:
		return m.OldBKSReferenceNo(ctx)
	case jobdetail.FieldCoordinates:
		return m.OldCoordinates(ctx)
	case jobdetail.FieldFolderNo:
		return m.OldFolderNo(ctx)
	case jobdetail.FieldUploadedFile:
		return m.OldUploadedFile(ctx)
	case jobdetail.FieldIndustryArea:
		return m.OldIndustryArea(ctx)
	case jobdetail.FieldClusterStructure:
		return m.OldClusterStructure(ctx)
	case jobdetail.FieldIsLicenseExpired:
		return m.OldIsLicenseExpired(ctx)
	case jobdetail.FieldIsCompleted:
		return m.OldIsCompleted(ctx)
	case jobdetail.FieldNote:
		return m.OldNote(ctx)
	case jobdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobdetail.FieldYibfNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYibfNo(v)
		return nil
	case jobdetail.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case jobdetail.FieldAdministration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdministration(v)
		return nil
	case jobdetail.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case jobdetail.FieldIsland:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsland(v)
		return nil
	case jobdetail.FieldParcel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParcel(v)
		return nil
	case jobdetail.FieldSheet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSheet(v)
		return nil
	case jobdetail.FieldContractDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractDate(v)
		return nil
	case jobdetail.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case jobdetail.FieldLicenseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseDate(v)
		return nil
	case jobdetail.FieldLicenseNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNo(v)
		return nil
	case jobdetail.FieldDistributionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistributionDate(v)
		return nil
	case jobdetail.FieldCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionDate(v)
		return nil
	case jobdetail.FieldLandArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandArea(v)
		return nil
	case jobdetail.FieldTotalArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalArea(v)
		return nil
	case jobdetail.FieldConstructionArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionArea(v)
		return nil
	case jobdetail.FieldLeftArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftArea(v)
		return nil
	case jobdetail.FieldYDSAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYDSAddress(v)
		return nil
	case jobdetail.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobdetail.FieldBuildingClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingClass(v)
		return nil
	case jobdetail.FieldBuildingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingType(v)
		return nil
	case jobdetail.FieldLevel:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case jobdetail.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case jobdetail.FieldFloorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloorCount(v)
		return nil
	case jobdetail.FieldBKSReferenceNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBKSReferenceNo(v)
		return nil
	case jobdetail.FieldCoordinates:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinates(v)
		return nil
	case jobdetail.FieldFolderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderNo(v)
		return nil
	case jobdetail.FieldUploadedFile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadedFile(v)
		return nil
	case jobdetail.FieldIndustryArea:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndustryArea(v)
		return nil
	case jobdetail.FieldClusterStructure:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClusterStructure(v)
		return nil
	case jobdetail.FieldIsLicenseExpired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLicenseExpired(v)
		return nil
	case jobdetail.FieldIsCompleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCompleted(v)
		return nil
	case jobdetail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_YibfNo != nil {
		fields = append(fields, jobdetail.FieldYibfNo)
	}
	if m.add_LandArea != nil {
		fields = append(fields, jobdetail.FieldLandArea)
	}
	if m.add_TotalArea != nil {
		fields = append(fields, jobdetail.FieldTotalArea)
	}
	if m.add_ConstructionArea != nil {
		fields = append(fields, jobdetail.FieldConstructionArea)
	}
	if m.add_LeftArea != nil {
		fields = append(fields, jobdetail.FieldLeftArea)
	}
	if m.add_Level != nil {
		fields = append(fields, jobdetail.FieldLevel)
	}
	if m.add_UnitPrice != nil {
		fields = append(fields, jobdetail.FieldUnitPrice)
	}
	if m.add_FloorCount != nil {
		fields = append(fields, jobdetail.FieldFloorCount)
	}
	if m.add_BKSReferenceNo != nil {
		fields = append(fields, jobdetail.FieldBKSReferenceNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.AddedYibfNo()
	case jobdetail.FieldLandArea:
		return m.AddedLandArea()
	case jobdetail.FieldTotalArea:
		return m.AddedTotalArea()
	case jobdetail.FieldConstructionArea:
		return m.AddedConstructionArea()
	case jobdetail.FieldLeftArea:
		return m.AddedLeftArea()
	case jobdetail.FieldLevel:
		return m.AddedLevel()
	case jobdetail.FieldUnitPrice:
		return m.AddedUnitPrice()
	case jobdetail.FieldFloorCount:
		return m.AddedFloorCount()
	case jobdetail.FieldBKSReferenceNo:
		return m.AddedBKSReferenceNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobdetail.FieldYibfNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYibfNo(v)
		return nil
	case jobdetail.FieldLandArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLandArea(v)
		return nil
	case jobdetail.FieldTotalArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalArea(v)
		return nil
	case jobdetail.FieldConstructionArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConstructionArea(v)
		return nil
	case jobdetail.FieldLeftArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeftArea(v)
		return nil
	case jobdetail.FieldLevel:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case jobdetail.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case jobdetail.FieldFloorCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloorCount(v)
		return nil
	case jobdetail.FieldBKSReferenceNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBKSReferenceNo(v)
		return nil
	}
	return fmt.Errorf("unknown JobDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobdetail.FieldTitle) {
		fields = append(fields, jobdetail.FieldTitle)
	}
	if m.FieldCleared(jobdetail.FieldAdministration) {
		fields = append(fields, jobdetail.FieldAdministration)
	}
	if m.FieldCleared(jobdetail.FieldState) {
		fields = append(fields, jobdetail.FieldState)
	}
	if m.FieldCleared(jobdetail.FieldIsland) {
		fields = append(fields, jobdetail.FieldIsland)
	}
	if m.FieldCleared(jobdetail.FieldParcel) {
		fields = append(fields, jobdetail.FieldParcel)
	}
	if m.FieldCleared(jobdetail.FieldSheet) {
		fields = append(fields, jobdetail.FieldSheet)
	}
	if m.FieldCleared(jobdetail.FieldContractDate) {
		fields = append(fields, jobdetail.FieldContractDate)
	}
	if m.FieldCleared(jobdetail.FieldStartDate) {
		fields = append(fields, jobdetail.FieldStartDate)
	}
	if m.FieldCleared(jobdetail.FieldLicenseDate) {
		fields = append(fields, jobdetail.FieldLicenseDate)
	}
	if m.FieldCleared(jobdetail.FieldLicenseNo) {
		fields = append(fields, jobdetail.FieldLicenseNo)
	}
	if m.FieldCleared(jobdetail.FieldDistributionDate) {
		fields = append(fields, jobdetail.FieldDistributionDate)
	}
	if m.FieldCleared(jobdetail.FieldCompletionDate) {
		fields = append(fields, jobdetail.FieldCompletionDate)
	}
	if m.FieldCleared(jobdetail.FieldLandArea) {
		fields = append(fields, jobdetail.FieldLandArea)
	}
	if m.FieldCleared(jobdetail.FieldTotalArea) {
		fields = append(fields, jobdetail.FieldTotalArea)
	}
	if m.FieldCleared(jobdetail.FieldConstructionArea) {
		fields = append(fields, jobdetail.FieldConstructionArea)
	}
	if m.FieldCleared(jobdetail.FieldLeftArea) {
		fields = append(fields, jobdetail.FieldLeftArea)
	}
	if m.FieldCleared(jobdetail.FieldYDSAddress) {
		fields = append(fields, jobdetail.FieldYDSAddress)
	}
	if m.FieldCleared(jobdetail.FieldAddress) {
		fields = append(fields, jobdetail.FieldAddress)
	}
	if m.FieldCleared(jobdetail.FieldBuildingClass) {
		fields = append(fields, jobdetail.FieldBuildingClass)
	}
	if m.FieldCleared(jobdetail.FieldBuildingType) {
		fields = append(fields, jobdetail.FieldBuildingType)
	}
	if m.FieldCleared(jobdetail.FieldLevel) {
		fields = append(fields, jobdetail.FieldLevel)
	}
	if m.FieldCleared(jobdetail.FieldUnitPrice) {
		fields = append(fields, jobdetail.FieldUnitPrice)
	}
	if m.FieldCleared(jobdetail.FieldFloorCount) {
		fields = append(fields, jobdetail.FieldFloorCount)
	}
	if m.FieldCleared(jobdetail.FieldBKSReferenceNo) {
		fields = append(fields, jobdetail.FieldBKSReferenceNo)
	}
	if m.FieldCleared(jobdetail.FieldCoordinates) {
		fields = append(fields, jobdetail.FieldCoordinates)
	}
	if m.FieldCleared(jobdetail.FieldFolderNo) {
		fields = append(fields, jobdetail.FieldFolderNo)
	}
	if m.FieldCleared(jobdetail.FieldUploadedFile) {
		fields = append(fields, jobdetail.FieldUploadedFile)
	}
	if m.FieldCleared(jobdetail.FieldIndustryArea) {
		fields = append(fields, jobdetail.FieldIndustryArea)
	}
	if m.FieldCleared(jobdetail.FieldClusterStructure) {
		fields = append(fields, jobdetail.FieldClusterStructure)
	}
	if m.FieldCleared(jobdetail.FieldIsLicenseExpired) {
		fields = append(fields, jobdetail.FieldIsLicenseExpired)
	}
	if m.FieldCleared(jobdetail.FieldIsCompleted) {
		fields = append(fields, jobdetail.FieldIsCompleted)
	}
	if m.FieldCleared(jobdetail.FieldNote) {
		fields = append(fields, jobdetail.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobDetailMutation) ClearField(name string) error {
	switch name {
	case jobdetail.FieldTitle:
		m.ClearTitle()
		return nil
	case jobdetail.FieldAdministration:
		m.ClearAdministration()
		return nil
	case jobdetail.FieldState:
		m.ClearState()
		return nil
	case jobdetail.FieldIsland:
		m.ClearIsland()
		return nil
	case jobdetail.FieldParcel:
		m.ClearParcel()
		return nil
	case jobdetail.FieldSheet:
		m.ClearSheet()
		return nil
	case jobdetail.FieldContractDate:
		m.ClearContractDate()
		return nil
	case jobdetail.FieldStartDate:
		m.ClearStartDate()
		return nil
	case jobdetail.FieldLicenseDate:
		m.ClearLicenseDate()
		return nil
	case jobdetail.FieldLicenseNo:
		m.ClearLicenseNo()
		return nil
	case jobdetail.FieldDistributionDate:
		m.ClearDistributionDate()
		return nil
	case jobdetail.FieldCompletionDate:
		m.ClearCompletionDate()
		return nil
	case jobdetail.FieldLandArea:
		m.ClearLandArea()
		return nil
	case jobdetail.FieldTotalArea:
		m.ClearTotalArea()
		return nil
	case jobdetail.FieldConstructionArea:
		m.ClearConstructionArea()
		return nil
	case jobdetail.FieldLeftArea:
		m.ClearLeftArea()
		return nil
	case jobdetail.FieldYDSAddress:
		m.ClearYDSAddress()
		return nil
	case jobdetail.FieldAddress:
		m.ClearAddress()
		return nil
	case jobdetail.FieldBuildingClass:
		m.ClearBuildingClass()
		return nil
	case jobdetail.FieldBuildingType:
		m.ClearBuildingType()
		return nil
	case jobdetail.FieldLevel:
		m.ClearLevel()
		return nil
	case jobdetail.FieldUnitPrice:
		m.ClearUnitPrice()
		return nil
	case jobdetail.FieldFloorCount:
		m.ClearFloorCount()
		return nil
	case jobdetail.FieldBKSReferenceNo:
		m.ClearBKSReferenceNo()
		return nil
	case jobdetail.FieldCoordinates:
		m.ClearCoordinates()
		return nil
	case jobdetail.FieldFolderNo:
		m.ClearFolderNo()
		return nil
	case jobdetail.FieldUploadedFile:
		m.ClearUploadedFile()
		return nil
	case jobdetail.FieldIndustryArea:
		m.ClearIndustryArea()
		return nil
	case jobdetail.FieldClusterStructure:
		m.ClearClusterStructure()
		return nil
	case jobdetail.FieldIsLicenseExpired:
		m.ClearIsLicenseExpired()
		return nil
	case jobdetail.FieldIsCompleted:
		m.ClearIsCompleted()
		return nil
	case jobdetail.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobDetailMutation) ResetField(name string) error {
	switch name {
	case jobdetail.FieldYibfNo:
		m.ResetYibfNo()
		return nil
	case jobdetail.FieldTitle:
		m.ResetTitle()
		return nil
	case jobdetail.FieldAdministration:
		m.ResetAdministration()
		return nil
	case jobdetail.FieldState:
		m.ResetState()
		return nil
	case jobdetail.FieldIsland:
		m.ResetIsland()
		return nil
	case jobdetail.FieldParcel:
		m.ResetParcel()
		return nil
	case jobdetail.FieldSheet:
		m.ResetSheet()
		return nil
	case jobdetail.FieldContractDate:
		m.ResetContractDate()
		return nil
	case jobdetail.FieldStartDate:
		m.ResetStartDate()
		return nil
	case jobdetail.FieldLicenseDate:
		m.ResetLicenseDate()
		return nil
	case jobdetail.FieldLicenseNo:
		m.ResetLicenseNo()
		return nil
	case jobdetail.FieldDistributionDate:
		m.ResetDistributionDate()
		return nil
	case jobdetail.FieldCompletionDate:
		m.ResetCompletionDate()
		return nil
	case jobdetail.FieldLandArea:
		m.ResetLandArea()
		return nil
	case jobdetail.FieldTotalArea:
		m.ResetTotalArea()
		return nil
	case jobdetail.FieldConstructionArea:
		m.ResetConstructionArea()
		return nil
	case jobdetail.FieldLeftArea:
		m.ResetLeftArea()
		return nil
	case jobdetail.FieldYDSAddress:
		m.ResetYDSAddress()
		return nil
	case jobdetail.FieldAddress:
		m.ResetAddress()
		return nil
	case jobdetail.FieldBuildingClass:
		m.ResetBuildingClass()
		return nil
	case jobdetail.FieldBuildingType:
		m.ResetBuildingType()
		return nil
	case jobdetail.FieldLevel:
		m.ResetLevel()
		return nil
	case jobdetail.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case jobdetail.FieldFloorCount:
		m.ResetFloorCount()
		return nil
	case jobdetail.FieldBKSReferenceNo:
		m.ResetBKSReferenceNo()
		return nil
	case jobdetail.FieldCoordinates:
		m.ResetCoordinates()
		return nil
	case jobdetail.FieldFolderNo:
		m.ResetFolderNo()
		return nil
	case jobdetail.FieldUploadedFile:
		m.ResetUploadedFile()
		return nil
	case jobdetail.FieldIndustryArea:
		m.ResetIndustryArea()
		return nil
	case jobdetail.FieldClusterStructure:
		m.ResetClusterStructure()
		return nil
	case jobdetail.FieldIsLicenseExpired:
		m.ResetIsLicenseExpired()
		return nil
	case jobdetail.FieldIsCompleted:
		m.ResetIsCompleted()
		return nil
	case jobdetail.FieldNote:
		m.ResetNote()
		return nil
	case jobdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.owner != nil {
		edges = append(edges, jobdetail.EdgeOwner)
	}
	if m.author != nil {
		edges = append(edges, jobdetail.EdgeAuthor)
	}
	if m.company != nil {
		edges = append(edges, jobdetail.EdgeCompany)
	}
	if m.progress != nil {
		edges = append(edges, jobdetail.EdgeProgress)
	}
	if m.contractor != nil {
		edges = append(edges, jobdetail.EdgeContractor)
	}
	if m.supervisor != nil {
		edges = append(edges, jobdetail.EdgeSupervisor)
	}
	if m.static != nil {
		edges = append(edges, jobdetail.EdgeStatic)
	}
	if m.mechanic != nil {
		edges = append(edges, jobdetail.EdgeMechanic)
	}
	if m.electric != nil {
		edges = append(edges, jobdetail.EdgeElectric)
	}
	if m.inspector != nil {
		edges = append(edges, jobdetail.EdgeInspector)
	}
	if m.architect != nil {
		edges = append(edges, jobdetail.EdgeArchitect)
	}
	if m.controller != nil {
		edges = append(edges, jobdetail.EdgeController)
	}
	if m.mechaniccontroller != nil {
		edges = append(edges, jobdetail.EdgeMechaniccontroller)
	}
	if m.electriccontroller != nil {
		edges = append(edges, jobdetail.EdgeElectriccontroller)
	}
	if m.layers != nil {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	if m.payments != nil {
		edges = append(edges, jobdetail.EdgePayments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobdetail.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeProgress:
		if id := m.progress; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeContractor:
		if id := m.contractor; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeSupervisor:
		if id := m.supervisor; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeStatic:
		if id := m.static; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeMechanic:
		if id := m.mechanic; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeElectric:
		if id := m.electric; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeInspector:
		if id := m.inspector; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeArchitect:
		if id := m.architect; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeController:
		if id := m.controller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeMechaniccontroller:
		if id := m.mechaniccontroller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeElectriccontroller:
		if id := m.electriccontroller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeLayers:
		ids := make([]ent.Value, 0, len(m.layers))
		for id := range m.layers {
			ids = append(ids, id)
		}
		return ids
	case jobdetail.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedlayers != nil {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	if m.removedpayments != nil {
		edges = append(edges, jobdetail.EdgePayments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobdetail.EdgeLayers:
		ids := make([]ent.Value, 0, len(m.removedlayers))
		for id := range m.removedlayers {
			ids = append(ids, id)
		}
		return ids
	case jobdetail.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedowner {
		edges = append(edges, jobdetail.EdgeOwner)
	}
	if m.clearedauthor {
		edges = append(edges, jobdetail.EdgeAuthor)
	}
	if m.clearedcompany {
		edges = append(edges, jobdetail.EdgeCompany)
	}
	if m.clearedprogress {
		edges = append(edges, jobdetail.EdgeProgress)
	}
	if m.clearedcontractor {
		edges = append(edges, jobdetail.EdgeContractor)
	}
	if m.clearedsupervisor {
		edges = append(edges, jobdetail.EdgeSupervisor)
	}
	if m.clearedstatic {
		edges = append(edges, jobdetail.EdgeStatic)
	}
	if m.clearedmechanic {
		edges = append(edges, jobdetail.EdgeMechanic)
	}
	if m.clearedelectric {
		edges = append(edges, jobdetail.EdgeElectric)
	}
	if m.clearedinspector {
		edges = append(edges, jobdetail.EdgeInspector)
	}
	if m.clearedarchitect {
		edges = append(edges, jobdetail.EdgeArchitect)
	}
	if m.clearedcontroller {
		edges = append(edges, jobdetail.EdgeController)
	}
	if m.clearedmechaniccontroller {
		edges = append(edges, jobdetail.EdgeMechaniccontroller)
	}
	if m.clearedelectriccontroller {
		edges = append(edges, jobdetail.EdgeElectriccontroller)
	}
	if m.clearedlayers {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	if m.clearedpayments {
		edges = append(edges, jobdetail.EdgePayments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case jobdetail.EdgeOwner:
		return m.clearedowner
	case jobdetail.EdgeAuthor:
		return m.clearedauthor
	case jobdetail.EdgeCompany:
		return m.clearedcompany
	case jobdetail.EdgeProgress:
		return m.clearedprogress
	case jobdetail.EdgeContractor:
		return m.clearedcontractor
	case jobdetail.EdgeSupervisor:
		return m.clearedsupervisor
	case jobdetail.EdgeStatic:
		return m.clearedstatic
	case jobdetail.EdgeMechanic:
		return m.clearedmechanic
	case jobdetail.EdgeElectric:
		return m.clearedelectric
	case jobdetail.EdgeInspector:
		return m.clearedinspector
	case jobdetail.EdgeArchitect:
		return m.clearedarchitect
	case jobdetail.EdgeController:
		return m.clearedcontroller
	case jobdetail.EdgeMechaniccontroller:
		return m.clearedmechaniccontroller
	case jobdetail.EdgeElectriccontroller:
		return m.clearedelectriccontroller
	case jobdetail.EdgeLayers:
		return m.clearedlayers
	case jobdetail.EdgePayments:
		return m.clearedpayments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobDetailMutation) ClearEdge(name string) error {
	switch name {
	case jobdetail.EdgeOwner:
		m.ClearOwner()
		return nil
	case jobdetail.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case jobdetail.EdgeCompany:
		m.ClearCompany()
		return nil
	case jobdetail.EdgeProgress:
		m.ClearProgress()
		return nil
	case jobdetail.EdgeContractor:
		m.ClearContractor()
		return nil
	case jobdetail.EdgeSupervisor:
		m.ClearSupervisor()
		return nil
	case jobdetail.EdgeStatic:
		m.ClearStatic()
		return nil
	case jobdetail.EdgeMechanic:
		m.ClearMechanic()
		return nil
	case jobdetail.EdgeElectric:
		m.ClearElectric()
		return nil
	case jobdetail.EdgeInspector:
		m.ClearInspector()
		return nil
	case jobdetail.EdgeArchitect:
		m.ClearArchitect()
		return nil
	case jobdetail.EdgeController:
		m.ClearController()
		return nil
	case jobdetail.EdgeMechaniccontroller:
		m.ClearMechaniccontroller()
		return nil
	case jobdetail.EdgeElectriccontroller:
		m.ClearElectriccontroller()
		return nil
	}
	return fmt.Errorf("unknown JobDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobDetailMutation) ResetEdge(name string) error {
	switch name {
	case jobdetail.EdgeOwner:
		m.ResetOwner()
		return nil
	case jobdetail.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case jobdetail.EdgeCompany:
		m.ResetCompany()
		return nil
	case jobdetail.EdgeProgress:
		m.ResetProgress()
		return nil
	case jobdetail.EdgeContractor:
		m.ResetContractor()
		return nil
	case jobdetail.EdgeSupervisor:
		m.ResetSupervisor()
		return nil
	case jobdetail.EdgeStatic:
		m.ResetStatic()
		return nil
	case jobdetail.EdgeMechanic:
		m.ResetMechanic()
		return nil
	case jobdetail.EdgeElectric:
		m.ResetElectric()
		return nil
	case jobdetail.EdgeInspector:
		m.ResetInspector()
		return nil
	case jobdetail.EdgeArchitect:
		m.ResetArchitect()
		return nil
	case jobdetail.EdgeController:
		m.ResetController()
		return nil
	case jobdetail.EdgeMechaniccontroller:
		m.ResetMechaniccontroller()
		return nil
	case jobdetail.EdgeElectriccontroller:
		m.ResetElectriccontroller()
		return nil
	case jobdetail.EdgeLayers:
		m.ResetLayers()
		return nil
	case jobdetail.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown JobDetail edge %s", name)
}

// JobLayerMutation represents an operation that mutates the JobLayer nodes in the graph.
type JobLayerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Name          *string
	_Metre         *string
	_MoldDate      *time.Time
	_ConcreteDate  *time.Time
	_Samples       *int
	add_Samples    *int
	_ConcreteClass *string
	_WeekResult    *string
	_MonthResult   *string
	_CreatedAt     *time.Time
	_UpdatedAt     *time.Time
	clearedFields  map[string]struct{}
	layer          *int
	clearedlayer   bool
	done           bool
	oldValue       func(context.Context) (*JobLayer, error)
	predicates     []predicate.JobLayer
}

var _ ent.Mutation = (*JobLayerMutation)(nil)

// joblayerOption allows management of the mutation configuration using functional options.
type joblayerOption func(*JobLayerMutation)

// newJobLayerMutation creates new mutation for the JobLayer entity.
func newJobLayerMutation(c config, op Op, opts ...joblayerOption) *JobLayerMutation {
	m := &JobLayerMutation{
		config:        c,
		op:            op,
		typ:           TypeJobLayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobLayerID sets the ID field of the mutation.
func withJobLayerID(id int) joblayerOption {
	return func(m *JobLayerMutation) {
		var (
			err   error
			once  sync.Once
			value *JobLayer
		)
		m.oldValue = func(ctx context.Context) (*JobLayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobLayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobLayer sets the old JobLayer of the mutation.
func withJobLayer(node *JobLayer) joblayerOption {
	return func(m *JobLayerMutation) {
		m.oldValue = func(context.Context) (*JobLayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobLayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobLayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobLayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobLayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobLayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobLayerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobLayerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobLayerMutation) ResetName() {
	m._Name = nil
}

// SetMetre sets the "Metre" field.
func (m *JobLayerMutation) SetMetre(s string) {
	m._Metre = &s
}

// Metre returns the value of the "Metre" field in the mutation.
func (m *JobLayerMutation) Metre() (r string, exists bool) {
	v := m._Metre
	if v == nil {
		return
	}
	return *v, true
}

// OldMetre returns the old "Metre" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMetre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetre: %w", err)
	}
	return oldValue.Metre, nil
}

// ResetMetre resets all changes to the "Metre" field.
func (m *JobLayerMutation) ResetMetre() {
	m._Metre = nil
}

// SetMoldDate sets the "MoldDate" field.
func (m *JobLayerMutation) SetMoldDate(t time.Time) {
	m._MoldDate = &t
}

// MoldDate returns the value of the "MoldDate" field in the mutation.
func (m *JobLayerMutation) MoldDate() (r time.Time, exists bool) {
	v := m._MoldDate
	if v == nil {
		return
	}
	return *v, true
}

// OldMoldDate returns the old "MoldDate" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMoldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoldDate: %w", err)
	}
	return oldValue.MoldDate, nil
}

// ClearMoldDate clears the value of the "MoldDate" field.
func (m *JobLayerMutation) ClearMoldDate() {
	m._MoldDate = nil
	m.clearedFields[joblayer.FieldMoldDate] = struct{}{}
}

// MoldDateCleared returns if the "MoldDate" field was cleared in this mutation.
func (m *JobLayerMutation) MoldDateCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldMoldDate]
	return ok
}

// ResetMoldDate resets all changes to the "MoldDate" field.
func (m *JobLayerMutation) ResetMoldDate() {
	m._MoldDate = nil
	delete(m.clearedFields, joblayer.FieldMoldDate)
}

// SetConcreteDate sets the "ConcreteDate" field.
func (m *JobLayerMutation) SetConcreteDate(t time.Time) {
	m._ConcreteDate = &t
}

// ConcreteDate returns the value of the "ConcreteDate" field in the mutation.
func (m *JobLayerMutation) ConcreteDate() (r time.Time, exists bool) {
	v := m._ConcreteDate
	if v == nil {
		return
	}
	return *v, true
}

// OldConcreteDate returns the old "ConcreteDate" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldConcreteDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcreteDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcreteDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcreteDate: %w", err)
	}
	return oldValue.ConcreteDate, nil
}

// ClearConcreteDate clears the value of the "ConcreteDate" field.
func (m *JobLayerMutation) ClearConcreteDate() {
	m._ConcreteDate = nil
	m.clearedFields[joblayer.FieldConcreteDate] = struct{}{}
}

// ConcreteDateCleared returns if the "ConcreteDate" field was cleared in this mutation.
func (m *JobLayerMutation) ConcreteDateCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldConcreteDate]
	return ok
}

// ResetConcreteDate resets all changes to the "ConcreteDate" field.
func (m *JobLayerMutation) ResetConcreteDate() {
	m._ConcreteDate = nil
	delete(m.clearedFields, joblayer.FieldConcreteDate)
}

// SetSamples sets the "Samples" field.
func (m *JobLayerMutation) SetSamples(i int) {
	m._Samples = &i
	m.add_Samples = nil
}

// Samples returns the value of the "Samples" field in the mutation.
func (m *JobLayerMutation) Samples() (r int, exists bool) {
	v := m._Samples
	if v == nil {
		return
	}
	return *v, true
}

// OldSamples returns the old "Samples" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldSamples(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSamples is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSamples requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSamples: %w", err)
	}
	return oldValue.Samples, nil
}

// AddSamples adds i to the "Samples" field.
func (m *JobLayerMutation) AddSamples(i int) {
	if m.add_Samples != nil {
		*m.add_Samples += i
	} else {
		m.add_Samples = &i
	}
}

// AddedSamples returns the value that was added to the "Samples" field in this mutation.
func (m *JobLayerMutation) AddedSamples() (r int, exists bool) {
	v := m.add_Samples
	if v == nil {
		return
	}
	return *v, true
}

// ClearSamples clears the value of the "Samples" field.
func (m *JobLayerMutation) ClearSamples() {
	m._Samples = nil
	m.add_Samples = nil
	m.clearedFields[joblayer.FieldSamples] = struct{}{}
}

// SamplesCleared returns if the "Samples" field was cleared in this mutation.
func (m *JobLayerMutation) SamplesCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldSamples]
	return ok
}

// ResetSamples resets all changes to the "Samples" field.
func (m *JobLayerMutation) ResetSamples() {
	m._Samples = nil
	m.add_Samples = nil
	delete(m.clearedFields, joblayer.FieldSamples)
}

// SetConcreteClass sets the "ConcreteClass" field.
func (m *JobLayerMutation) SetConcreteClass(s string) {
	m._ConcreteClass = &s
}

// ConcreteClass returns the value of the "ConcreteClass" field in the mutation.
func (m *JobLayerMutation) ConcreteClass() (r string, exists bool) {
	v := m._ConcreteClass
	if v == nil {
		return
	}
	return *v, true
}

// OldConcreteClass returns the old "ConcreteClass" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldConcreteClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcreteClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcreteClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcreteClass: %w", err)
	}
	return oldValue.ConcreteClass, nil
}

// ClearConcreteClass clears the value of the "ConcreteClass" field.
func (m *JobLayerMutation) ClearConcreteClass() {
	m._ConcreteClass = nil
	m.clearedFields[joblayer.FieldConcreteClass] = struct{}{}
}

// ConcreteClassCleared returns if the "ConcreteClass" field was cleared in this mutation.
func (m *JobLayerMutation) ConcreteClassCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldConcreteClass]
	return ok
}

// ResetConcreteClass resets all changes to the "ConcreteClass" field.
func (m *JobLayerMutation) ResetConcreteClass() {
	m._ConcreteClass = nil
	delete(m.clearedFields, joblayer.FieldConcreteClass)
}

// SetWeekResult sets the "WeekResult" field.
func (m *JobLayerMutation) SetWeekResult(s string) {
	m._WeekResult = &s
}

// WeekResult returns the value of the "WeekResult" field in the mutation.
func (m *JobLayerMutation) WeekResult() (r string, exists bool) {
	v := m._WeekResult
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekResult returns the old "WeekResult" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldWeekResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekResult: %w", err)
	}
	return oldValue.WeekResult, nil
}

// ClearWeekResult clears the value of the "WeekResult" field.
func (m *JobLayerMutation) ClearWeekResult() {
	m._WeekResult = nil
	m.clearedFields[joblayer.FieldWeekResult] = struct{}{}
}

// WeekResultCleared returns if the "WeekResult" field was cleared in this mutation.
func (m *JobLayerMutation) WeekResultCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldWeekResult]
	return ok
}

// ResetWeekResult resets all changes to the "WeekResult" field.
func (m *JobLayerMutation) ResetWeekResult() {
	m._WeekResult = nil
	delete(m.clearedFields, joblayer.FieldWeekResult)
}

// SetMonthResult sets the "MonthResult" field.
func (m *JobLayerMutation) SetMonthResult(s string) {
	m._MonthResult = &s
}

// MonthResult returns the value of the "MonthResult" field in the mutation.
func (m *JobLayerMutation) MonthResult() (r string, exists bool) {
	v := m._MonthResult
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthResult returns the old "MonthResult" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMonthResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthResult: %w", err)
	}
	return oldValue.MonthResult, nil
}

// ClearMonthResult clears the value of the "MonthResult" field.
func (m *JobLayerMutation) ClearMonthResult() {
	m._MonthResult = nil
	m.clearedFields[joblayer.FieldMonthResult] = struct{}{}
}

// MonthResultCleared returns if the "MonthResult" field was cleared in this mutation.
func (m *JobLayerMutation) MonthResultCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldMonthResult]
	return ok
}

// ResetMonthResult resets all changes to the "MonthResult" field.
func (m *JobLayerMutation) ResetMonthResult() {
	m._MonthResult = nil
	delete(m.clearedFields, joblayer.FieldMonthResult)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobLayerMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobLayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobLayerMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobLayerMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobLayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobLayerMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetLayerID sets the "layer" edge to the JobDetail entity by id.
func (m *JobLayerMutation) SetLayerID(id int) {
	m.layer = &id
}

// ClearLayer clears the "layer" edge to the JobDetail entity.
func (m *JobLayerMutation) ClearLayer() {
	m.clearedlayer = true
}

// LayerCleared reports if the "layer" edge to the JobDetail entity was cleared.
func (m *JobLayerMutation) LayerCleared() bool {
	return m.clearedlayer
}

// LayerID returns the "layer" edge ID in the mutation.
func (m *JobLayerMutation) LayerID() (id int, exists bool) {
	if m.layer != nil {
		return *m.layer, true
	}
	return
}

// LayerIDs returns the "layer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LayerID instead. It exists only for internal usage by the builders.
func (m *JobLayerMutation) LayerIDs() (ids []int) {
	if id := m.layer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLayer resets all changes to the "layer" edge.
func (m *JobLayerMutation) ResetLayer() {
	m.layer = nil
	m.clearedlayer = false
}

// Where appends a list predicates to the JobLayerMutation builder.
func (m *JobLayerMutation) Where(ps ...predicate.JobLayer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobLayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobLayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobLayer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobLayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobLayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobLayer).
func (m *JobLayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobLayerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._Name != nil {
		fields = append(fields, joblayer.FieldName)
	}
	if m._Metre != nil {
		fields = append(fields, joblayer.FieldMetre)
	}
	if m._MoldDate != nil {
		fields = append(fields, joblayer.FieldMoldDate)
	}
	if m._ConcreteDate != nil {
		fields = append(fields, joblayer.FieldConcreteDate)
	}
	if m._Samples != nil {
		fields = append(fields, joblayer.FieldSamples)
	}
	if m._ConcreteClass != nil {
		fields = append(fields, joblayer.FieldConcreteClass)
	}
	if m._WeekResult != nil {
		fields = append(fields, joblayer.FieldWeekResult)
	}
	if m._MonthResult != nil {
		fields = append(fields, joblayer.FieldMonthResult)
	}
	if m._CreatedAt != nil {
		fields = append(fields, joblayer.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, joblayer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobLayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joblayer.FieldName:
		return m.Name()
	case joblayer.FieldMetre:
		return m.Metre()
	case joblayer.FieldMoldDate:
		return m.MoldDate()
	case joblayer.FieldConcreteDate:
		return m.ConcreteDate()
	case joblayer.FieldSamples:
		return m.Samples()
	case joblayer.FieldConcreteClass:
		return m.ConcreteClass()
	case joblayer.FieldWeekResult:
		return m.WeekResult()
	case joblayer.FieldMonthResult:
		return m.MonthResult()
	case joblayer.FieldCreatedAt:
		return m.CreatedAt()
	case joblayer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobLayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joblayer.FieldName:
		return m.OldName(ctx)
	case joblayer.FieldMetre:
		return m.OldMetre(ctx)
	case joblayer.FieldMoldDate:
		return m.OldMoldDate(ctx)
	case joblayer.FieldConcreteDate:
		return m.OldConcreteDate(ctx)
	case joblayer.FieldSamples:
		return m.OldSamples(ctx)
	case joblayer.FieldConcreteClass:
		return m.OldConcreteClass(ctx)
	case joblayer.FieldWeekResult:
		return m.OldWeekResult(ctx)
	case joblayer.FieldMonthResult:
		return m.OldMonthResult(ctx)
	case joblayer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case joblayer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobLayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joblayer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case joblayer.FieldMetre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetre(v)
		return nil
	case joblayer.FieldMoldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoldDate(v)
		return nil
	case joblayer.FieldConcreteDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcreteDate(v)
		return nil
	case joblayer.FieldSamples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSamples(v)
		return nil
	case joblayer.FieldConcreteClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcreteClass(v)
		return nil
	case joblayer.FieldWeekResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekResult(v)
		return nil
	case joblayer.FieldMonthResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthResult(v)
		return nil
	case joblayer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case joblayer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobLayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobLayerMutation) AddedFields() []string {
	var fields []string
	if m.add_Samples != nil {
		fields = append(fields, joblayer.FieldSamples)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobLayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case joblayer.FieldSamples:
		return m.AddedSamples()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case joblayer.FieldSamples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSamples(v)
		return nil
	}
	return fmt.Errorf("unknown JobLayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobLayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joblayer.FieldMoldDate) {
		fields = append(fields, joblayer.FieldMoldDate)
	}
	if m.FieldCleared(joblayer.FieldConcreteDate) {
		fields = append(fields, joblayer.FieldConcreteDate)
	}
	if m.FieldCleared(joblayer.FieldSamples) {
		fields = append(fields, joblayer.FieldSamples)
	}
	if m.FieldCleared(joblayer.FieldConcreteClass) {
		fields = append(fields, joblayer.FieldConcreteClass)
	}
	if m.FieldCleared(joblayer.FieldWeekResult) {
		fields = append(fields, joblayer.FieldWeekResult)
	}
	if m.FieldCleared(joblayer.FieldMonthResult) {
		fields = append(fields, joblayer.FieldMonthResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobLayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobLayerMutation) ClearField(name string) error {
	switch name {
	case joblayer.FieldMoldDate:
		m.ClearMoldDate()
		return nil
	case joblayer.FieldConcreteDate:
		m.ClearConcreteDate()
		return nil
	case joblayer.FieldSamples:
		m.ClearSamples()
		return nil
	case joblayer.FieldConcreteClass:
		m.ClearConcreteClass()
		return nil
	case joblayer.FieldWeekResult:
		m.ClearWeekResult()
		return nil
	case joblayer.FieldMonthResult:
		m.ClearMonthResult()
		return nil
	}
	return fmt.Errorf("unknown JobLayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobLayerMutation) ResetField(name string) error {
	switch name {
	case joblayer.FieldName:
		m.ResetName()
		return nil
	case joblayer.FieldMetre:
		m.ResetMetre()
		return nil
	case joblayer.FieldMoldDate:
		m.ResetMoldDate()
		return nil
	case joblayer.FieldConcreteDate:
		m.ResetConcreteDate()
		return nil
	case joblayer.FieldSamples:
		m.ResetSamples()
		return nil
	case joblayer.FieldConcreteClass:
		m.ResetConcreteClass()
		return nil
	case joblayer.FieldWeekResult:
		m.ResetWeekResult()
		return nil
	case joblayer.FieldMonthResult:
		m.ResetMonthResult()
		return nil
	case joblayer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case joblayer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobLayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobLayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.layer != nil {
		edges = append(edges, joblayer.EdgeLayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobLayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joblayer.EdgeLayer:
		if id := m.layer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobLayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobLayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobLayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlayer {
		edges = append(edges, joblayer.EdgeLayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobLayerMutation) EdgeCleared(name string) bool {
	switch name {
	case joblayer.EdgeLayer:
		return m.clearedlayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobLayerMutation) ClearEdge(name string) error {
	switch name {
	case joblayer.EdgeLayer:
		m.ClearLayer()
		return nil
	}
	return fmt.Errorf("unknown JobLayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobLayerMutation) ResetEdge(name string) error {
	switch name {
	case joblayer.EdgeLayer:
		m.ResetLayer()
		return nil
	}
	return fmt.Errorf("unknown JobLayer edge %s", name)
}

// JobOwnerMutation represents an operation that mutates the JobOwner nodes in the graph.
type JobOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_Address      *string
	_TcNo         *int
	add_TcNo      *int
	_TaxAdmin     *string
	_TaxNo        *int
	add_TaxNo     *int
	_Phone        *string
	_Email        *string
	_YDSID        *int
	add_YDSID     *int
	_Shareholder  *bool
	_Note         *string
	_CreatedAt    *time.Time
	_UpdatedAt    *time.Time
	clearedFields map[string]struct{}
	owners        map[int]struct{}
	removedowners map[int]struct{}
	clearedowners bool
	done          bool
	oldValue      func(context.Context) (*JobOwner, error)
	predicates    []predicate.JobOwner
}

var _ ent.Mutation = (*JobOwnerMutation)(nil)

// jobownerOption allows management of the mutation configuration using functional options.
type jobownerOption func(*JobOwnerMutation)

// newJobOwnerMutation creates new mutation for the JobOwner entity.
func newJobOwnerMutation(c config, op Op, opts ...jobownerOption) *JobOwnerMutation {
	m := &JobOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeJobOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobOwnerID sets the ID field of the mutation.
func withJobOwnerID(id int) jobownerOption {
	return func(m *JobOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *JobOwner
		)
		m.oldValue = func(ctx context.Context) (*JobOwner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobOwner sets the old JobOwner of the mutation.
func withJobOwner(node *JobOwner) jobownerOption {
	return func(m *JobOwnerMutation) {
		m.oldValue = func(context.Context) (*JobOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobOwnerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobOwnerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobOwner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobOwnerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobOwnerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobOwnerMutation) ResetName() {
	m._Name = nil
}

// SetAddress sets the "Address" field.
func (m *JobOwnerMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobOwnerMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobOwnerMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobowner.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobOwnerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobOwnerMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobowner.FieldAddress)
}

// SetTcNo sets the "TcNo" field.
func (m *JobOwnerMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *JobOwnerMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *JobOwnerMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *JobOwnerMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *JobOwnerMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[jobowner.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *JobOwnerMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *JobOwnerMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, jobowner.FieldTcNo)
}

// SetTaxAdmin sets the "TaxAdmin" field.
func (m *JobOwnerMutation) SetTaxAdmin(s string) {
	m._TaxAdmin = &s
}

// TaxAdmin returns the value of the "TaxAdmin" field in the mutation.
func (m *JobOwnerMutation) TaxAdmin() (r string, exists bool) {
	v := m._TaxAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAdmin returns the old "TaxAdmin" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTaxAdmin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAdmin: %w", err)
	}
	return oldValue.TaxAdmin, nil
}

// ClearTaxAdmin clears the value of the "TaxAdmin" field.
func (m *JobOwnerMutation) ClearTaxAdmin() {
	m._TaxAdmin = nil
	m.clearedFields[jobowner.FieldTaxAdmin] = struct{}{}
}

// TaxAdminCleared returns if the "TaxAdmin" field was cleared in this mutation.
func (m *JobOwnerMutation) TaxAdminCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTaxAdmin]
	return ok
}

// ResetTaxAdmin resets all changes to the "TaxAdmin" field.
func (m *JobOwnerMutation) ResetTaxAdmin() {
	m._TaxAdmin = nil
	delete(m.clearedFields, jobowner.FieldTaxAdmin)
}

// SetTaxNo sets the "TaxNo" field.
func (m *JobOwnerMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *JobOwnerMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *JobOwnerMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *JobOwnerMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *JobOwnerMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[jobowner.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *JobOwnerMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *JobOwnerMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, jobowner.FieldTaxNo)
}

// SetPhone sets the "Phone" field.
func (m *JobOwnerMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *JobOwnerMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *JobOwnerMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[jobowner.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *JobOwnerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *JobOwnerMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, jobowner.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *JobOwnerMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *JobOwnerMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *JobOwnerMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[jobowner.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *JobOwnerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *JobOwnerMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, jobowner.FieldEmail)
}

// SetYDSID sets the "YDSID" field.
func (m *JobOwnerMutation) SetYDSID(i int) {
	m._YDSID = &i
	m.add_YDSID = nil
}

// YDSID returns the value of the "YDSID" field in the mutation.
func (m *JobOwnerMutation) YDSID() (r int, exists bool) {
	v := m._YDSID
	if v == nil {
		return
	}
	return *v, true
}

// OldYDSID returns the old "YDSID" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldYDSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYDSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYDSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYDSID: %w", err)
	}
	return oldValue.YDSID, nil
}

// AddYDSID adds i to the "YDSID" field.
func (m *JobOwnerMutation) AddYDSID(i int) {
	if m.add_YDSID != nil {
		*m.add_YDSID += i
	} else {
		m.add_YDSID = &i
	}
}

// AddedYDSID returns the value that was added to the "YDSID" field in this mutation.
func (m *JobOwnerMutation) AddedYDSID() (r int, exists bool) {
	v := m.add_YDSID
	if v == nil {
		return
	}
	return *v, true
}

// ClearYDSID clears the value of the "YDSID" field.
func (m *JobOwnerMutation) ClearYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	m.clearedFields[jobowner.FieldYDSID] = struct{}{}
}

// YDSIDCleared returns if the "YDSID" field was cleared in this mutation.
func (m *JobOwnerMutation) YDSIDCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldYDSID]
	return ok
}

// ResetYDSID resets all changes to the "YDSID" field.
func (m *JobOwnerMutation) ResetYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	delete(m.clearedFields, jobowner.FieldYDSID)
}

// SetShareholder sets the "Shareholder" field.
func (m *JobOwnerMutation) SetShareholder(b bool) {
	m._Shareholder = &b
}

// Shareholder returns the value of the "Shareholder" field in the mutation.
func (m *JobOwnerMutation) Shareholder() (r bool, exists bool) {
	v := m._Shareholder
	if v == nil {
		return
	}
	return *v, true
}

// OldShareholder returns the old "Shareholder" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldShareholder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShareholder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShareholder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShareholder: %w", err)
	}
	return oldValue.Shareholder, nil
}

// ResetShareholder resets all changes to the "Shareholder" field.
func (m *JobOwnerMutation) ResetShareholder() {
	m._Shareholder = nil
}

// SetNote sets the "Note" field.
func (m *JobOwnerMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobOwnerMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobOwnerMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobowner.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobOwnerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobOwnerMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobowner.FieldNote)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobOwnerMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobOwnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobOwnerMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobOwnerMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobOwnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobOwnerMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddOwnerIDs adds the "owners" edge to the JobDetail entity by ids.
func (m *JobOwnerMutation) AddOwnerIDs(ids ...int) {
	if m.owners == nil {
		m.owners = make(map[int]struct{})
	}
	for i := range ids {
		m.owners[ids[i]] = struct{}{}
	}
}

// ClearOwners clears the "owners" edge to the JobDetail entity.
func (m *JobOwnerMutation) ClearOwners() {
	m.clearedowners = true
}

// OwnersCleared reports if the "owners" edge to the JobDetail entity was cleared.
func (m *JobOwnerMutation) OwnersCleared() bool {
	return m.clearedowners
}

// RemoveOwnerIDs removes the "owners" edge to the JobDetail entity by IDs.
func (m *JobOwnerMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowners == nil {
		m.removedowners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owners, ids[i])
		m.removedowners[ids[i]] = struct{}{}
	}
}

// RemovedOwners returns the removed IDs of the "owners" edge to the JobDetail entity.
func (m *JobOwnerMutation) RemovedOwnersIDs() (ids []int) {
	for id := range m.removedowners {
		ids = append(ids, id)
	}
	return
}

// OwnersIDs returns the "owners" edge IDs in the mutation.
func (m *JobOwnerMutation) OwnersIDs() (ids []int) {
	for id := range m.owners {
		ids = append(ids, id)
	}
	return
}

// ResetOwners resets all changes to the "owners" edge.
func (m *JobOwnerMutation) ResetOwners() {
	m.owners = nil
	m.clearedowners = false
	m.removedowners = nil
}

// Where appends a list predicates to the JobOwnerMutation builder.
func (m *JobOwnerMutation) Where(ps ...predicate.JobOwner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobOwnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobOwnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobOwner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobOwnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobOwnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobOwner).
func (m *JobOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobOwnerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._Name != nil {
		fields = append(fields, jobowner.FieldName)
	}
	if m._Address != nil {
		fields = append(fields, jobowner.FieldAddress)
	}
	if m._TcNo != nil {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m._TaxAdmin != nil {
		fields = append(fields, jobowner.FieldTaxAdmin)
	}
	if m._TaxNo != nil {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	if m._Phone != nil {
		fields = append(fields, jobowner.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, jobowner.FieldEmail)
	}
	if m._YDSID != nil {
		fields = append(fields, jobowner.FieldYDSID)
	}
	if m._Shareholder != nil {
		fields = append(fields, jobowner.FieldShareholder)
	}
	if m._Note != nil {
		fields = append(fields, jobowner.FieldNote)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobowner.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobowner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobowner.FieldName:
		return m.Name()
	case jobowner.FieldAddress:
		return m.Address()
	case jobowner.FieldTcNo:
		return m.TcNo()
	case jobowner.FieldTaxAdmin:
		return m.TaxAdmin()
	case jobowner.FieldTaxNo:
		return m.TaxNo()
	case jobowner.FieldPhone:
		return m.Phone()
	case jobowner.FieldEmail:
		return m.Email()
	case jobowner.FieldYDSID:
		return m.YDSID()
	case jobowner.FieldShareholder:
		return m.Shareholder()
	case jobowner.FieldNote:
		return m.Note()
	case jobowner.FieldCreatedAt:
		return m.CreatedAt()
	case jobowner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobowner.FieldName:
		return m.OldName(ctx)
	case jobowner.FieldAddress:
		return m.OldAddress(ctx)
	case jobowner.FieldTcNo:
		return m.OldTcNo(ctx)
	case jobowner.FieldTaxAdmin:
		return m.OldTaxAdmin(ctx)
	case jobowner.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case jobowner.FieldPhone:
		return m.OldPhone(ctx)
	case jobowner.FieldEmail:
		return m.OldEmail(ctx)
	case jobowner.FieldYDSID:
		return m.OldYDSID(ctx)
	case jobowner.FieldShareholder:
		return m.OldShareholder(ctx)
	case jobowner.FieldNote:
		return m.OldNote(ctx)
	case jobowner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobowner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobOwner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobowner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobowner.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobowner.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case jobowner.FieldTaxAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAdmin(v)
		return nil
	case jobowner.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case jobowner.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case jobowner.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case jobowner.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYDSID(v)
		return nil
	case jobowner.FieldShareholder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShareholder(v)
		return nil
	case jobowner.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobowner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobowner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobOwnerMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	if m.add_YDSID != nil {
		fields = append(fields, jobowner.FieldYDSID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobOwnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobowner.FieldTcNo:
		return m.AddedTcNo()
	case jobowner.FieldTaxNo:
		return m.AddedTaxNo()
	case jobowner.FieldYDSID:
		return m.AddedYDSID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobowner.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case jobowner.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	case jobowner.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYDSID(v)
		return nil
	}
	return fmt.Errorf("unknown JobOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobOwnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobowner.FieldAddress) {
		fields = append(fields, jobowner.FieldAddress)
	}
	if m.FieldCleared(jobowner.FieldTcNo) {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m.FieldCleared(jobowner.FieldTaxAdmin) {
		fields = append(fields, jobowner.FieldTaxAdmin)
	}
	if m.FieldCleared(jobowner.FieldTaxNo) {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	if m.FieldCleared(jobowner.FieldPhone) {
		fields = append(fields, jobowner.FieldPhone)
	}
	if m.FieldCleared(jobowner.FieldEmail) {
		fields = append(fields, jobowner.FieldEmail)
	}
	if m.FieldCleared(jobowner.FieldYDSID) {
		fields = append(fields, jobowner.FieldYDSID)
	}
	if m.FieldCleared(jobowner.FieldNote) {
		fields = append(fields, jobowner.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobOwnerMutation) ClearField(name string) error {
	switch name {
	case jobowner.FieldAddress:
		m.ClearAddress()
		return nil
	case jobowner.FieldTcNo:
		m.ClearTcNo()
		return nil
	case jobowner.FieldTaxAdmin:
		m.ClearTaxAdmin()
		return nil
	case jobowner.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case jobowner.FieldPhone:
		m.ClearPhone()
		return nil
	case jobowner.FieldEmail:
		m.ClearEmail()
		return nil
	case jobowner.FieldYDSID:
		m.ClearYDSID()
		return nil
	case jobowner.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobOwnerMutation) ResetField(name string) error {
	switch name {
	case jobowner.FieldName:
		m.ResetName()
		return nil
	case jobowner.FieldAddress:
		m.ResetAddress()
		return nil
	case jobowner.FieldTcNo:
		m.ResetTcNo()
		return nil
	case jobowner.FieldTaxAdmin:
		m.ResetTaxAdmin()
		return nil
	case jobowner.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case jobowner.FieldPhone:
		m.ResetPhone()
		return nil
	case jobowner.FieldEmail:
		m.ResetEmail()
		return nil
	case jobowner.FieldYDSID:
		m.ResetYDSID()
		return nil
	case jobowner.FieldShareholder:
		m.ResetShareholder()
		return nil
	case jobowner.FieldNote:
		m.ResetNote()
		return nil
	case jobowner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobowner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owners != nil {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobOwnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobowner.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.owners))
		for id := range m.owners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedowners != nil {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobOwnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobowner.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.removedowners))
		for id := range m.removedowners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowners {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobOwnerMutation) EdgeCleared(name string) bool {
	switch name {
	case jobowner.EdgeOwners:
		return m.clearedowners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobOwnerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobOwner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobOwnerMutation) ResetEdge(name string) error {
	switch name {
	case jobowner.EdgeOwners:
		m.ResetOwners()
		return nil
	}
	return fmt.Errorf("unknown JobOwner edge %s", name)
}

// JobPaymentsMutation represents an operation that mutates the JobPayments nodes in the graph.
type JobPaymentsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_Date           *time.Time
	_Amount         *int
	add_Amount      *int
	_Description    *string
	_Status         *string
	_Percentage     *float64
	add_Percentage  *float64
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	payments        *int
	clearedpayments bool
	done            bool
	oldValue        func(context.Context) (*JobPayments, error)
	predicates      []predicate.JobPayments
}

var _ ent.Mutation = (*JobPaymentsMutation)(nil)

// jobpaymentsOption allows management of the mutation configuration using functional options.
type jobpaymentsOption func(*JobPaymentsMutation)

// newJobPaymentsMutation creates new mutation for the JobPayments entity.
func newJobPaymentsMutation(c config, op Op, opts ...jobpaymentsOption) *JobPaymentsMutation {
	m := &JobPaymentsMutation{
		config:        c,
		op:            op,
		typ:           TypeJobPayments,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobPaymentsID sets the ID field of the mutation.
func withJobPaymentsID(id int) jobpaymentsOption {
	return func(m *JobPaymentsMutation) {
		var (
			err   error
			once  sync.Once
			value *JobPayments
		)
		m.oldValue = func(ctx context.Context) (*JobPayments, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobPayments.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobPayments sets the old JobPayments of the mutation.
func withJobPayments(node *JobPayments) jobpaymentsOption {
	return func(m *JobPaymentsMutation) {
		m.oldValue = func(context.Context) (*JobPayments, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobPaymentsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobPaymentsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobPaymentsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobPaymentsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobPayments.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDate sets the "Date" field.
func (m *JobPaymentsMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the value of the "Date" field in the mutation.
func (m *JobPaymentsMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "Date" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "Date" field.
func (m *JobPaymentsMutation) ResetDate() {
	m._Date = nil
}

// SetAmount sets the "Amount" field.
func (m *JobPaymentsMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the value of the "Amount" field in the mutation.
func (m *JobPaymentsMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "Amount" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "Amount" field.
func (m *JobPaymentsMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the "Amount" field in this mutation.
func (m *JobPaymentsMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "Amount" field.
func (m *JobPaymentsMutation) ClearAmount() {
	m._Amount = nil
	m.add_Amount = nil
	m.clearedFields[jobpayments.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "Amount" field was cleared in this mutation.
func (m *JobPaymentsMutation) AmountCleared() bool {
	_, ok := m.clearedFields[jobpayments.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "Amount" field.
func (m *JobPaymentsMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
	delete(m.clearedFields, jobpayments.FieldAmount)
}

// SetDescription sets the "Description" field.
func (m *JobPaymentsMutation) SetDescription(s string) {
	m._Description = &s
}

// Description returns the value of the "Description" field in the mutation.
func (m *JobPaymentsMutation) Description() (r string, exists bool) {
	v := m._Description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "Description" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "Description" field.
func (m *JobPaymentsMutation) ClearDescription() {
	m._Description = nil
	m.clearedFields[jobpayments.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "Description" field was cleared in this mutation.
func (m *JobPaymentsMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[jobpayments.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "Description" field.
func (m *JobPaymentsMutation) ResetDescription() {
	m._Description = nil
	delete(m.clearedFields, jobpayments.FieldDescription)
}

// SetStatus sets the "Status" field.
func (m *JobPaymentsMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *JobPaymentsMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *JobPaymentsMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[jobpayments.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *JobPaymentsMutation) StatusCleared() bool {
	_, ok := m.clearedFields[jobpayments.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *JobPaymentsMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, jobpayments.FieldStatus)
}

// SetPercentage sets the "Percentage" field.
func (m *JobPaymentsMutation) SetPercentage(f float64) {
	m._Percentage = &f
	m.add_Percentage = nil
}

// Percentage returns the value of the "Percentage" field in the mutation.
func (m *JobPaymentsMutation) Percentage() (r float64, exists bool) {
	v := m._Percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentage returns the old "Percentage" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentage: %w", err)
	}
	return oldValue.Percentage, nil
}

// AddPercentage adds f to the "Percentage" field.
func (m *JobPaymentsMutation) AddPercentage(f float64) {
	if m.add_Percentage != nil {
		*m.add_Percentage += f
	} else {
		m.add_Percentage = &f
	}
}

// AddedPercentage returns the value that was added to the "Percentage" field in this mutation.
func (m *JobPaymentsMutation) AddedPercentage() (r float64, exists bool) {
	v := m.add_Percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearPercentage clears the value of the "Percentage" field.
func (m *JobPaymentsMutation) ClearPercentage() {
	m._Percentage = nil
	m.add_Percentage = nil
	m.clearedFields[jobpayments.FieldPercentage] = struct{}{}
}

// PercentageCleared returns if the "Percentage" field was cleared in this mutation.
func (m *JobPaymentsMutation) PercentageCleared() bool {
	_, ok := m.clearedFields[jobpayments.FieldPercentage]
	return ok
}

// ResetPercentage resets all changes to the "Percentage" field.
func (m *JobPaymentsMutation) ResetPercentage() {
	m._Percentage = nil
	m.add_Percentage = nil
	delete(m.clearedFields, jobpayments.FieldPercentage)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobPaymentsMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobPaymentsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobPaymentsMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobPaymentsMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobPaymentsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobPayments entity.
// If the JobPayments object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobPaymentsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobPaymentsMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetPaymentsID sets the "payments" edge to the JobDetail entity by id.
func (m *JobPaymentsMutation) SetPaymentsID(id int) {
	m.payments = &id
}

// ClearPayments clears the "payments" edge to the JobDetail entity.
func (m *JobPaymentsMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the JobDetail entity was cleared.
func (m *JobPaymentsMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// PaymentsID returns the "payments" edge ID in the mutation.
func (m *JobPaymentsMutation) PaymentsID() (id int, exists bool) {
	if m.payments != nil {
		return *m.payments, true
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PaymentsID instead. It exists only for internal usage by the builders.
func (m *JobPaymentsMutation) PaymentsIDs() (ids []int) {
	if id := m.payments; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *JobPaymentsMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
}

// Where appends a list predicates to the JobPaymentsMutation builder.
func (m *JobPaymentsMutation) Where(ps ...predicate.JobPayments) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobPaymentsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobPaymentsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobPayments, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobPaymentsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobPaymentsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobPayments).
func (m *JobPaymentsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobPaymentsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Date != nil {
		fields = append(fields, jobpayments.FieldDate)
	}
	if m._Amount != nil {
		fields = append(fields, jobpayments.FieldAmount)
	}
	if m._Description != nil {
		fields = append(fields, jobpayments.FieldDescription)
	}
	if m._Status != nil {
		fields = append(fields, jobpayments.FieldStatus)
	}
	if m._Percentage != nil {
		fields = append(fields, jobpayments.FieldPercentage)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobpayments.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobpayments.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobPaymentsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobpayments.FieldDate:
		return m.Date()
	case jobpayments.FieldAmount:
		return m.Amount()
	case jobpayments.FieldDescription:
		return m.Description()
	case jobpayments.FieldStatus:
		return m.Status()
	case jobpayments.FieldPercentage:
		return m.Percentage()
	case jobpayments.FieldCreatedAt:
		return m.CreatedAt()
	case jobpayments.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobPaymentsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobpayments.FieldDate:
		return m.OldDate(ctx)
	case jobpayments.FieldAmount:
		return m.OldAmount(ctx)
	case jobpayments.FieldDescription:
		return m.OldDescription(ctx)
	case jobpayments.FieldStatus:
		return m.OldStatus(ctx)
	case jobpayments.FieldPercentage:
		return m.OldPercentage(ctx)
	case jobpayments.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobpayments.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobPayments field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPaymentsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobpayments.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case jobpayments.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case jobpayments.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case jobpayments.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobpayments.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentage(v)
		return nil
	case jobpayments.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobpayments.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobPayments field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobPaymentsMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, jobpayments.FieldAmount)
	}
	if m.add_Percentage != nil {
		fields = append(fields, jobpayments.FieldPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobPaymentsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobpayments.FieldAmount:
		return m.AddedAmount()
	case jobpayments.FieldPercentage:
		return m.AddedPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobPaymentsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobpayments.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case jobpayments.FieldPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown JobPayments numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobPaymentsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobpayments.FieldAmount) {
		fields = append(fields, jobpayments.FieldAmount)
	}
	if m.FieldCleared(jobpayments.FieldDescription) {
		fields = append(fields, jobpayments.FieldDescription)
	}
	if m.FieldCleared(jobpayments.FieldStatus) {
		fields = append(fields, jobpayments.FieldStatus)
	}
	if m.FieldCleared(jobpayments.FieldPercentage) {
		fields = append(fields, jobpayments.FieldPercentage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobPaymentsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobPaymentsMutation) ClearField(name string) error {
	switch name {
	case jobpayments.FieldAmount:
		m.ClearAmount()
		return nil
	case jobpayments.FieldDescription:
		m.ClearDescription()
		return nil
	case jobpayments.FieldStatus:
		m.ClearStatus()
		return nil
	case jobpayments.FieldPercentage:
		m.ClearPercentage()
		return nil
	}
	return fmt.Errorf("unknown JobPayments nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobPaymentsMutation) ResetField(name string) error {
	switch name {
	case jobpayments.FieldDate:
		m.ResetDate()
		return nil
	case jobpayments.FieldAmount:
		m.ResetAmount()
		return nil
	case jobpayments.FieldDescription:
		m.ResetDescription()
		return nil
	case jobpayments.FieldStatus:
		m.ResetStatus()
		return nil
	case jobpayments.FieldPercentage:
		m.ResetPercentage()
		return nil
	case jobpayments.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobpayments.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobPayments field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobPaymentsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.payments != nil {
		edges = append(edges, jobpayments.EdgePayments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobPaymentsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobpayments.EdgePayments:
		if id := m.payments; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobPaymentsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobPaymentsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobPaymentsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpayments {
		edges = append(edges, jobpayments.EdgePayments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobPaymentsMutation) EdgeCleared(name string) bool {
	switch name {
	case jobpayments.EdgePayments:
		return m.clearedpayments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobPaymentsMutation) ClearEdge(name string) error {
	switch name {
	case jobpayments.EdgePayments:
		m.ClearPayments()
		return nil
	}
	return fmt.Errorf("unknown JobPayments unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobPaymentsMutation) ResetEdge(name string) error {
	switch name {
	case jobpayments.EdgePayments:
		m.ResetPayments()
		return nil
	}
	return fmt.Errorf("unknown JobPayments edge %s", name)
}

// JobProgressMutation represents an operation that mutates the JobProgress nodes in the graph.
type JobProgressMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_One            *int
	add_One         *int
	_Two            *int
	add_Two         *int
	_Three          *int
	add_Three       *int
	_Four           *int
	add_Four        *int
	_Five           *int
	add_Five        *int
	_Six            *int
	add_Six         *int
	_CreatedAt      *time.Time
	_UpdatedAt      *time.Time
	clearedFields   map[string]struct{}
	progress        map[int]struct{}
	removedprogress map[int]struct{}
	clearedprogress bool
	done            bool
	oldValue        func(context.Context) (*JobProgress, error)
	predicates      []predicate.JobProgress
}

var _ ent.Mutation = (*JobProgressMutation)(nil)

// jobprogressOption allows management of the mutation configuration using functional options.
type jobprogressOption func(*JobProgressMutation)

// newJobProgressMutation creates new mutation for the JobProgress entity.
func newJobProgressMutation(c config, op Op, opts ...jobprogressOption) *JobProgressMutation {
	m := &JobProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeJobProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobProgressID sets the ID field of the mutation.
func withJobProgressID(id int) jobprogressOption {
	return func(m *JobProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *JobProgress
		)
		m.oldValue = func(ctx context.Context) (*JobProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobProgress sets the old JobProgress of the mutation.
func withJobProgress(node *JobProgress) jobprogressOption {
	return func(m *JobProgressMutation) {
		m.oldValue = func(context.Context) (*JobProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobProgressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobProgressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOne sets the "One" field.
func (m *JobProgressMutation) SetOne(i int) {
	m._One = &i
	m.add_One = nil
}

// One returns the value of the "One" field in the mutation.
func (m *JobProgressMutation) One() (r int, exists bool) {
	v := m._One
	if v == nil {
		return
	}
	return *v, true
}

// OldOne returns the old "One" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldOne(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOne: %w", err)
	}
	return oldValue.One, nil
}

// AddOne adds i to the "One" field.
func (m *JobProgressMutation) AddOne(i int) {
	if m.add_One != nil {
		*m.add_One += i
	} else {
		m.add_One = &i
	}
}

// AddedOne returns the value that was added to the "One" field in this mutation.
func (m *JobProgressMutation) AddedOne() (r int, exists bool) {
	v := m.add_One
	if v == nil {
		return
	}
	return *v, true
}

// ClearOne clears the value of the "One" field.
func (m *JobProgressMutation) ClearOne() {
	m._One = nil
	m.add_One = nil
	m.clearedFields[jobprogress.FieldOne] = struct{}{}
}

// OneCleared returns if the "One" field was cleared in this mutation.
func (m *JobProgressMutation) OneCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldOne]
	return ok
}

// ResetOne resets all changes to the "One" field.
func (m *JobProgressMutation) ResetOne() {
	m._One = nil
	m.add_One = nil
	delete(m.clearedFields, jobprogress.FieldOne)
}

// SetTwo sets the "Two" field.
func (m *JobProgressMutation) SetTwo(i int) {
	m._Two = &i
	m.add_Two = nil
}

// Two returns the value of the "Two" field in the mutation.
func (m *JobProgressMutation) Two() (r int, exists bool) {
	v := m._Two
	if v == nil {
		return
	}
	return *v, true
}

// OldTwo returns the old "Two" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldTwo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwo: %w", err)
	}
	return oldValue.Two, nil
}

// AddTwo adds i to the "Two" field.
func (m *JobProgressMutation) AddTwo(i int) {
	if m.add_Two != nil {
		*m.add_Two += i
	} else {
		m.add_Two = &i
	}
}

// AddedTwo returns the value that was added to the "Two" field in this mutation.
func (m *JobProgressMutation) AddedTwo() (r int, exists bool) {
	v := m.add_Two
	if v == nil {
		return
	}
	return *v, true
}

// ClearTwo clears the value of the "Two" field.
func (m *JobProgressMutation) ClearTwo() {
	m._Two = nil
	m.add_Two = nil
	m.clearedFields[jobprogress.FieldTwo] = struct{}{}
}

// TwoCleared returns if the "Two" field was cleared in this mutation.
func (m *JobProgressMutation) TwoCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldTwo]
	return ok
}

// ResetTwo resets all changes to the "Two" field.
func (m *JobProgressMutation) ResetTwo() {
	m._Two = nil
	m.add_Two = nil
	delete(m.clearedFields, jobprogress.FieldTwo)
}

// SetThree sets the "Three" field.
func (m *JobProgressMutation) SetThree(i int) {
	m._Three = &i
	m.add_Three = nil
}

// Three returns the value of the "Three" field in the mutation.
func (m *JobProgressMutation) Three() (r int, exists bool) {
	v := m._Three
	if v == nil {
		return
	}
	return *v, true
}

// OldThree returns the old "Three" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldThree(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThree: %w", err)
	}
	return oldValue.Three, nil
}

// AddThree adds i to the "Three" field.
func (m *JobProgressMutation) AddThree(i int) {
	if m.add_Three != nil {
		*m.add_Three += i
	} else {
		m.add_Three = &i
	}
}

// AddedThree returns the value that was added to the "Three" field in this mutation.
func (m *JobProgressMutation) AddedThree() (r int, exists bool) {
	v := m.add_Three
	if v == nil {
		return
	}
	return *v, true
}

// ClearThree clears the value of the "Three" field.
func (m *JobProgressMutation) ClearThree() {
	m._Three = nil
	m.add_Three = nil
	m.clearedFields[jobprogress.FieldThree] = struct{}{}
}

// ThreeCleared returns if the "Three" field was cleared in this mutation.
func (m *JobProgressMutation) ThreeCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldThree]
	return ok
}

// ResetThree resets all changes to the "Three" field.
func (m *JobProgressMutation) ResetThree() {
	m._Three = nil
	m.add_Three = nil
	delete(m.clearedFields, jobprogress.FieldThree)
}

// SetFour sets the "Four" field.
func (m *JobProgressMutation) SetFour(i int) {
	m._Four = &i
	m.add_Four = nil
}

// Four returns the value of the "Four" field in the mutation.
func (m *JobProgressMutation) Four() (r int, exists bool) {
	v := m._Four
	if v == nil {
		return
	}
	return *v, true
}

// OldFour returns the old "Four" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldFour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFour: %w", err)
	}
	return oldValue.Four, nil
}

// AddFour adds i to the "Four" field.
func (m *JobProgressMutation) AddFour(i int) {
	if m.add_Four != nil {
		*m.add_Four += i
	} else {
		m.add_Four = &i
	}
}

// AddedFour returns the value that was added to the "Four" field in this mutation.
func (m *JobProgressMutation) AddedFour() (r int, exists bool) {
	v := m.add_Four
	if v == nil {
		return
	}
	return *v, true
}

// ClearFour clears the value of the "Four" field.
func (m *JobProgressMutation) ClearFour() {
	m._Four = nil
	m.add_Four = nil
	m.clearedFields[jobprogress.FieldFour] = struct{}{}
}

// FourCleared returns if the "Four" field was cleared in this mutation.
func (m *JobProgressMutation) FourCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldFour]
	return ok
}

// ResetFour resets all changes to the "Four" field.
func (m *JobProgressMutation) ResetFour() {
	m._Four = nil
	m.add_Four = nil
	delete(m.clearedFields, jobprogress.FieldFour)
}

// SetFive sets the "Five" field.
func (m *JobProgressMutation) SetFive(i int) {
	m._Five = &i
	m.add_Five = nil
}

// Five returns the value of the "Five" field in the mutation.
func (m *JobProgressMutation) Five() (r int, exists bool) {
	v := m._Five
	if v == nil {
		return
	}
	return *v, true
}

// OldFive returns the old "Five" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldFive(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFive: %w", err)
	}
	return oldValue.Five, nil
}

// AddFive adds i to the "Five" field.
func (m *JobProgressMutation) AddFive(i int) {
	if m.add_Five != nil {
		*m.add_Five += i
	} else {
		m.add_Five = &i
	}
}

// AddedFive returns the value that was added to the "Five" field in this mutation.
func (m *JobProgressMutation) AddedFive() (r int, exists bool) {
	v := m.add_Five
	if v == nil {
		return
	}
	return *v, true
}

// ClearFive clears the value of the "Five" field.
func (m *JobProgressMutation) ClearFive() {
	m._Five = nil
	m.add_Five = nil
	m.clearedFields[jobprogress.FieldFive] = struct{}{}
}

// FiveCleared returns if the "Five" field was cleared in this mutation.
func (m *JobProgressMutation) FiveCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldFive]
	return ok
}

// ResetFive resets all changes to the "Five" field.
func (m *JobProgressMutation) ResetFive() {
	m._Five = nil
	m.add_Five = nil
	delete(m.clearedFields, jobprogress.FieldFive)
}

// SetSix sets the "Six" field.
func (m *JobProgressMutation) SetSix(i int) {
	m._Six = &i
	m.add_Six = nil
}

// Six returns the value of the "Six" field in the mutation.
func (m *JobProgressMutation) Six() (r int, exists bool) {
	v := m._Six
	if v == nil {
		return
	}
	return *v, true
}

// OldSix returns the old "Six" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldSix(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSix: %w", err)
	}
	return oldValue.Six, nil
}

// AddSix adds i to the "Six" field.
func (m *JobProgressMutation) AddSix(i int) {
	if m.add_Six != nil {
		*m.add_Six += i
	} else {
		m.add_Six = &i
	}
}

// AddedSix returns the value that was added to the "Six" field in this mutation.
func (m *JobProgressMutation) AddedSix() (r int, exists bool) {
	v := m.add_Six
	if v == nil {
		return
	}
	return *v, true
}

// ClearSix clears the value of the "Six" field.
func (m *JobProgressMutation) ClearSix() {
	m._Six = nil
	m.add_Six = nil
	m.clearedFields[jobprogress.FieldSix] = struct{}{}
}

// SixCleared returns if the "Six" field was cleared in this mutation.
func (m *JobProgressMutation) SixCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldSix]
	return ok
}

// ResetSix resets all changes to the "Six" field.
func (m *JobProgressMutation) ResetSix() {
	m._Six = nil
	m.add_Six = nil
	delete(m.clearedFields, jobprogress.FieldSix)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobProgressMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobProgressMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobProgressMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobProgressMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddProgresIDs adds the "progress" edge to the JobDetail entity by ids.
func (m *JobProgressMutation) AddProgresIDs(ids ...int) {
	if m.progress == nil {
		m.progress = make(map[int]struct{})
	}
	for i := range ids {
		m.progress[ids[i]] = struct{}{}
	}
}

// ClearProgress clears the "progress" edge to the JobDetail entity.
func (m *JobProgressMutation) ClearProgress() {
	m.clearedprogress = true
}

// ProgressCleared reports if the "progress" edge to the JobDetail entity was cleared.
func (m *JobProgressMutation) ProgressCleared() bool {
	return m.clearedprogress
}

// RemoveProgresIDs removes the "progress" edge to the JobDetail entity by IDs.
func (m *JobProgressMutation) RemoveProgresIDs(ids ...int) {
	if m.removedprogress == nil {
		m.removedprogress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.progress, ids[i])
		m.removedprogress[ids[i]] = struct{}{}
	}
}

// RemovedProgress returns the removed IDs of the "progress" edge to the JobDetail entity.
func (m *JobProgressMutation) RemovedProgressIDs() (ids []int) {
	for id := range m.removedprogress {
		ids = append(ids, id)
	}
	return
}

// ProgressIDs returns the "progress" edge IDs in the mutation.
func (m *JobProgressMutation) ProgressIDs() (ids []int) {
	for id := range m.progress {
		ids = append(ids, id)
	}
	return
}

// ResetProgress resets all changes to the "progress" edge.
func (m *JobProgressMutation) ResetProgress() {
	m.progress = nil
	m.clearedprogress = false
	m.removedprogress = nil
}

// Where appends a list predicates to the JobProgressMutation builder.
func (m *JobProgressMutation) Where(ps ...predicate.JobProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobProgress).
func (m *JobProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobProgressMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._One != nil {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m._Two != nil {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m._Three != nil {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m._Four != nil {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m._Five != nil {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m._Six != nil {
		fields = append(fields, jobprogress.FieldSix)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobprogress.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobprogress.FieldOne:
		return m.One()
	case jobprogress.FieldTwo:
		return m.Two()
	case jobprogress.FieldThree:
		return m.Three()
	case jobprogress.FieldFour:
		return m.Four()
	case jobprogress.FieldFive:
		return m.Five()
	case jobprogress.FieldSix:
		return m.Six()
	case jobprogress.FieldCreatedAt:
		return m.CreatedAt()
	case jobprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobprogress.FieldOne:
		return m.OldOne(ctx)
	case jobprogress.FieldTwo:
		return m.OldTwo(ctx)
	case jobprogress.FieldThree:
		return m.OldThree(ctx)
	case jobprogress.FieldFour:
		return m.OldFour(ctx)
	case jobprogress.FieldFive:
		return m.OldFive(ctx)
	case jobprogress.FieldSix:
		return m.OldSix(ctx)
	case jobprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobprogress.FieldOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOne(v)
		return nil
	case jobprogress.FieldTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwo(v)
		return nil
	case jobprogress.FieldThree:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThree(v)
		return nil
	case jobprogress.FieldFour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFour(v)
		return nil
	case jobprogress.FieldFive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFive(v)
		return nil
	case jobprogress.FieldSix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSix(v)
		return nil
	case jobprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobProgressMutation) AddedFields() []string {
	var fields []string
	if m.add_One != nil {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m.add_Two != nil {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m.add_Three != nil {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m.add_Four != nil {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m.add_Five != nil {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m.add_Six != nil {
		fields = append(fields, jobprogress.FieldSix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobprogress.FieldOne:
		return m.AddedOne()
	case jobprogress.FieldTwo:
		return m.AddedTwo()
	case jobprogress.FieldThree:
		return m.AddedThree()
	case jobprogress.FieldFour:
		return m.AddedFour()
	case jobprogress.FieldFive:
		return m.AddedFive()
	case jobprogress.FieldSix:
		return m.AddedSix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobprogress.FieldOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOne(v)
		return nil
	case jobprogress.FieldTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTwo(v)
		return nil
	case jobprogress.FieldThree:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThree(v)
		return nil
	case jobprogress.FieldFour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFour(v)
		return nil
	case jobprogress.FieldFive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFive(v)
		return nil
	case jobprogress.FieldSix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSix(v)
		return nil
	}
	return fmt.Errorf("unknown JobProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobprogress.FieldOne) {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m.FieldCleared(jobprogress.FieldTwo) {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m.FieldCleared(jobprogress.FieldThree) {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m.FieldCleared(jobprogress.FieldFour) {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m.FieldCleared(jobprogress.FieldFive) {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m.FieldCleared(jobprogress.FieldSix) {
		fields = append(fields, jobprogress.FieldSix)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobProgressMutation) ClearField(name string) error {
	switch name {
	case jobprogress.FieldOne:
		m.ClearOne()
		return nil
	case jobprogress.FieldTwo:
		m.ClearTwo()
		return nil
	case jobprogress.FieldThree:
		m.ClearThree()
		return nil
	case jobprogress.FieldFour:
		m.ClearFour()
		return nil
	case jobprogress.FieldFive:
		m.ClearFive()
		return nil
	case jobprogress.FieldSix:
		m.ClearSix()
		return nil
	}
	return fmt.Errorf("unknown JobProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobProgressMutation) ResetField(name string) error {
	switch name {
	case jobprogress.FieldOne:
		m.ResetOne()
		return nil
	case jobprogress.FieldTwo:
		m.ResetTwo()
		return nil
	case jobprogress.FieldThree:
		m.ResetThree()
		return nil
	case jobprogress.FieldFour:
		m.ResetFour()
		return nil
	case jobprogress.FieldFive:
		m.ResetFive()
		return nil
	case jobprogress.FieldSix:
		m.ResetSix()
		return nil
	case jobprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.progress != nil {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobprogress.EdgeProgress:
		ids := make([]ent.Value, 0, len(m.progress))
		for id := range m.progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprogress != nil {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobProgressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobprogress.EdgeProgress:
		ids := make([]ent.Value, 0, len(m.removedprogress))
		for id := range m.removedprogress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprogress {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case jobprogress.EdgeProgress:
		return m.clearedprogress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobProgressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobProgressMutation) ResetEdge(name string) error {
	switch name {
	case jobprogress.EdgeProgress:
		m.ResetProgress()
		return nil
	}
	return fmt.Errorf("unknown JobProgress edge %s", name)
}

// JobSupervisorMutation represents an operation that mutates the JobSupervisor nodes in the graph.
type JobSupervisorMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_Name                *string
	_Address             *string
	_Phone               *string
	_Email               *string
	_TcNo                *int
	add_TcNo             *int
	_Position            *string
	_Career              *string
	_RegisterNo          *int
	add_RegisterNo       *int
	_SocialSecurityNo    *int
	add_SocialSecurityNo *int
	_SchoolGraduation    *string
	_YDSID               *int
	add_YDSID            *int
	_CreatedAt           *time.Time
	_UpdatedAt           *time.Time
	clearedFields        map[string]struct{}
	supervisors          map[int]struct{}
	removedsupervisors   map[int]struct{}
	clearedsupervisors   bool
	done                 bool
	oldValue             func(context.Context) (*JobSupervisor, error)
	predicates           []predicate.JobSupervisor
}

var _ ent.Mutation = (*JobSupervisorMutation)(nil)

// jobsupervisorOption allows management of the mutation configuration using functional options.
type jobsupervisorOption func(*JobSupervisorMutation)

// newJobSupervisorMutation creates new mutation for the JobSupervisor entity.
func newJobSupervisorMutation(c config, op Op, opts ...jobsupervisorOption) *JobSupervisorMutation {
	m := &JobSupervisorMutation{
		config:        c,
		op:            op,
		typ:           TypeJobSupervisor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobSupervisorID sets the ID field of the mutation.
func withJobSupervisorID(id int) jobsupervisorOption {
	return func(m *JobSupervisorMutation) {
		var (
			err   error
			once  sync.Once
			value *JobSupervisor
		)
		m.oldValue = func(ctx context.Context) (*JobSupervisor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobSupervisor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobSupervisor sets the old JobSupervisor of the mutation.
func withJobSupervisor(node *JobSupervisor) jobsupervisorOption {
	return func(m *JobSupervisorMutation) {
		m.oldValue = func(context.Context) (*JobSupervisor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobSupervisorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobSupervisorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobSupervisorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobSupervisorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobSupervisor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobSupervisorMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobSupervisorMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *JobSupervisorMutation) ClearName() {
	m._Name = nil
	m.clearedFields[jobsupervisor.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *JobSupervisorMutation) NameCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *JobSupervisorMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, jobsupervisor.FieldName)
}

// SetAddress sets the "Address" field.
func (m *JobSupervisorMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobSupervisorMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobSupervisorMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobsupervisor.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobSupervisorMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobSupervisorMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobsupervisor.FieldAddress)
}

// SetPhone sets the "Phone" field.
func (m *JobSupervisorMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *JobSupervisorMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *JobSupervisorMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[jobsupervisor.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *JobSupervisorMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *JobSupervisorMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, jobsupervisor.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *JobSupervisorMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *JobSupervisorMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *JobSupervisorMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[jobsupervisor.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *JobSupervisorMutation) EmailCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *JobSupervisorMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, jobsupervisor.FieldEmail)
}

// SetTcNo sets the "TcNo" field.
func (m *JobSupervisorMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *JobSupervisorMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *JobSupervisorMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *JobSupervisorMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *JobSupervisorMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[jobsupervisor.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *JobSupervisorMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *JobSupervisorMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, jobsupervisor.FieldTcNo)
}

// SetPosition sets the "Position" field.
func (m *JobSupervisorMutation) SetPosition(s string) {
	m._Position = &s
}

// Position returns the value of the "Position" field in the mutation.
func (m *JobSupervisorMutation) Position() (r string, exists bool) {
	v := m._Position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "Position" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "Position" field.
func (m *JobSupervisorMutation) ClearPosition() {
	m._Position = nil
	m.clearedFields[jobsupervisor.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "Position" field was cleared in this mutation.
func (m *JobSupervisorMutation) PositionCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "Position" field.
func (m *JobSupervisorMutation) ResetPosition() {
	m._Position = nil
	delete(m.clearedFields, jobsupervisor.FieldPosition)
}

// SetCareer sets the "Career" field.
func (m *JobSupervisorMutation) SetCareer(s string) {
	m._Career = &s
}

// Career returns the value of the "Career" field in the mutation.
func (m *JobSupervisorMutation) Career() (r string, exists bool) {
	v := m._Career
	if v == nil {
		return
	}
	return *v, true
}

// OldCareer returns the old "Career" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldCareer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCareer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCareer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCareer: %w", err)
	}
	return oldValue.Career, nil
}

// ClearCareer clears the value of the "Career" field.
func (m *JobSupervisorMutation) ClearCareer() {
	m._Career = nil
	m.clearedFields[jobsupervisor.FieldCareer] = struct{}{}
}

// CareerCleared returns if the "Career" field was cleared in this mutation.
func (m *JobSupervisorMutation) CareerCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldCareer]
	return ok
}

// ResetCareer resets all changes to the "Career" field.
func (m *JobSupervisorMutation) ResetCareer() {
	m._Career = nil
	delete(m.clearedFields, jobsupervisor.FieldCareer)
}

// SetRegisterNo sets the "RegisterNo" field.
func (m *JobSupervisorMutation) SetRegisterNo(i int) {
	m._RegisterNo = &i
	m.add_RegisterNo = nil
}

// RegisterNo returns the value of the "RegisterNo" field in the mutation.
func (m *JobSupervisorMutation) RegisterNo() (r int, exists bool) {
	v := m._RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterNo returns the old "RegisterNo" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldRegisterNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterNo: %w", err)
	}
	return oldValue.RegisterNo, nil
}

// AddRegisterNo adds i to the "RegisterNo" field.
func (m *JobSupervisorMutation) AddRegisterNo(i int) {
	if m.add_RegisterNo != nil {
		*m.add_RegisterNo += i
	} else {
		m.add_RegisterNo = &i
	}
}

// AddedRegisterNo returns the value that was added to the "RegisterNo" field in this mutation.
func (m *JobSupervisorMutation) AddedRegisterNo() (r int, exists bool) {
	v := m.add_RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegisterNo clears the value of the "RegisterNo" field.
func (m *JobSupervisorMutation) ClearRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	m.clearedFields[jobsupervisor.FieldRegisterNo] = struct{}{}
}

// RegisterNoCleared returns if the "RegisterNo" field was cleared in this mutation.
func (m *JobSupervisorMutation) RegisterNoCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldRegisterNo]
	return ok
}

// ResetRegisterNo resets all changes to the "RegisterNo" field.
func (m *JobSupervisorMutation) ResetRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	delete(m.clearedFields, jobsupervisor.FieldRegisterNo)
}

// SetSocialSecurityNo sets the "SocialSecurityNo" field.
func (m *JobSupervisorMutation) SetSocialSecurityNo(i int) {
	m._SocialSecurityNo = &i
	m.add_SocialSecurityNo = nil
}

// SocialSecurityNo returns the value of the "SocialSecurityNo" field in the mutation.
func (m *JobSupervisorMutation) SocialSecurityNo() (r int, exists bool) {
	v := m._SocialSecurityNo
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialSecurityNo returns the old "SocialSecurityNo" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldSocialSecurityNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialSecurityNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialSecurityNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialSecurityNo: %w", err)
	}
	return oldValue.SocialSecurityNo, nil
}

// AddSocialSecurityNo adds i to the "SocialSecurityNo" field.
func (m *JobSupervisorMutation) AddSocialSecurityNo(i int) {
	if m.add_SocialSecurityNo != nil {
		*m.add_SocialSecurityNo += i
	} else {
		m.add_SocialSecurityNo = &i
	}
}

// AddedSocialSecurityNo returns the value that was added to the "SocialSecurityNo" field in this mutation.
func (m *JobSupervisorMutation) AddedSocialSecurityNo() (r int, exists bool) {
	v := m.add_SocialSecurityNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearSocialSecurityNo clears the value of the "SocialSecurityNo" field.
func (m *JobSupervisorMutation) ClearSocialSecurityNo() {
	m._SocialSecurityNo = nil
	m.add_SocialSecurityNo = nil
	m.clearedFields[jobsupervisor.FieldSocialSecurityNo] = struct{}{}
}

// SocialSecurityNoCleared returns if the "SocialSecurityNo" field was cleared in this mutation.
func (m *JobSupervisorMutation) SocialSecurityNoCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldSocialSecurityNo]
	return ok
}

// ResetSocialSecurityNo resets all changes to the "SocialSecurityNo" field.
func (m *JobSupervisorMutation) ResetSocialSecurityNo() {
	m._SocialSecurityNo = nil
	m.add_SocialSecurityNo = nil
	delete(m.clearedFields, jobsupervisor.FieldSocialSecurityNo)
}

// SetSchoolGraduation sets the "SchoolGraduation" field.
func (m *JobSupervisorMutation) SetSchoolGraduation(s string) {
	m._SchoolGraduation = &s
}

// SchoolGraduation returns the value of the "SchoolGraduation" field in the mutation.
func (m *JobSupervisorMutation) SchoolGraduation() (r string, exists bool) {
	v := m._SchoolGraduation
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolGraduation returns the old "SchoolGraduation" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldSchoolGraduation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolGraduation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolGraduation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolGraduation: %w", err)
	}
	return oldValue.SchoolGraduation, nil
}

// ClearSchoolGraduation clears the value of the "SchoolGraduation" field.
func (m *JobSupervisorMutation) ClearSchoolGraduation() {
	m._SchoolGraduation = nil
	m.clearedFields[jobsupervisor.FieldSchoolGraduation] = struct{}{}
}

// SchoolGraduationCleared returns if the "SchoolGraduation" field was cleared in this mutation.
func (m *JobSupervisorMutation) SchoolGraduationCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldSchoolGraduation]
	return ok
}

// ResetSchoolGraduation resets all changes to the "SchoolGraduation" field.
func (m *JobSupervisorMutation) ResetSchoolGraduation() {
	m._SchoolGraduation = nil
	delete(m.clearedFields, jobsupervisor.FieldSchoolGraduation)
}

// SetYDSID sets the "YDSID" field.
func (m *JobSupervisorMutation) SetYDSID(i int) {
	m._YDSID = &i
	m.add_YDSID = nil
}

// YDSID returns the value of the "YDSID" field in the mutation.
func (m *JobSupervisorMutation) YDSID() (r int, exists bool) {
	v := m._YDSID
	if v == nil {
		return
	}
	return *v, true
}

// OldYDSID returns the old "YDSID" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldYDSID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYDSID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYDSID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYDSID: %w", err)
	}
	return oldValue.YDSID, nil
}

// AddYDSID adds i to the "YDSID" field.
func (m *JobSupervisorMutation) AddYDSID(i int) {
	if m.add_YDSID != nil {
		*m.add_YDSID += i
	} else {
		m.add_YDSID = &i
	}
}

// AddedYDSID returns the value that was added to the "YDSID" field in this mutation.
func (m *JobSupervisorMutation) AddedYDSID() (r int, exists bool) {
	v := m.add_YDSID
	if v == nil {
		return
	}
	return *v, true
}

// ClearYDSID clears the value of the "YDSID" field.
func (m *JobSupervisorMutation) ClearYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	m.clearedFields[jobsupervisor.FieldYDSID] = struct{}{}
}

// YDSIDCleared returns if the "YDSID" field was cleared in this mutation.
func (m *JobSupervisorMutation) YDSIDCleared() bool {
	_, ok := m.clearedFields[jobsupervisor.FieldYDSID]
	return ok
}

// ResetYDSID resets all changes to the "YDSID" field.
func (m *JobSupervisorMutation) ResetYDSID() {
	m._YDSID = nil
	m.add_YDSID = nil
	delete(m.clearedFields, jobsupervisor.FieldYDSID)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobSupervisorMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobSupervisorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobSupervisorMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobSupervisorMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobSupervisorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobSupervisor entity.
// If the JobSupervisor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobSupervisorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobSupervisorMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddSupervisorIDs adds the "supervisors" edge to the JobDetail entity by ids.
func (m *JobSupervisorMutation) AddSupervisorIDs(ids ...int) {
	if m.supervisors == nil {
		m.supervisors = make(map[int]struct{})
	}
	for i := range ids {
		m.supervisors[ids[i]] = struct{}{}
	}
}

// ClearSupervisors clears the "supervisors" edge to the JobDetail entity.
func (m *JobSupervisorMutation) ClearSupervisors() {
	m.clearedsupervisors = true
}

// SupervisorsCleared reports if the "supervisors" edge to the JobDetail entity was cleared.
func (m *JobSupervisorMutation) SupervisorsCleared() bool {
	return m.clearedsupervisors
}

// RemoveSupervisorIDs removes the "supervisors" edge to the JobDetail entity by IDs.
func (m *JobSupervisorMutation) RemoveSupervisorIDs(ids ...int) {
	if m.removedsupervisors == nil {
		m.removedsupervisors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.supervisors, ids[i])
		m.removedsupervisors[ids[i]] = struct{}{}
	}
}

// RemovedSupervisors returns the removed IDs of the "supervisors" edge to the JobDetail entity.
func (m *JobSupervisorMutation) RemovedSupervisorsIDs() (ids []int) {
	for id := range m.removedsupervisors {
		ids = append(ids, id)
	}
	return
}

// SupervisorsIDs returns the "supervisors" edge IDs in the mutation.
func (m *JobSupervisorMutation) SupervisorsIDs() (ids []int) {
	for id := range m.supervisors {
		ids = append(ids, id)
	}
	return
}

// ResetSupervisors resets all changes to the "supervisors" edge.
func (m *JobSupervisorMutation) ResetSupervisors() {
	m.supervisors = nil
	m.clearedsupervisors = false
	m.removedsupervisors = nil
}

// Where appends a list predicates to the JobSupervisorMutation builder.
func (m *JobSupervisorMutation) Where(ps ...predicate.JobSupervisor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobSupervisorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobSupervisorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobSupervisor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobSupervisorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobSupervisorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobSupervisor).
func (m *JobSupervisorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobSupervisorMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m._Name != nil {
		fields = append(fields, jobsupervisor.FieldName)
	}
	if m._Address != nil {
		fields = append(fields, jobsupervisor.FieldAddress)
	}
	if m._Phone != nil {
		fields = append(fields, jobsupervisor.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, jobsupervisor.FieldEmail)
	}
	if m._TcNo != nil {
		fields = append(fields, jobsupervisor.FieldTcNo)
	}
	if m._Position != nil {
		fields = append(fields, jobsupervisor.FieldPosition)
	}
	if m._Career != nil {
		fields = append(fields, jobsupervisor.FieldCareer)
	}
	if m._RegisterNo != nil {
		fields = append(fields, jobsupervisor.FieldRegisterNo)
	}
	if m._SocialSecurityNo != nil {
		fields = append(fields, jobsupervisor.FieldSocialSecurityNo)
	}
	if m._SchoolGraduation != nil {
		fields = append(fields, jobsupervisor.FieldSchoolGraduation)
	}
	if m._YDSID != nil {
		fields = append(fields, jobsupervisor.FieldYDSID)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobsupervisor.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobsupervisor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobSupervisorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobsupervisor.FieldName:
		return m.Name()
	case jobsupervisor.FieldAddress:
		return m.Address()
	case jobsupervisor.FieldPhone:
		return m.Phone()
	case jobsupervisor.FieldEmail:
		return m.Email()
	case jobsupervisor.FieldTcNo:
		return m.TcNo()
	case jobsupervisor.FieldPosition:
		return m.Position()
	case jobsupervisor.FieldCareer:
		return m.Career()
	case jobsupervisor.FieldRegisterNo:
		return m.RegisterNo()
	case jobsupervisor.FieldSocialSecurityNo:
		return m.SocialSecurityNo()
	case jobsupervisor.FieldSchoolGraduation:
		return m.SchoolGraduation()
	case jobsupervisor.FieldYDSID:
		return m.YDSID()
	case jobsupervisor.FieldCreatedAt:
		return m.CreatedAt()
	case jobsupervisor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobSupervisorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobsupervisor.FieldName:
		return m.OldName(ctx)
	case jobsupervisor.FieldAddress:
		return m.OldAddress(ctx)
	case jobsupervisor.FieldPhone:
		return m.OldPhone(ctx)
	case jobsupervisor.FieldEmail:
		return m.OldEmail(ctx)
	case jobsupervisor.FieldTcNo:
		return m.OldTcNo(ctx)
	case jobsupervisor.FieldPosition:
		return m.OldPosition(ctx)
	case jobsupervisor.FieldCareer:
		return m.OldCareer(ctx)
	case jobsupervisor.FieldRegisterNo:
		return m.OldRegisterNo(ctx)
	case jobsupervisor.FieldSocialSecurityNo:
		return m.OldSocialSecurityNo(ctx)
	case jobsupervisor.FieldSchoolGraduation:
		return m.OldSchoolGraduation(ctx)
	case jobsupervisor.FieldYDSID:
		return m.OldYDSID(ctx)
	case jobsupervisor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobsupervisor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobSupervisor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSupervisorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobsupervisor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobsupervisor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobsupervisor.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case jobsupervisor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case jobsupervisor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case jobsupervisor.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case jobsupervisor.FieldCareer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCareer(v)
		return nil
	case jobsupervisor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterNo(v)
		return nil
	case jobsupervisor.FieldSocialSecurityNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialSecurityNo(v)
		return nil
	case jobsupervisor.FieldSchoolGraduation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolGraduation(v)
		return nil
	case jobsupervisor.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYDSID(v)
		return nil
	case jobsupervisor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobsupervisor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobSupervisor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobSupervisorMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, jobsupervisor.FieldTcNo)
	}
	if m.add_RegisterNo != nil {
		fields = append(fields, jobsupervisor.FieldRegisterNo)
	}
	if m.add_SocialSecurityNo != nil {
		fields = append(fields, jobsupervisor.FieldSocialSecurityNo)
	}
	if m.add_YDSID != nil {
		fields = append(fields, jobsupervisor.FieldYDSID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobSupervisorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobsupervisor.FieldTcNo:
		return m.AddedTcNo()
	case jobsupervisor.FieldRegisterNo:
		return m.AddedRegisterNo()
	case jobsupervisor.FieldSocialSecurityNo:
		return m.AddedSocialSecurityNo()
	case jobsupervisor.FieldYDSID:
		return m.AddedYDSID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobSupervisorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobsupervisor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case jobsupervisor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterNo(v)
		return nil
	case jobsupervisor.FieldSocialSecurityNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSocialSecurityNo(v)
		return nil
	case jobsupervisor.FieldYDSID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYDSID(v)
		return nil
	}
	return fmt.Errorf("unknown JobSupervisor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobSupervisorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobsupervisor.FieldName) {
		fields = append(fields, jobsupervisor.FieldName)
	}
	if m.FieldCleared(jobsupervisor.FieldAddress) {
		fields = append(fields, jobsupervisor.FieldAddress)
	}
	if m.FieldCleared(jobsupervisor.FieldPhone) {
		fields = append(fields, jobsupervisor.FieldPhone)
	}
	if m.FieldCleared(jobsupervisor.FieldEmail) {
		fields = append(fields, jobsupervisor.FieldEmail)
	}
	if m.FieldCleared(jobsupervisor.FieldTcNo) {
		fields = append(fields, jobsupervisor.FieldTcNo)
	}
	if m.FieldCleared(jobsupervisor.FieldPosition) {
		fields = append(fields, jobsupervisor.FieldPosition)
	}
	if m.FieldCleared(jobsupervisor.FieldCareer) {
		fields = append(fields, jobsupervisor.FieldCareer)
	}
	if m.FieldCleared(jobsupervisor.FieldRegisterNo) {
		fields = append(fields, jobsupervisor.FieldRegisterNo)
	}
	if m.FieldCleared(jobsupervisor.FieldSocialSecurityNo) {
		fields = append(fields, jobsupervisor.FieldSocialSecurityNo)
	}
	if m.FieldCleared(jobsupervisor.FieldSchoolGraduation) {
		fields = append(fields, jobsupervisor.FieldSchoolGraduation)
	}
	if m.FieldCleared(jobsupervisor.FieldYDSID) {
		fields = append(fields, jobsupervisor.FieldYDSID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobSupervisorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobSupervisorMutation) ClearField(name string) error {
	switch name {
	case jobsupervisor.FieldName:
		m.ClearName()
		return nil
	case jobsupervisor.FieldAddress:
		m.ClearAddress()
		return nil
	case jobsupervisor.FieldPhone:
		m.ClearPhone()
		return nil
	case jobsupervisor.FieldEmail:
		m.ClearEmail()
		return nil
	case jobsupervisor.FieldTcNo:
		m.ClearTcNo()
		return nil
	case jobsupervisor.FieldPosition:
		m.ClearPosition()
		return nil
	case jobsupervisor.FieldCareer:
		m.ClearCareer()
		return nil
	case jobsupervisor.FieldRegisterNo:
		m.ClearRegisterNo()
		return nil
	case jobsupervisor.FieldSocialSecurityNo:
		m.ClearSocialSecurityNo()
		return nil
	case jobsupervisor.FieldSchoolGraduation:
		m.ClearSchoolGraduation()
		return nil
	case jobsupervisor.FieldYDSID:
		m.ClearYDSID()
		return nil
	}
	return fmt.Errorf("unknown JobSupervisor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobSupervisorMutation) ResetField(name string) error {
	switch name {
	case jobsupervisor.FieldName:
		m.ResetName()
		return nil
	case jobsupervisor.FieldAddress:
		m.ResetAddress()
		return nil
	case jobsupervisor.FieldPhone:
		m.ResetPhone()
		return nil
	case jobsupervisor.FieldEmail:
		m.ResetEmail()
		return nil
	case jobsupervisor.FieldTcNo:
		m.ResetTcNo()
		return nil
	case jobsupervisor.FieldPosition:
		m.ResetPosition()
		return nil
	case jobsupervisor.FieldCareer:
		m.ResetCareer()
		return nil
	case jobsupervisor.FieldRegisterNo:
		m.ResetRegisterNo()
		return nil
	case jobsupervisor.FieldSocialSecurityNo:
		m.ResetSocialSecurityNo()
		return nil
	case jobsupervisor.FieldSchoolGraduation:
		m.ResetSchoolGraduation()
		return nil
	case jobsupervisor.FieldYDSID:
		m.ResetYDSID()
		return nil
	case jobsupervisor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobsupervisor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobSupervisor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobSupervisorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.supervisors != nil {
		edges = append(edges, jobsupervisor.EdgeSupervisors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobSupervisorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobsupervisor.EdgeSupervisors:
		ids := make([]ent.Value, 0, len(m.supervisors))
		for id := range m.supervisors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobSupervisorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsupervisors != nil {
		edges = append(edges, jobsupervisor.EdgeSupervisors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobSupervisorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobsupervisor.EdgeSupervisors:
		ids := make([]ent.Value, 0, len(m.removedsupervisors))
		for id := range m.removedsupervisors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobSupervisorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsupervisors {
		edges = append(edges, jobsupervisor.EdgeSupervisors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobSupervisorMutation) EdgeCleared(name string) bool {
	switch name {
	case jobsupervisor.EdgeSupervisors:
		return m.clearedsupervisors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobSupervisorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobSupervisor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobSupervisorMutation) ResetEdge(name string) error {
	switch name {
	case jobsupervisor.EdgeSupervisors:
		m.ResetSupervisors()
		return nil
	}
	return fmt.Errorf("unknown JobSupervisor edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Username        *string
	_Name            *string
	_Email           *string
	_Phone           *string
	_Password        *string
	_Role            *string
	_CreatedAt       *time.Time
	_UpdatedAt       *time.Time
	clearedFields    map[string]struct{}
	companies        map[int]struct{}
	removedcompanies map[int]struct{}
	clearedcompanies bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "Username" field.
func (m *UserMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "Username" field.
func (m *UserMutation) ResetUsername() {
	m._Username = nil
}

// SetName sets the "Name" field.
func (m *UserMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *UserMutation) ResetName() {
	m._Name = nil
}

// SetEmail sets the "Email" field.
func (m *UserMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "Email" field.
func (m *UserMutation) ResetEmail() {
	m._Email = nil
}

// SetPhone sets the "Phone" field.
func (m *UserMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *UserMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *UserMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPassword sets the "Password" field.
func (m *UserMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "Password" field.
func (m *UserMutation) ResetPassword() {
	m._Password = nil
}

// SetRole sets the "Role" field.
func (m *UserMutation) SetRole(s string) {
	m._Role = &s
}

// Role returns the value of the "Role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m._Role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "Role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "Role" field.
func (m *UserMutation) ResetRole() {
	m._Role = nil
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *UserMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *UserMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddCompanyIDs adds the "companies" edge to the CompanyUser entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.companies == nil {
		m.companies = make(map[int]struct{})
	}
	for i := range ids {
		m.companies[ids[i]] = struct{}{}
	}
}

// ClearCompanies clears the "companies" edge to the CompanyUser entity.
func (m *UserMutation) ClearCompanies() {
	m.clearedcompanies = true
}

// CompaniesCleared reports if the "companies" edge to the CompanyUser entity was cleared.
func (m *UserMutation) CompaniesCleared() bool {
	return m.clearedcompanies
}

// RemoveCompanyIDs removes the "companies" edge to the CompanyUser entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompanies == nil {
		m.removedcompanies = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.companies, ids[i])
		m.removedcompanies[ids[i]] = struct{}{}
	}
}

// RemovedCompanies returns the removed IDs of the "companies" edge to the CompanyUser entity.
func (m *UserMutation) RemovedCompaniesIDs() (ids []int) {
	for id := range m.removedcompanies {
		ids = append(ids, id)
	}
	return
}

// CompaniesIDs returns the "companies" edge IDs in the mutation.
func (m *UserMutation) CompaniesIDs() (ids []int) {
	for id := range m.companies {
		ids = append(ids, id)
	}
	return
}

// ResetCompanies resets all changes to the "companies" edge.
func (m *UserMutation) ResetCompanies() {
	m.companies = nil
	m.clearedcompanies = false
	m.removedcompanies = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._Username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m._Name != nil {
		fields = append(fields, user.FieldName)
	}
	if m._Email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m._Phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m._Password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m._Role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m._CreatedAt != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.companies != nil {
		edges = append(edges, user.EdgeCompanies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCompanies:
		ids := make([]ent.Value, 0, len(m.companies))
		for id := range m.companies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcompanies != nil {
		edges = append(edges, user.EdgeCompanies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCompanies:
		ids := make([]ent.Value, 0, len(m.removedcompanies))
		for id := range m.removedcompanies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompanies {
		edges = append(edges, user.EdgeCompanies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCompanies:
		return m.clearedcompanies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCompanies:
		m.ResetCompanies()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
