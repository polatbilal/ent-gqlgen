// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"gqlgen-ent/ent/companydetail"
	"gqlgen-ent/ent/companyengineer"
	"gqlgen-ent/ent/jobauthor"
	"gqlgen-ent/ent/jobcontractor"
	"gqlgen-ent/ent/jobdetail"
	"gqlgen-ent/ent/joblayer"
	"gqlgen-ent/ent/jobowner"
	"gqlgen-ent/ent/jobprogress"
	"gqlgen-ent/ent/predicate"
	"gqlgen-ent/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompanyDetail   = "CompanyDetail"
	TypeCompanyEngineer = "CompanyEngineer"
	TypeJobAuthor       = "JobAuthor"
	TypeJobContractor   = "JobContractor"
	TypeJobDetail       = "JobDetail"
	TypeJobLayer        = "JobLayer"
	TypeJobOwner        = "JobOwner"
	TypeJobProgress     = "JobProgress"
	TypeUser            = "User"
)

// CompanyDetailMutation represents an operation that mutates the CompanyDetail nodes in the graph.
type CompanyDetailMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	_CompanyCode        *int
	add_CompanyCode     *int
	_Name               *string
	_Address            *string
	_City               *string
	_State              *string
	_Phone              *string
	_Fax                *string
	_Mobile             *string
	_Email              *string
	_Website            *string
	_TaxAdmin           *string
	_TaxNo              *int
	add_TaxNo           *int
	_Commerce           *string
	_CommerceReg        *string
	_VisaDate           *time.Time
	_CreatedAt          *time.Time
	_UpdatedAt          *time.Time
	clearedFields       map[string]struct{}
	companyOwner        *int
	clearedcompanyOwner bool
	done                bool
	oldValue            func(context.Context) (*CompanyDetail, error)
	predicates          []predicate.CompanyDetail
}

var _ ent.Mutation = (*CompanyDetailMutation)(nil)

// companydetailOption allows management of the mutation configuration using functional options.
type companydetailOption func(*CompanyDetailMutation)

// newCompanyDetailMutation creates new mutation for the CompanyDetail entity.
func newCompanyDetailMutation(c config, op Op, opts ...companydetailOption) *CompanyDetailMutation {
	m := &CompanyDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyDetailID sets the ID field of the mutation.
func withCompanyDetailID(id int) companydetailOption {
	return func(m *CompanyDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyDetail
		)
		m.oldValue = func(ctx context.Context) (*CompanyDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyDetail sets the old CompanyDetail of the mutation.
func withCompanyDetail(node *CompanyDetail) companydetailOption {
	return func(m *CompanyDetailMutation) {
		m.oldValue = func(context.Context) (*CompanyDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyCode sets the "CompanyCode" field.
func (m *CompanyDetailMutation) SetCompanyCode(i int) {
	m._CompanyCode = &i
	m.add_CompanyCode = nil
}

// CompanyCode returns the value of the "CompanyCode" field in the mutation.
func (m *CompanyDetailMutation) CompanyCode() (r int, exists bool) {
	v := m._CompanyCode
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyCode returns the old "CompanyCode" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCompanyCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyCode: %w", err)
	}
	return oldValue.CompanyCode, nil
}

// AddCompanyCode adds i to the "CompanyCode" field.
func (m *CompanyDetailMutation) AddCompanyCode(i int) {
	if m.add_CompanyCode != nil {
		*m.add_CompanyCode += i
	} else {
		m.add_CompanyCode = &i
	}
}

// AddedCompanyCode returns the value that was added to the "CompanyCode" field in this mutation.
func (m *CompanyDetailMutation) AddedCompanyCode() (r int, exists bool) {
	v := m.add_CompanyCode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCompanyCode resets all changes to the "CompanyCode" field.
func (m *CompanyDetailMutation) ResetCompanyCode() {
	m._CompanyCode = nil
	m.add_CompanyCode = nil
}

// SetName sets the "Name" field.
func (m *CompanyDetailMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CompanyDetailMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *CompanyDetailMutation) ResetName() {
	m._Name = nil
}

// SetAddress sets the "Address" field.
func (m *CompanyDetailMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *CompanyDetailMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *CompanyDetailMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[companydetail.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *CompanyDetailMutation) AddressCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *CompanyDetailMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, companydetail.FieldAddress)
}

// SetCity sets the "City" field.
func (m *CompanyDetailMutation) SetCity(s string) {
	m._City = &s
}

// City returns the value of the "City" field in the mutation.
func (m *CompanyDetailMutation) City() (r string, exists bool) {
	v := m._City
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "City" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "City" field.
func (m *CompanyDetailMutation) ClearCity() {
	m._City = nil
	m.clearedFields[companydetail.FieldCity] = struct{}{}
}

// CityCleared returns if the "City" field was cleared in this mutation.
func (m *CompanyDetailMutation) CityCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldCity]
	return ok
}

// ResetCity resets all changes to the "City" field.
func (m *CompanyDetailMutation) ResetCity() {
	m._City = nil
	delete(m.clearedFields, companydetail.FieldCity)
}

// SetState sets the "State" field.
func (m *CompanyDetailMutation) SetState(s string) {
	m._State = &s
}

// State returns the value of the "State" field in the mutation.
func (m *CompanyDetailMutation) State() (r string, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "State" field.
func (m *CompanyDetailMutation) ClearState() {
	m._State = nil
	m.clearedFields[companydetail.FieldState] = struct{}{}
}

// StateCleared returns if the "State" field was cleared in this mutation.
func (m *CompanyDetailMutation) StateCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldState]
	return ok
}

// ResetState resets all changes to the "State" field.
func (m *CompanyDetailMutation) ResetState() {
	m._State = nil
	delete(m.clearedFields, companydetail.FieldState)
}

// SetPhone sets the "Phone" field.
func (m *CompanyDetailMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *CompanyDetailMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *CompanyDetailMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[companydetail.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *CompanyDetailMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *CompanyDetailMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, companydetail.FieldPhone)
}

// SetFax sets the "Fax" field.
func (m *CompanyDetailMutation) SetFax(s string) {
	m._Fax = &s
}

// Fax returns the value of the "Fax" field in the mutation.
func (m *CompanyDetailMutation) Fax() (r string, exists bool) {
	v := m._Fax
	if v == nil {
		return
	}
	return *v, true
}

// OldFax returns the old "Fax" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldFax(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFax: %w", err)
	}
	return oldValue.Fax, nil
}

// ClearFax clears the value of the "Fax" field.
func (m *CompanyDetailMutation) ClearFax() {
	m._Fax = nil
	m.clearedFields[companydetail.FieldFax] = struct{}{}
}

// FaxCleared returns if the "Fax" field was cleared in this mutation.
func (m *CompanyDetailMutation) FaxCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldFax]
	return ok
}

// ResetFax resets all changes to the "Fax" field.
func (m *CompanyDetailMutation) ResetFax() {
	m._Fax = nil
	delete(m.clearedFields, companydetail.FieldFax)
}

// SetMobile sets the "Mobile" field.
func (m *CompanyDetailMutation) SetMobile(s string) {
	m._Mobile = &s
}

// Mobile returns the value of the "Mobile" field in the mutation.
func (m *CompanyDetailMutation) Mobile() (r string, exists bool) {
	v := m._Mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "Mobile" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ClearMobile clears the value of the "Mobile" field.
func (m *CompanyDetailMutation) ClearMobile() {
	m._Mobile = nil
	m.clearedFields[companydetail.FieldMobile] = struct{}{}
}

// MobileCleared returns if the "Mobile" field was cleared in this mutation.
func (m *CompanyDetailMutation) MobileCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldMobile]
	return ok
}

// ResetMobile resets all changes to the "Mobile" field.
func (m *CompanyDetailMutation) ResetMobile() {
	m._Mobile = nil
	delete(m.clearedFields, companydetail.FieldMobile)
}

// SetEmail sets the "Email" field.
func (m *CompanyDetailMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *CompanyDetailMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *CompanyDetailMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[companydetail.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *CompanyDetailMutation) EmailCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *CompanyDetailMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, companydetail.FieldEmail)
}

// SetWebsite sets the "Website" field.
func (m *CompanyDetailMutation) SetWebsite(s string) {
	m._Website = &s
}

// Website returns the value of the "Website" field in the mutation.
func (m *CompanyDetailMutation) Website() (r string, exists bool) {
	v := m._Website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "Website" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "Website" field.
func (m *CompanyDetailMutation) ClearWebsite() {
	m._Website = nil
	m.clearedFields[companydetail.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "Website" field was cleared in this mutation.
func (m *CompanyDetailMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "Website" field.
func (m *CompanyDetailMutation) ResetWebsite() {
	m._Website = nil
	delete(m.clearedFields, companydetail.FieldWebsite)
}

// SetTaxAdmin sets the "TaxAdmin" field.
func (m *CompanyDetailMutation) SetTaxAdmin(s string) {
	m._TaxAdmin = &s
}

// TaxAdmin returns the value of the "TaxAdmin" field in the mutation.
func (m *CompanyDetailMutation) TaxAdmin() (r string, exists bool) {
	v := m._TaxAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAdmin returns the old "TaxAdmin" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldTaxAdmin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAdmin: %w", err)
	}
	return oldValue.TaxAdmin, nil
}

// ClearTaxAdmin clears the value of the "TaxAdmin" field.
func (m *CompanyDetailMutation) ClearTaxAdmin() {
	m._TaxAdmin = nil
	m.clearedFields[companydetail.FieldTaxAdmin] = struct{}{}
}

// TaxAdminCleared returns if the "TaxAdmin" field was cleared in this mutation.
func (m *CompanyDetailMutation) TaxAdminCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldTaxAdmin]
	return ok
}

// ResetTaxAdmin resets all changes to the "TaxAdmin" field.
func (m *CompanyDetailMutation) ResetTaxAdmin() {
	m._TaxAdmin = nil
	delete(m.clearedFields, companydetail.FieldTaxAdmin)
}

// SetTaxNo sets the "TaxNo" field.
func (m *CompanyDetailMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *CompanyDetailMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *CompanyDetailMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *CompanyDetailMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *CompanyDetailMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[companydetail.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *CompanyDetailMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *CompanyDetailMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, companydetail.FieldTaxNo)
}

// SetCommerce sets the "Commerce" field.
func (m *CompanyDetailMutation) SetCommerce(s string) {
	m._Commerce = &s
}

// Commerce returns the value of the "Commerce" field in the mutation.
func (m *CompanyDetailMutation) Commerce() (r string, exists bool) {
	v := m._Commerce
	if v == nil {
		return
	}
	return *v, true
}

// OldCommerce returns the old "Commerce" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCommerce(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommerce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommerce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommerce: %w", err)
	}
	return oldValue.Commerce, nil
}

// ClearCommerce clears the value of the "Commerce" field.
func (m *CompanyDetailMutation) ClearCommerce() {
	m._Commerce = nil
	m.clearedFields[companydetail.FieldCommerce] = struct{}{}
}

// CommerceCleared returns if the "Commerce" field was cleared in this mutation.
func (m *CompanyDetailMutation) CommerceCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldCommerce]
	return ok
}

// ResetCommerce resets all changes to the "Commerce" field.
func (m *CompanyDetailMutation) ResetCommerce() {
	m._Commerce = nil
	delete(m.clearedFields, companydetail.FieldCommerce)
}

// SetCommerceReg sets the "CommerceReg" field.
func (m *CompanyDetailMutation) SetCommerceReg(s string) {
	m._CommerceReg = &s
}

// CommerceReg returns the value of the "CommerceReg" field in the mutation.
func (m *CompanyDetailMutation) CommerceReg() (r string, exists bool) {
	v := m._CommerceReg
	if v == nil {
		return
	}
	return *v, true
}

// OldCommerceReg returns the old "CommerceReg" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCommerceReg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommerceReg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommerceReg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommerceReg: %w", err)
	}
	return oldValue.CommerceReg, nil
}

// ClearCommerceReg clears the value of the "CommerceReg" field.
func (m *CompanyDetailMutation) ClearCommerceReg() {
	m._CommerceReg = nil
	m.clearedFields[companydetail.FieldCommerceReg] = struct{}{}
}

// CommerceRegCleared returns if the "CommerceReg" field was cleared in this mutation.
func (m *CompanyDetailMutation) CommerceRegCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldCommerceReg]
	return ok
}

// ResetCommerceReg resets all changes to the "CommerceReg" field.
func (m *CompanyDetailMutation) ResetCommerceReg() {
	m._CommerceReg = nil
	delete(m.clearedFields, companydetail.FieldCommerceReg)
}

// SetVisaDate sets the "VisaDate" field.
func (m *CompanyDetailMutation) SetVisaDate(t time.Time) {
	m._VisaDate = &t
}

// VisaDate returns the value of the "VisaDate" field in the mutation.
func (m *CompanyDetailMutation) VisaDate() (r time.Time, exists bool) {
	v := m._VisaDate
	if v == nil {
		return
	}
	return *v, true
}

// OldVisaDate returns the old "VisaDate" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldVisaDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisaDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisaDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisaDate: %w", err)
	}
	return oldValue.VisaDate, nil
}

// ClearVisaDate clears the value of the "VisaDate" field.
func (m *CompanyDetailMutation) ClearVisaDate() {
	m._VisaDate = nil
	m.clearedFields[companydetail.FieldVisaDate] = struct{}{}
}

// VisaDateCleared returns if the "VisaDate" field was cleared in this mutation.
func (m *CompanyDetailMutation) VisaDateCleared() bool {
	_, ok := m.clearedFields[companydetail.FieldVisaDate]
	return ok
}

// ResetVisaDate resets all changes to the "VisaDate" field.
func (m *CompanyDetailMutation) ResetVisaDate() {
	m._VisaDate = nil
	delete(m.clearedFields, companydetail.FieldVisaDate)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CompanyDetailMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CompanyDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CompanyDetailMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CompanyDetailMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CompanyDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the CompanyDetail entity.
// If the CompanyDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CompanyDetailMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// SetCompanyOwnerID sets the "companyOwner" edge to the CompanyEngineer entity by id.
func (m *CompanyDetailMutation) SetCompanyOwnerID(id int) {
	m.companyOwner = &id
}

// ClearCompanyOwner clears the "companyOwner" edge to the CompanyEngineer entity.
func (m *CompanyDetailMutation) ClearCompanyOwner() {
	m.clearedcompanyOwner = true
}

// CompanyOwnerCleared reports if the "companyOwner" edge to the CompanyEngineer entity was cleared.
func (m *CompanyDetailMutation) CompanyOwnerCleared() bool {
	return m.clearedcompanyOwner
}

// CompanyOwnerID returns the "companyOwner" edge ID in the mutation.
func (m *CompanyDetailMutation) CompanyOwnerID() (id int, exists bool) {
	if m.companyOwner != nil {
		return *m.companyOwner, true
	}
	return
}

// CompanyOwnerIDs returns the "companyOwner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyOwnerID instead. It exists only for internal usage by the builders.
func (m *CompanyDetailMutation) CompanyOwnerIDs() (ids []int) {
	if id := m.companyOwner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompanyOwner resets all changes to the "companyOwner" edge.
func (m *CompanyDetailMutation) ResetCompanyOwner() {
	m.companyOwner = nil
	m.clearedcompanyOwner = false
}

// Where appends a list predicates to the CompanyDetailMutation builder.
func (m *CompanyDetailMutation) Where(ps ...predicate.CompanyDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyDetail).
func (m *CompanyDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyDetailMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m._CompanyCode != nil {
		fields = append(fields, companydetail.FieldCompanyCode)
	}
	if m._Name != nil {
		fields = append(fields, companydetail.FieldName)
	}
	if m._Address != nil {
		fields = append(fields, companydetail.FieldAddress)
	}
	if m._City != nil {
		fields = append(fields, companydetail.FieldCity)
	}
	if m._State != nil {
		fields = append(fields, companydetail.FieldState)
	}
	if m._Phone != nil {
		fields = append(fields, companydetail.FieldPhone)
	}
	if m._Fax != nil {
		fields = append(fields, companydetail.FieldFax)
	}
	if m._Mobile != nil {
		fields = append(fields, companydetail.FieldMobile)
	}
	if m._Email != nil {
		fields = append(fields, companydetail.FieldEmail)
	}
	if m._Website != nil {
		fields = append(fields, companydetail.FieldWebsite)
	}
	if m._TaxAdmin != nil {
		fields = append(fields, companydetail.FieldTaxAdmin)
	}
	if m._TaxNo != nil {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	if m._Commerce != nil {
		fields = append(fields, companydetail.FieldCommerce)
	}
	if m._CommerceReg != nil {
		fields = append(fields, companydetail.FieldCommerceReg)
	}
	if m._VisaDate != nil {
		fields = append(fields, companydetail.FieldVisaDate)
	}
	if m._CreatedAt != nil {
		fields = append(fields, companydetail.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, companydetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.CompanyCode()
	case companydetail.FieldName:
		return m.Name()
	case companydetail.FieldAddress:
		return m.Address()
	case companydetail.FieldCity:
		return m.City()
	case companydetail.FieldState:
		return m.State()
	case companydetail.FieldPhone:
		return m.Phone()
	case companydetail.FieldFax:
		return m.Fax()
	case companydetail.FieldMobile:
		return m.Mobile()
	case companydetail.FieldEmail:
		return m.Email()
	case companydetail.FieldWebsite:
		return m.Website()
	case companydetail.FieldTaxAdmin:
		return m.TaxAdmin()
	case companydetail.FieldTaxNo:
		return m.TaxNo()
	case companydetail.FieldCommerce:
		return m.Commerce()
	case companydetail.FieldCommerceReg:
		return m.CommerceReg()
	case companydetail.FieldVisaDate:
		return m.VisaDate()
	case companydetail.FieldCreatedAt:
		return m.CreatedAt()
	case companydetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.OldCompanyCode(ctx)
	case companydetail.FieldName:
		return m.OldName(ctx)
	case companydetail.FieldAddress:
		return m.OldAddress(ctx)
	case companydetail.FieldCity:
		return m.OldCity(ctx)
	case companydetail.FieldState:
		return m.OldState(ctx)
	case companydetail.FieldPhone:
		return m.OldPhone(ctx)
	case companydetail.FieldFax:
		return m.OldFax(ctx)
	case companydetail.FieldMobile:
		return m.OldMobile(ctx)
	case companydetail.FieldEmail:
		return m.OldEmail(ctx)
	case companydetail.FieldWebsite:
		return m.OldWebsite(ctx)
	case companydetail.FieldTaxAdmin:
		return m.OldTaxAdmin(ctx)
	case companydetail.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case companydetail.FieldCommerce:
		return m.OldCommerce(ctx)
	case companydetail.FieldCommerceReg:
		return m.OldCommerceReg(ctx)
	case companydetail.FieldVisaDate:
		return m.OldVisaDate(ctx)
	case companydetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companydetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companydetail.FieldCompanyCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyCode(v)
		return nil
	case companydetail.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case companydetail.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case companydetail.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case companydetail.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case companydetail.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case companydetail.FieldFax:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFax(v)
		return nil
	case companydetail.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case companydetail.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case companydetail.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case companydetail.FieldTaxAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAdmin(v)
		return nil
	case companydetail.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case companydetail.FieldCommerce:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommerce(v)
		return nil
	case companydetail.FieldCommerceReg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommerceReg(v)
		return nil
	case companydetail.FieldVisaDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisaDate(v)
		return nil
	case companydetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companydetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_CompanyCode != nil {
		fields = append(fields, companydetail.FieldCompanyCode)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companydetail.FieldCompanyCode:
		return m.AddedCompanyCode()
	case companydetail.FieldTaxNo:
		return m.AddedTaxNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companydetail.FieldCompanyCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCompanyCode(v)
		return nil
	case companydetail.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companydetail.FieldAddress) {
		fields = append(fields, companydetail.FieldAddress)
	}
	if m.FieldCleared(companydetail.FieldCity) {
		fields = append(fields, companydetail.FieldCity)
	}
	if m.FieldCleared(companydetail.FieldState) {
		fields = append(fields, companydetail.FieldState)
	}
	if m.FieldCleared(companydetail.FieldPhone) {
		fields = append(fields, companydetail.FieldPhone)
	}
	if m.FieldCleared(companydetail.FieldFax) {
		fields = append(fields, companydetail.FieldFax)
	}
	if m.FieldCleared(companydetail.FieldMobile) {
		fields = append(fields, companydetail.FieldMobile)
	}
	if m.FieldCleared(companydetail.FieldEmail) {
		fields = append(fields, companydetail.FieldEmail)
	}
	if m.FieldCleared(companydetail.FieldWebsite) {
		fields = append(fields, companydetail.FieldWebsite)
	}
	if m.FieldCleared(companydetail.FieldTaxAdmin) {
		fields = append(fields, companydetail.FieldTaxAdmin)
	}
	if m.FieldCleared(companydetail.FieldTaxNo) {
		fields = append(fields, companydetail.FieldTaxNo)
	}
	if m.FieldCleared(companydetail.FieldCommerce) {
		fields = append(fields, companydetail.FieldCommerce)
	}
	if m.FieldCleared(companydetail.FieldCommerceReg) {
		fields = append(fields, companydetail.FieldCommerceReg)
	}
	if m.FieldCleared(companydetail.FieldVisaDate) {
		fields = append(fields, companydetail.FieldVisaDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyDetailMutation) ClearField(name string) error {
	switch name {
	case companydetail.FieldAddress:
		m.ClearAddress()
		return nil
	case companydetail.FieldCity:
		m.ClearCity()
		return nil
	case companydetail.FieldState:
		m.ClearState()
		return nil
	case companydetail.FieldPhone:
		m.ClearPhone()
		return nil
	case companydetail.FieldFax:
		m.ClearFax()
		return nil
	case companydetail.FieldMobile:
		m.ClearMobile()
		return nil
	case companydetail.FieldEmail:
		m.ClearEmail()
		return nil
	case companydetail.FieldWebsite:
		m.ClearWebsite()
		return nil
	case companydetail.FieldTaxAdmin:
		m.ClearTaxAdmin()
		return nil
	case companydetail.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case companydetail.FieldCommerce:
		m.ClearCommerce()
		return nil
	case companydetail.FieldCommerceReg:
		m.ClearCommerceReg()
		return nil
	case companydetail.FieldVisaDate:
		m.ClearVisaDate()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyDetailMutation) ResetField(name string) error {
	switch name {
	case companydetail.FieldCompanyCode:
		m.ResetCompanyCode()
		return nil
	case companydetail.FieldName:
		m.ResetName()
		return nil
	case companydetail.FieldAddress:
		m.ResetAddress()
		return nil
	case companydetail.FieldCity:
		m.ResetCity()
		return nil
	case companydetail.FieldState:
		m.ResetState()
		return nil
	case companydetail.FieldPhone:
		m.ResetPhone()
		return nil
	case companydetail.FieldFax:
		m.ResetFax()
		return nil
	case companydetail.FieldMobile:
		m.ResetMobile()
		return nil
	case companydetail.FieldEmail:
		m.ResetEmail()
		return nil
	case companydetail.FieldWebsite:
		m.ResetWebsite()
		return nil
	case companydetail.FieldTaxAdmin:
		m.ResetTaxAdmin()
		return nil
	case companydetail.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case companydetail.FieldCommerce:
		m.ResetCommerce()
		return nil
	case companydetail.FieldCommerceReg:
		m.ResetCommerceReg()
		return nil
	case companydetail.FieldVisaDate:
		m.ResetVisaDate()
		return nil
	case companydetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companydetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.companyOwner != nil {
		edges = append(edges, companydetail.EdgeCompanyOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companydetail.EdgeCompanyOwner:
		if id := m.companyOwner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcompanyOwner {
		edges = append(edges, companydetail.EdgeCompanyOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case companydetail.EdgeCompanyOwner:
		return m.clearedcompanyOwner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyDetailMutation) ClearEdge(name string) error {
	switch name {
	case companydetail.EdgeCompanyOwner:
		m.ClearCompanyOwner()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyDetailMutation) ResetEdge(name string) error {
	switch name {
	case companydetail.EdgeCompanyOwner:
		m.ResetCompanyOwner()
		return nil
	}
	return fmt.Errorf("unknown CompanyDetail edge %s", name)
}

// CompanyEngineerMutation represents an operation that mutates the CompanyEngineer nodes in the graph.
type CompanyEngineerMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Name                      *string
	_Address                   *string
	_Email                     *string
	_TcNo                      *int
	add_TcNo                   *int
	_Phone                     *string
	_RegNo                     *int
	add_RegNo                  *int
	_CertNo                    *int
	add_CertNo                 *int
	_Career                    *string
	_Position                  *string
	_Note                      *string
	_Status                    *int
	add_Status                 *int
	_Deleted                   *int
	add_Deleted                *int
	_Employment                *time.Time
	_Dismissal                 *time.Time
	_CreatedAt                 *time.Time
	_UpdatedAt                 *time.Time
	clearedFields              map[string]struct{}
	companyOwners              map[int]struct{}
	removedcompanyOwners       map[int]struct{}
	clearedcompanyOwners       bool
	inspectors                 map[int]struct{}
	removedinspectors          map[int]struct{}
	clearedinspectors          bool
	architects                 map[int]struct{}
	removedarchitects          map[int]struct{}
	clearedarchitects          bool
	statics                    map[int]struct{}
	removedstatics             map[int]struct{}
	clearedstatics             bool
	mechanics                  map[int]struct{}
	removedmechanics           map[int]struct{}
	clearedmechanics           bool
	electrics                  map[int]struct{}
	removedelectrics           map[int]struct{}
	clearedelectrics           bool
	controllers                map[int]struct{}
	removedcontrollers         map[int]struct{}
	clearedcontrollers         bool
	mechaniccontrollers        map[int]struct{}
	removedmechaniccontrollers map[int]struct{}
	clearedmechaniccontrollers bool
	electriccontrollers        map[int]struct{}
	removedelectriccontrollers map[int]struct{}
	clearedelectriccontrollers bool
	done                       bool
	oldValue                   func(context.Context) (*CompanyEngineer, error)
	predicates                 []predicate.CompanyEngineer
}

var _ ent.Mutation = (*CompanyEngineerMutation)(nil)

// companyengineerOption allows management of the mutation configuration using functional options.
type companyengineerOption func(*CompanyEngineerMutation)

// newCompanyEngineerMutation creates new mutation for the CompanyEngineer entity.
func newCompanyEngineerMutation(c config, op Op, opts ...companyengineerOption) *CompanyEngineerMutation {
	m := &CompanyEngineerMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyEngineer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyEngineerID sets the ID field of the mutation.
func withCompanyEngineerID(id int) companyengineerOption {
	return func(m *CompanyEngineerMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyEngineer
		)
		m.oldValue = func(ctx context.Context) (*CompanyEngineer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyEngineer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyEngineer sets the old CompanyEngineer of the mutation.
func withCompanyEngineer(node *CompanyEngineer) companyengineerOption {
	return func(m *CompanyEngineerMutation) {
		m.oldValue = func(context.Context) (*CompanyEngineer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyEngineerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyEngineerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyEngineerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyEngineerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyEngineer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *CompanyEngineerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *CompanyEngineerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *CompanyEngineerMutation) ResetName() {
	m._Name = nil
}

// SetAddress sets the "Address" field.
func (m *CompanyEngineerMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *CompanyEngineerMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *CompanyEngineerMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[companyengineer.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *CompanyEngineerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *CompanyEngineerMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, companyengineer.FieldAddress)
}

// SetEmail sets the "Email" field.
func (m *CompanyEngineerMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *CompanyEngineerMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *CompanyEngineerMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[companyengineer.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *CompanyEngineerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *CompanyEngineerMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, companyengineer.FieldEmail)
}

// SetTcNo sets the "TcNo" field.
func (m *CompanyEngineerMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *CompanyEngineerMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *CompanyEngineerMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *CompanyEngineerMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[companyengineer.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *CompanyEngineerMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, companyengineer.FieldTcNo)
}

// SetPhone sets the "Phone" field.
func (m *CompanyEngineerMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *CompanyEngineerMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *CompanyEngineerMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[companyengineer.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *CompanyEngineerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *CompanyEngineerMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, companyengineer.FieldPhone)
}

// SetRegNo sets the "RegNo" field.
func (m *CompanyEngineerMutation) SetRegNo(i int) {
	m._RegNo = &i
	m.add_RegNo = nil
}

// RegNo returns the value of the "RegNo" field in the mutation.
func (m *CompanyEngineerMutation) RegNo() (r int, exists bool) {
	v := m._RegNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRegNo returns the old "RegNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldRegNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegNo: %w", err)
	}
	return oldValue.RegNo, nil
}

// AddRegNo adds i to the "RegNo" field.
func (m *CompanyEngineerMutation) AddRegNo(i int) {
	if m.add_RegNo != nil {
		*m.add_RegNo += i
	} else {
		m.add_RegNo = &i
	}
}

// AddedRegNo returns the value that was added to the "RegNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedRegNo() (r int, exists bool) {
	v := m.add_RegNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegNo clears the value of the "RegNo" field.
func (m *CompanyEngineerMutation) ClearRegNo() {
	m._RegNo = nil
	m.add_RegNo = nil
	m.clearedFields[companyengineer.FieldRegNo] = struct{}{}
}

// RegNoCleared returns if the "RegNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) RegNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldRegNo]
	return ok
}

// ResetRegNo resets all changes to the "RegNo" field.
func (m *CompanyEngineerMutation) ResetRegNo() {
	m._RegNo = nil
	m.add_RegNo = nil
	delete(m.clearedFields, companyengineer.FieldRegNo)
}

// SetCertNo sets the "CertNo" field.
func (m *CompanyEngineerMutation) SetCertNo(i int) {
	m._CertNo = &i
	m.add_CertNo = nil
}

// CertNo returns the value of the "CertNo" field in the mutation.
func (m *CompanyEngineerMutation) CertNo() (r int, exists bool) {
	v := m._CertNo
	if v == nil {
		return
	}
	return *v, true
}

// OldCertNo returns the old "CertNo" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCertNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertNo: %w", err)
	}
	return oldValue.CertNo, nil
}

// AddCertNo adds i to the "CertNo" field.
func (m *CompanyEngineerMutation) AddCertNo(i int) {
	if m.add_CertNo != nil {
		*m.add_CertNo += i
	} else {
		m.add_CertNo = &i
	}
}

// AddedCertNo returns the value that was added to the "CertNo" field in this mutation.
func (m *CompanyEngineerMutation) AddedCertNo() (r int, exists bool) {
	v := m.add_CertNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearCertNo clears the value of the "CertNo" field.
func (m *CompanyEngineerMutation) ClearCertNo() {
	m._CertNo = nil
	m.add_CertNo = nil
	m.clearedFields[companyengineer.FieldCertNo] = struct{}{}
}

// CertNoCleared returns if the "CertNo" field was cleared in this mutation.
func (m *CompanyEngineerMutation) CertNoCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldCertNo]
	return ok
}

// ResetCertNo resets all changes to the "CertNo" field.
func (m *CompanyEngineerMutation) ResetCertNo() {
	m._CertNo = nil
	m.add_CertNo = nil
	delete(m.clearedFields, companyengineer.FieldCertNo)
}

// SetCareer sets the "Career" field.
func (m *CompanyEngineerMutation) SetCareer(s string) {
	m._Career = &s
}

// Career returns the value of the "Career" field in the mutation.
func (m *CompanyEngineerMutation) Career() (r string, exists bool) {
	v := m._Career
	if v == nil {
		return
	}
	return *v, true
}

// OldCareer returns the old "Career" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCareer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCareer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCareer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCareer: %w", err)
	}
	return oldValue.Career, nil
}

// ClearCareer clears the value of the "Career" field.
func (m *CompanyEngineerMutation) ClearCareer() {
	m._Career = nil
	m.clearedFields[companyengineer.FieldCareer] = struct{}{}
}

// CareerCleared returns if the "Career" field was cleared in this mutation.
func (m *CompanyEngineerMutation) CareerCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldCareer]
	return ok
}

// ResetCareer resets all changes to the "Career" field.
func (m *CompanyEngineerMutation) ResetCareer() {
	m._Career = nil
	delete(m.clearedFields, companyengineer.FieldCareer)
}

// SetPosition sets the "Position" field.
func (m *CompanyEngineerMutation) SetPosition(s string) {
	m._Position = &s
}

// Position returns the value of the "Position" field in the mutation.
func (m *CompanyEngineerMutation) Position() (r string, exists bool) {
	v := m._Position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "Position" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ClearPosition clears the value of the "Position" field.
func (m *CompanyEngineerMutation) ClearPosition() {
	m._Position = nil
	m.clearedFields[companyengineer.FieldPosition] = struct{}{}
}

// PositionCleared returns if the "Position" field was cleared in this mutation.
func (m *CompanyEngineerMutation) PositionCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldPosition]
	return ok
}

// ResetPosition resets all changes to the "Position" field.
func (m *CompanyEngineerMutation) ResetPosition() {
	m._Position = nil
	delete(m.clearedFields, companyengineer.FieldPosition)
}

// SetNote sets the "Note" field.
func (m *CompanyEngineerMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *CompanyEngineerMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *CompanyEngineerMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[companyengineer.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *CompanyEngineerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *CompanyEngineerMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, companyengineer.FieldNote)
}

// SetStatus sets the "Status" field.
func (m *CompanyEngineerMutation) SetStatus(i int) {
	m._Status = &i
	m.add_Status = nil
}

// Status returns the value of the "Status" field in the mutation.
func (m *CompanyEngineerMutation) Status() (r int, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "Status" field.
func (m *CompanyEngineerMutation) AddStatus(i int) {
	if m.add_Status != nil {
		*m.add_Status += i
	} else {
		m.add_Status = &i
	}
}

// AddedStatus returns the value that was added to the "Status" field in this mutation.
func (m *CompanyEngineerMutation) AddedStatus() (r int, exists bool) {
	v := m.add_Status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "Status" field.
func (m *CompanyEngineerMutation) ResetStatus() {
	m._Status = nil
	m.add_Status = nil
}

// SetDeleted sets the "Deleted" field.
func (m *CompanyEngineerMutation) SetDeleted(i int) {
	m._Deleted = &i
	m.add_Deleted = nil
}

// Deleted returns the value of the "Deleted" field in the mutation.
func (m *CompanyEngineerMutation) Deleted() (r int, exists bool) {
	v := m._Deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "Deleted" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to the "Deleted" field.
func (m *CompanyEngineerMutation) AddDeleted(i int) {
	if m.add_Deleted != nil {
		*m.add_Deleted += i
	} else {
		m.add_Deleted = &i
	}
}

// AddedDeleted returns the value that was added to the "Deleted" field in this mutation.
func (m *CompanyEngineerMutation) AddedDeleted() (r int, exists bool) {
	v := m.add_Deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted resets all changes to the "Deleted" field.
func (m *CompanyEngineerMutation) ResetDeleted() {
	m._Deleted = nil
	m.add_Deleted = nil
}

// SetEmployment sets the "Employment" field.
func (m *CompanyEngineerMutation) SetEmployment(t time.Time) {
	m._Employment = &t
}

// Employment returns the value of the "Employment" field in the mutation.
func (m *CompanyEngineerMutation) Employment() (r time.Time, exists bool) {
	v := m._Employment
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployment returns the old "Employment" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldEmployment(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployment: %w", err)
	}
	return oldValue.Employment, nil
}

// ClearEmployment clears the value of the "Employment" field.
func (m *CompanyEngineerMutation) ClearEmployment() {
	m._Employment = nil
	m.clearedFields[companyengineer.FieldEmployment] = struct{}{}
}

// EmploymentCleared returns if the "Employment" field was cleared in this mutation.
func (m *CompanyEngineerMutation) EmploymentCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldEmployment]
	return ok
}

// ResetEmployment resets all changes to the "Employment" field.
func (m *CompanyEngineerMutation) ResetEmployment() {
	m._Employment = nil
	delete(m.clearedFields, companyengineer.FieldEmployment)
}

// SetDismissal sets the "Dismissal" field.
func (m *CompanyEngineerMutation) SetDismissal(t time.Time) {
	m._Dismissal = &t
}

// Dismissal returns the value of the "Dismissal" field in the mutation.
func (m *CompanyEngineerMutation) Dismissal() (r time.Time, exists bool) {
	v := m._Dismissal
	if v == nil {
		return
	}
	return *v, true
}

// OldDismissal returns the old "Dismissal" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldDismissal(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDismissal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDismissal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDismissal: %w", err)
	}
	return oldValue.Dismissal, nil
}

// ClearDismissal clears the value of the "Dismissal" field.
func (m *CompanyEngineerMutation) ClearDismissal() {
	m._Dismissal = nil
	m.clearedFields[companyengineer.FieldDismissal] = struct{}{}
}

// DismissalCleared returns if the "Dismissal" field was cleared in this mutation.
func (m *CompanyEngineerMutation) DismissalCleared() bool {
	_, ok := m.clearedFields[companyengineer.FieldDismissal]
	return ok
}

// ResetDismissal resets all changes to the "Dismissal" field.
func (m *CompanyEngineerMutation) ResetDismissal() {
	m._Dismissal = nil
	delete(m.clearedFields, companyengineer.FieldDismissal)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *CompanyEngineerMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *CompanyEngineerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *CompanyEngineerMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *CompanyEngineerMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *CompanyEngineerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the CompanyEngineer entity.
// If the CompanyEngineer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyEngineerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *CompanyEngineerMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddCompanyOwnerIDs adds the "companyOwners" edge to the CompanyDetail entity by ids.
func (m *CompanyEngineerMutation) AddCompanyOwnerIDs(ids ...int) {
	if m.companyOwners == nil {
		m.companyOwners = make(map[int]struct{})
	}
	for i := range ids {
		m.companyOwners[ids[i]] = struct{}{}
	}
}

// ClearCompanyOwners clears the "companyOwners" edge to the CompanyDetail entity.
func (m *CompanyEngineerMutation) ClearCompanyOwners() {
	m.clearedcompanyOwners = true
}

// CompanyOwnersCleared reports if the "companyOwners" edge to the CompanyDetail entity was cleared.
func (m *CompanyEngineerMutation) CompanyOwnersCleared() bool {
	return m.clearedcompanyOwners
}

// RemoveCompanyOwnerIDs removes the "companyOwners" edge to the CompanyDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveCompanyOwnerIDs(ids ...int) {
	if m.removedcompanyOwners == nil {
		m.removedcompanyOwners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.companyOwners, ids[i])
		m.removedcompanyOwners[ids[i]] = struct{}{}
	}
}

// RemovedCompanyOwners returns the removed IDs of the "companyOwners" edge to the CompanyDetail entity.
func (m *CompanyEngineerMutation) RemovedCompanyOwnersIDs() (ids []int) {
	for id := range m.removedcompanyOwners {
		ids = append(ids, id)
	}
	return
}

// CompanyOwnersIDs returns the "companyOwners" edge IDs in the mutation.
func (m *CompanyEngineerMutation) CompanyOwnersIDs() (ids []int) {
	for id := range m.companyOwners {
		ids = append(ids, id)
	}
	return
}

// ResetCompanyOwners resets all changes to the "companyOwners" edge.
func (m *CompanyEngineerMutation) ResetCompanyOwners() {
	m.companyOwners = nil
	m.clearedcompanyOwners = false
	m.removedcompanyOwners = nil
}

// AddInspectorIDs adds the "inspectors" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddInspectorIDs(ids ...int) {
	if m.inspectors == nil {
		m.inspectors = make(map[int]struct{})
	}
	for i := range ids {
		m.inspectors[ids[i]] = struct{}{}
	}
}

// ClearInspectors clears the "inspectors" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearInspectors() {
	m.clearedinspectors = true
}

// InspectorsCleared reports if the "inspectors" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) InspectorsCleared() bool {
	return m.clearedinspectors
}

// RemoveInspectorIDs removes the "inspectors" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveInspectorIDs(ids ...int) {
	if m.removedinspectors == nil {
		m.removedinspectors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inspectors, ids[i])
		m.removedinspectors[ids[i]] = struct{}{}
	}
}

// RemovedInspectors returns the removed IDs of the "inspectors" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedInspectorsIDs() (ids []int) {
	for id := range m.removedinspectors {
		ids = append(ids, id)
	}
	return
}

// InspectorsIDs returns the "inspectors" edge IDs in the mutation.
func (m *CompanyEngineerMutation) InspectorsIDs() (ids []int) {
	for id := range m.inspectors {
		ids = append(ids, id)
	}
	return
}

// ResetInspectors resets all changes to the "inspectors" edge.
func (m *CompanyEngineerMutation) ResetInspectors() {
	m.inspectors = nil
	m.clearedinspectors = false
	m.removedinspectors = nil
}

// AddArchitectIDs adds the "architects" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddArchitectIDs(ids ...int) {
	if m.architects == nil {
		m.architects = make(map[int]struct{})
	}
	for i := range ids {
		m.architects[ids[i]] = struct{}{}
	}
}

// ClearArchitects clears the "architects" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearArchitects() {
	m.clearedarchitects = true
}

// ArchitectsCleared reports if the "architects" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ArchitectsCleared() bool {
	return m.clearedarchitects
}

// RemoveArchitectIDs removes the "architects" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveArchitectIDs(ids ...int) {
	if m.removedarchitects == nil {
		m.removedarchitects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.architects, ids[i])
		m.removedarchitects[ids[i]] = struct{}{}
	}
}

// RemovedArchitects returns the removed IDs of the "architects" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedArchitectsIDs() (ids []int) {
	for id := range m.removedarchitects {
		ids = append(ids, id)
	}
	return
}

// ArchitectsIDs returns the "architects" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ArchitectsIDs() (ids []int) {
	for id := range m.architects {
		ids = append(ids, id)
	}
	return
}

// ResetArchitects resets all changes to the "architects" edge.
func (m *CompanyEngineerMutation) ResetArchitects() {
	m.architects = nil
	m.clearedarchitects = false
	m.removedarchitects = nil
}

// AddStaticIDs adds the "statics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddStaticIDs(ids ...int) {
	if m.statics == nil {
		m.statics = make(map[int]struct{})
	}
	for i := range ids {
		m.statics[ids[i]] = struct{}{}
	}
}

// ClearStatics clears the "statics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearStatics() {
	m.clearedstatics = true
}

// StaticsCleared reports if the "statics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) StaticsCleared() bool {
	return m.clearedstatics
}

// RemoveStaticIDs removes the "statics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveStaticIDs(ids ...int) {
	if m.removedstatics == nil {
		m.removedstatics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.statics, ids[i])
		m.removedstatics[ids[i]] = struct{}{}
	}
}

// RemovedStatics returns the removed IDs of the "statics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedStaticsIDs() (ids []int) {
	for id := range m.removedstatics {
		ids = append(ids, id)
	}
	return
}

// StaticsIDs returns the "statics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) StaticsIDs() (ids []int) {
	for id := range m.statics {
		ids = append(ids, id)
	}
	return
}

// ResetStatics resets all changes to the "statics" edge.
func (m *CompanyEngineerMutation) ResetStatics() {
	m.statics = nil
	m.clearedstatics = false
	m.removedstatics = nil
}

// AddMechanicIDs adds the "mechanics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddMechanicIDs(ids ...int) {
	if m.mechanics == nil {
		m.mechanics = make(map[int]struct{})
	}
	for i := range ids {
		m.mechanics[ids[i]] = struct{}{}
	}
}

// ClearMechanics clears the "mechanics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearMechanics() {
	m.clearedmechanics = true
}

// MechanicsCleared reports if the "mechanics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) MechanicsCleared() bool {
	return m.clearedmechanics
}

// RemoveMechanicIDs removes the "mechanics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveMechanicIDs(ids ...int) {
	if m.removedmechanics == nil {
		m.removedmechanics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mechanics, ids[i])
		m.removedmechanics[ids[i]] = struct{}{}
	}
}

// RemovedMechanics returns the removed IDs of the "mechanics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedMechanicsIDs() (ids []int) {
	for id := range m.removedmechanics {
		ids = append(ids, id)
	}
	return
}

// MechanicsIDs returns the "mechanics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) MechanicsIDs() (ids []int) {
	for id := range m.mechanics {
		ids = append(ids, id)
	}
	return
}

// ResetMechanics resets all changes to the "mechanics" edge.
func (m *CompanyEngineerMutation) ResetMechanics() {
	m.mechanics = nil
	m.clearedmechanics = false
	m.removedmechanics = nil
}

// AddElectricIDs adds the "electrics" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddElectricIDs(ids ...int) {
	if m.electrics == nil {
		m.electrics = make(map[int]struct{})
	}
	for i := range ids {
		m.electrics[ids[i]] = struct{}{}
	}
}

// ClearElectrics clears the "electrics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearElectrics() {
	m.clearedelectrics = true
}

// ElectricsCleared reports if the "electrics" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ElectricsCleared() bool {
	return m.clearedelectrics
}

// RemoveElectricIDs removes the "electrics" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveElectricIDs(ids ...int) {
	if m.removedelectrics == nil {
		m.removedelectrics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.electrics, ids[i])
		m.removedelectrics[ids[i]] = struct{}{}
	}
}

// RemovedElectrics returns the removed IDs of the "electrics" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedElectricsIDs() (ids []int) {
	for id := range m.removedelectrics {
		ids = append(ids, id)
	}
	return
}

// ElectricsIDs returns the "electrics" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ElectricsIDs() (ids []int) {
	for id := range m.electrics {
		ids = append(ids, id)
	}
	return
}

// ResetElectrics resets all changes to the "electrics" edge.
func (m *CompanyEngineerMutation) ResetElectrics() {
	m.electrics = nil
	m.clearedelectrics = false
	m.removedelectrics = nil
}

// AddControllerIDs adds the "controllers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddControllerIDs(ids ...int) {
	if m.controllers == nil {
		m.controllers = make(map[int]struct{})
	}
	for i := range ids {
		m.controllers[ids[i]] = struct{}{}
	}
}

// ClearControllers clears the "controllers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearControllers() {
	m.clearedcontrollers = true
}

// ControllersCleared reports if the "controllers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ControllersCleared() bool {
	return m.clearedcontrollers
}

// RemoveControllerIDs removes the "controllers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveControllerIDs(ids ...int) {
	if m.removedcontrollers == nil {
		m.removedcontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.controllers, ids[i])
		m.removedcontrollers[ids[i]] = struct{}{}
	}
}

// RemovedControllers returns the removed IDs of the "controllers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedControllersIDs() (ids []int) {
	for id := range m.removedcontrollers {
		ids = append(ids, id)
	}
	return
}

// ControllersIDs returns the "controllers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ControllersIDs() (ids []int) {
	for id := range m.controllers {
		ids = append(ids, id)
	}
	return
}

// ResetControllers resets all changes to the "controllers" edge.
func (m *CompanyEngineerMutation) ResetControllers() {
	m.controllers = nil
	m.clearedcontrollers = false
	m.removedcontrollers = nil
}

// AddMechaniccontrollerIDs adds the "mechaniccontrollers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddMechaniccontrollerIDs(ids ...int) {
	if m.mechaniccontrollers == nil {
		m.mechaniccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		m.mechaniccontrollers[ids[i]] = struct{}{}
	}
}

// ClearMechaniccontrollers clears the "mechaniccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearMechaniccontrollers() {
	m.clearedmechaniccontrollers = true
}

// MechaniccontrollersCleared reports if the "mechaniccontrollers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) MechaniccontrollersCleared() bool {
	return m.clearedmechaniccontrollers
}

// RemoveMechaniccontrollerIDs removes the "mechaniccontrollers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveMechaniccontrollerIDs(ids ...int) {
	if m.removedmechaniccontrollers == nil {
		m.removedmechaniccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.mechaniccontrollers, ids[i])
		m.removedmechaniccontrollers[ids[i]] = struct{}{}
	}
}

// RemovedMechaniccontrollers returns the removed IDs of the "mechaniccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedMechaniccontrollersIDs() (ids []int) {
	for id := range m.removedmechaniccontrollers {
		ids = append(ids, id)
	}
	return
}

// MechaniccontrollersIDs returns the "mechaniccontrollers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) MechaniccontrollersIDs() (ids []int) {
	for id := range m.mechaniccontrollers {
		ids = append(ids, id)
	}
	return
}

// ResetMechaniccontrollers resets all changes to the "mechaniccontrollers" edge.
func (m *CompanyEngineerMutation) ResetMechaniccontrollers() {
	m.mechaniccontrollers = nil
	m.clearedmechaniccontrollers = false
	m.removedmechaniccontrollers = nil
}

// AddElectriccontrollerIDs adds the "electriccontrollers" edge to the JobDetail entity by ids.
func (m *CompanyEngineerMutation) AddElectriccontrollerIDs(ids ...int) {
	if m.electriccontrollers == nil {
		m.electriccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		m.electriccontrollers[ids[i]] = struct{}{}
	}
}

// ClearElectriccontrollers clears the "electriccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) ClearElectriccontrollers() {
	m.clearedelectriccontrollers = true
}

// ElectriccontrollersCleared reports if the "electriccontrollers" edge to the JobDetail entity was cleared.
func (m *CompanyEngineerMutation) ElectriccontrollersCleared() bool {
	return m.clearedelectriccontrollers
}

// RemoveElectriccontrollerIDs removes the "electriccontrollers" edge to the JobDetail entity by IDs.
func (m *CompanyEngineerMutation) RemoveElectriccontrollerIDs(ids ...int) {
	if m.removedelectriccontrollers == nil {
		m.removedelectriccontrollers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.electriccontrollers, ids[i])
		m.removedelectriccontrollers[ids[i]] = struct{}{}
	}
}

// RemovedElectriccontrollers returns the removed IDs of the "electriccontrollers" edge to the JobDetail entity.
func (m *CompanyEngineerMutation) RemovedElectriccontrollersIDs() (ids []int) {
	for id := range m.removedelectriccontrollers {
		ids = append(ids, id)
	}
	return
}

// ElectriccontrollersIDs returns the "electriccontrollers" edge IDs in the mutation.
func (m *CompanyEngineerMutation) ElectriccontrollersIDs() (ids []int) {
	for id := range m.electriccontrollers {
		ids = append(ids, id)
	}
	return
}

// ResetElectriccontrollers resets all changes to the "electriccontrollers" edge.
func (m *CompanyEngineerMutation) ResetElectriccontrollers() {
	m.electriccontrollers = nil
	m.clearedelectriccontrollers = false
	m.removedelectriccontrollers = nil
}

// Where appends a list predicates to the CompanyEngineerMutation builder.
func (m *CompanyEngineerMutation) Where(ps ...predicate.CompanyEngineer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyEngineerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyEngineerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyEngineer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyEngineerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyEngineerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyEngineer).
func (m *CompanyEngineerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyEngineerMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m._Name != nil {
		fields = append(fields, companyengineer.FieldName)
	}
	if m._Address != nil {
		fields = append(fields, companyengineer.FieldAddress)
	}
	if m._Email != nil {
		fields = append(fields, companyengineer.FieldEmail)
	}
	if m._TcNo != nil {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m._Phone != nil {
		fields = append(fields, companyengineer.FieldPhone)
	}
	if m._RegNo != nil {
		fields = append(fields, companyengineer.FieldRegNo)
	}
	if m._CertNo != nil {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m._Career != nil {
		fields = append(fields, companyengineer.FieldCareer)
	}
	if m._Position != nil {
		fields = append(fields, companyengineer.FieldPosition)
	}
	if m._Note != nil {
		fields = append(fields, companyengineer.FieldNote)
	}
	if m._Status != nil {
		fields = append(fields, companyengineer.FieldStatus)
	}
	if m._Deleted != nil {
		fields = append(fields, companyengineer.FieldDeleted)
	}
	if m._Employment != nil {
		fields = append(fields, companyengineer.FieldEmployment)
	}
	if m._Dismissal != nil {
		fields = append(fields, companyengineer.FieldDismissal)
	}
	if m._CreatedAt != nil {
		fields = append(fields, companyengineer.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, companyengineer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyEngineerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companyengineer.FieldName:
		return m.Name()
	case companyengineer.FieldAddress:
		return m.Address()
	case companyengineer.FieldEmail:
		return m.Email()
	case companyengineer.FieldTcNo:
		return m.TcNo()
	case companyengineer.FieldPhone:
		return m.Phone()
	case companyengineer.FieldRegNo:
		return m.RegNo()
	case companyengineer.FieldCertNo:
		return m.CertNo()
	case companyengineer.FieldCareer:
		return m.Career()
	case companyengineer.FieldPosition:
		return m.Position()
	case companyengineer.FieldNote:
		return m.Note()
	case companyengineer.FieldStatus:
		return m.Status()
	case companyengineer.FieldDeleted:
		return m.Deleted()
	case companyengineer.FieldEmployment:
		return m.Employment()
	case companyengineer.FieldDismissal:
		return m.Dismissal()
	case companyengineer.FieldCreatedAt:
		return m.CreatedAt()
	case companyengineer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyEngineerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companyengineer.FieldName:
		return m.OldName(ctx)
	case companyengineer.FieldAddress:
		return m.OldAddress(ctx)
	case companyengineer.FieldEmail:
		return m.OldEmail(ctx)
	case companyengineer.FieldTcNo:
		return m.OldTcNo(ctx)
	case companyengineer.FieldPhone:
		return m.OldPhone(ctx)
	case companyengineer.FieldRegNo:
		return m.OldRegNo(ctx)
	case companyengineer.FieldCertNo:
		return m.OldCertNo(ctx)
	case companyengineer.FieldCareer:
		return m.OldCareer(ctx)
	case companyengineer.FieldPosition:
		return m.OldPosition(ctx)
	case companyengineer.FieldNote:
		return m.OldNote(ctx)
	case companyengineer.FieldStatus:
		return m.OldStatus(ctx)
	case companyengineer.FieldDeleted:
		return m.OldDeleted(ctx)
	case companyengineer.FieldEmployment:
		return m.OldEmployment(ctx)
	case companyengineer.FieldDismissal:
		return m.OldDismissal(ctx)
	case companyengineer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case companyengineer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyEngineerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companyengineer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case companyengineer.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case companyengineer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case companyengineer.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case companyengineer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case companyengineer.FieldRegNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegNo(v)
		return nil
	case companyengineer.FieldCertNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertNo(v)
		return nil
	case companyengineer.FieldCareer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCareer(v)
		return nil
	case companyengineer.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case companyengineer.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case companyengineer.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case companyengineer.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case companyengineer.FieldEmployment:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployment(v)
		return nil
	case companyengineer.FieldDismissal:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDismissal(v)
		return nil
	case companyengineer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case companyengineer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyEngineerMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m.add_RegNo != nil {
		fields = append(fields, companyengineer.FieldRegNo)
	}
	if m.add_CertNo != nil {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m.add_Status != nil {
		fields = append(fields, companyengineer.FieldStatus)
	}
	if m.add_Deleted != nil {
		fields = append(fields, companyengineer.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyEngineerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companyengineer.FieldTcNo:
		return m.AddedTcNo()
	case companyengineer.FieldRegNo:
		return m.AddedRegNo()
	case companyengineer.FieldCertNo:
		return m.AddedCertNo()
	case companyengineer.FieldStatus:
		return m.AddedStatus()
	case companyengineer.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyEngineerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companyengineer.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case companyengineer.FieldRegNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegNo(v)
		return nil
	case companyengineer.FieldCertNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCertNo(v)
		return nil
	case companyengineer.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case companyengineer.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyEngineerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(companyengineer.FieldAddress) {
		fields = append(fields, companyengineer.FieldAddress)
	}
	if m.FieldCleared(companyengineer.FieldEmail) {
		fields = append(fields, companyengineer.FieldEmail)
	}
	if m.FieldCleared(companyengineer.FieldTcNo) {
		fields = append(fields, companyengineer.FieldTcNo)
	}
	if m.FieldCleared(companyengineer.FieldPhone) {
		fields = append(fields, companyengineer.FieldPhone)
	}
	if m.FieldCleared(companyengineer.FieldRegNo) {
		fields = append(fields, companyengineer.FieldRegNo)
	}
	if m.FieldCleared(companyengineer.FieldCertNo) {
		fields = append(fields, companyengineer.FieldCertNo)
	}
	if m.FieldCleared(companyengineer.FieldCareer) {
		fields = append(fields, companyengineer.FieldCareer)
	}
	if m.FieldCleared(companyengineer.FieldPosition) {
		fields = append(fields, companyengineer.FieldPosition)
	}
	if m.FieldCleared(companyengineer.FieldNote) {
		fields = append(fields, companyengineer.FieldNote)
	}
	if m.FieldCleared(companyengineer.FieldEmployment) {
		fields = append(fields, companyengineer.FieldEmployment)
	}
	if m.FieldCleared(companyengineer.FieldDismissal) {
		fields = append(fields, companyengineer.FieldDismissal)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyEngineerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyEngineerMutation) ClearField(name string) error {
	switch name {
	case companyengineer.FieldAddress:
		m.ClearAddress()
		return nil
	case companyengineer.FieldEmail:
		m.ClearEmail()
		return nil
	case companyengineer.FieldTcNo:
		m.ClearTcNo()
		return nil
	case companyengineer.FieldPhone:
		m.ClearPhone()
		return nil
	case companyengineer.FieldRegNo:
		m.ClearRegNo()
		return nil
	case companyengineer.FieldCertNo:
		m.ClearCertNo()
		return nil
	case companyengineer.FieldCareer:
		m.ClearCareer()
		return nil
	case companyengineer.FieldPosition:
		m.ClearPosition()
		return nil
	case companyengineer.FieldNote:
		m.ClearNote()
		return nil
	case companyengineer.FieldEmployment:
		m.ClearEmployment()
		return nil
	case companyengineer.FieldDismissal:
		m.ClearDismissal()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyEngineerMutation) ResetField(name string) error {
	switch name {
	case companyengineer.FieldName:
		m.ResetName()
		return nil
	case companyengineer.FieldAddress:
		m.ResetAddress()
		return nil
	case companyengineer.FieldEmail:
		m.ResetEmail()
		return nil
	case companyengineer.FieldTcNo:
		m.ResetTcNo()
		return nil
	case companyengineer.FieldPhone:
		m.ResetPhone()
		return nil
	case companyengineer.FieldRegNo:
		m.ResetRegNo()
		return nil
	case companyengineer.FieldCertNo:
		m.ResetCertNo()
		return nil
	case companyengineer.FieldCareer:
		m.ResetCareer()
		return nil
	case companyengineer.FieldPosition:
		m.ResetPosition()
		return nil
	case companyengineer.FieldNote:
		m.ResetNote()
		return nil
	case companyengineer.FieldStatus:
		m.ResetStatus()
		return nil
	case companyengineer.FieldDeleted:
		m.ResetDeleted()
		return nil
	case companyengineer.FieldEmployment:
		m.ResetEmployment()
		return nil
	case companyengineer.FieldDismissal:
		m.ResetDismissal()
		return nil
	case companyengineer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case companyengineer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyEngineerMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.companyOwners != nil {
		edges = append(edges, companyengineer.EdgeCompanyOwners)
	}
	if m.inspectors != nil {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.architects != nil {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.statics != nil {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.mechanics != nil {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.electrics != nil {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.controllers != nil {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.mechaniccontrollers != nil {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.electriccontrollers != nil {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyEngineerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companyengineer.EdgeCompanyOwners:
		ids := make([]ent.Value, 0, len(m.companyOwners))
		for id := range m.companyOwners {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeInspectors:
		ids := make([]ent.Value, 0, len(m.inspectors))
		for id := range m.inspectors {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeArchitects:
		ids := make([]ent.Value, 0, len(m.architects))
		for id := range m.architects {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeStatics:
		ids := make([]ent.Value, 0, len(m.statics))
		for id := range m.statics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechanics:
		ids := make([]ent.Value, 0, len(m.mechanics))
		for id := range m.mechanics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectrics:
		ids := make([]ent.Value, 0, len(m.electrics))
		for id := range m.electrics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeControllers:
		ids := make([]ent.Value, 0, len(m.controllers))
		for id := range m.controllers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechaniccontrollers:
		ids := make([]ent.Value, 0, len(m.mechaniccontrollers))
		for id := range m.mechaniccontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectriccontrollers:
		ids := make([]ent.Value, 0, len(m.electriccontrollers))
		for id := range m.electriccontrollers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyEngineerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedcompanyOwners != nil {
		edges = append(edges, companyengineer.EdgeCompanyOwners)
	}
	if m.removedinspectors != nil {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.removedarchitects != nil {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.removedstatics != nil {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.removedmechanics != nil {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.removedelectrics != nil {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.removedcontrollers != nil {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.removedmechaniccontrollers != nil {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.removedelectriccontrollers != nil {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyEngineerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case companyengineer.EdgeCompanyOwners:
		ids := make([]ent.Value, 0, len(m.removedcompanyOwners))
		for id := range m.removedcompanyOwners {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeInspectors:
		ids := make([]ent.Value, 0, len(m.removedinspectors))
		for id := range m.removedinspectors {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeArchitects:
		ids := make([]ent.Value, 0, len(m.removedarchitects))
		for id := range m.removedarchitects {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeStatics:
		ids := make([]ent.Value, 0, len(m.removedstatics))
		for id := range m.removedstatics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechanics:
		ids := make([]ent.Value, 0, len(m.removedmechanics))
		for id := range m.removedmechanics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectrics:
		ids := make([]ent.Value, 0, len(m.removedelectrics))
		for id := range m.removedelectrics {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeControllers:
		ids := make([]ent.Value, 0, len(m.removedcontrollers))
		for id := range m.removedcontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeMechaniccontrollers:
		ids := make([]ent.Value, 0, len(m.removedmechaniccontrollers))
		for id := range m.removedmechaniccontrollers {
			ids = append(ids, id)
		}
		return ids
	case companyengineer.EdgeElectriccontrollers:
		ids := make([]ent.Value, 0, len(m.removedelectriccontrollers))
		for id := range m.removedelectriccontrollers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyEngineerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedcompanyOwners {
		edges = append(edges, companyengineer.EdgeCompanyOwners)
	}
	if m.clearedinspectors {
		edges = append(edges, companyengineer.EdgeInspectors)
	}
	if m.clearedarchitects {
		edges = append(edges, companyengineer.EdgeArchitects)
	}
	if m.clearedstatics {
		edges = append(edges, companyengineer.EdgeStatics)
	}
	if m.clearedmechanics {
		edges = append(edges, companyengineer.EdgeMechanics)
	}
	if m.clearedelectrics {
		edges = append(edges, companyengineer.EdgeElectrics)
	}
	if m.clearedcontrollers {
		edges = append(edges, companyengineer.EdgeControllers)
	}
	if m.clearedmechaniccontrollers {
		edges = append(edges, companyengineer.EdgeMechaniccontrollers)
	}
	if m.clearedelectriccontrollers {
		edges = append(edges, companyengineer.EdgeElectriccontrollers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyEngineerMutation) EdgeCleared(name string) bool {
	switch name {
	case companyengineer.EdgeCompanyOwners:
		return m.clearedcompanyOwners
	case companyengineer.EdgeInspectors:
		return m.clearedinspectors
	case companyengineer.EdgeArchitects:
		return m.clearedarchitects
	case companyengineer.EdgeStatics:
		return m.clearedstatics
	case companyengineer.EdgeMechanics:
		return m.clearedmechanics
	case companyengineer.EdgeElectrics:
		return m.clearedelectrics
	case companyengineer.EdgeControllers:
		return m.clearedcontrollers
	case companyengineer.EdgeMechaniccontrollers:
		return m.clearedmechaniccontrollers
	case companyengineer.EdgeElectriccontrollers:
		return m.clearedelectriccontrollers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyEngineerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CompanyEngineer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyEngineerMutation) ResetEdge(name string) error {
	switch name {
	case companyengineer.EdgeCompanyOwners:
		m.ResetCompanyOwners()
		return nil
	case companyengineer.EdgeInspectors:
		m.ResetInspectors()
		return nil
	case companyengineer.EdgeArchitects:
		m.ResetArchitects()
		return nil
	case companyengineer.EdgeStatics:
		m.ResetStatics()
		return nil
	case companyengineer.EdgeMechanics:
		m.ResetMechanics()
		return nil
	case companyengineer.EdgeElectrics:
		m.ResetElectrics()
		return nil
	case companyengineer.EdgeControllers:
		m.ResetControllers()
		return nil
	case companyengineer.EdgeMechaniccontrollers:
		m.ResetMechaniccontrollers()
		return nil
	case companyengineer.EdgeElectriccontrollers:
		m.ResetElectriccontrollers()
		return nil
	}
	return fmt.Errorf("unknown CompanyEngineer edge %s", name)
}

// JobAuthorMutation represents an operation that mutates the JobAuthor nodes in the graph.
type JobAuthorMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Architect     *string
	_Static        *string
	_Mechanic      *string
	_Electric      *string
	_Floor         *string
	_CreatedAt     *time.Time
	_UpdatedAt     *time.Time
	clearedFields  map[string]struct{}
	authors        map[int]struct{}
	removedauthors map[int]struct{}
	clearedauthors bool
	done           bool
	oldValue       func(context.Context) (*JobAuthor, error)
	predicates     []predicate.JobAuthor
}

var _ ent.Mutation = (*JobAuthorMutation)(nil)

// jobauthorOption allows management of the mutation configuration using functional options.
type jobauthorOption func(*JobAuthorMutation)

// newJobAuthorMutation creates new mutation for the JobAuthor entity.
func newJobAuthorMutation(c config, op Op, opts ...jobauthorOption) *JobAuthorMutation {
	m := &JobAuthorMutation{
		config:        c,
		op:            op,
		typ:           TypeJobAuthor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobAuthorID sets the ID field of the mutation.
func withJobAuthorID(id int) jobauthorOption {
	return func(m *JobAuthorMutation) {
		var (
			err   error
			once  sync.Once
			value *JobAuthor
		)
		m.oldValue = func(ctx context.Context) (*JobAuthor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobAuthor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobAuthor sets the old JobAuthor of the mutation.
func withJobAuthor(node *JobAuthor) jobauthorOption {
	return func(m *JobAuthorMutation) {
		m.oldValue = func(context.Context) (*JobAuthor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobAuthorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobAuthorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobAuthorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobAuthorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobAuthor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetArchitect sets the "Architect" field.
func (m *JobAuthorMutation) SetArchitect(s string) {
	m._Architect = &s
}

// Architect returns the value of the "Architect" field in the mutation.
func (m *JobAuthorMutation) Architect() (r string, exists bool) {
	v := m._Architect
	if v == nil {
		return
	}
	return *v, true
}

// OldArchitect returns the old "Architect" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldArchitect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchitect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchitect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchitect: %w", err)
	}
	return oldValue.Architect, nil
}

// ClearArchitect clears the value of the "Architect" field.
func (m *JobAuthorMutation) ClearArchitect() {
	m._Architect = nil
	m.clearedFields[jobauthor.FieldArchitect] = struct{}{}
}

// ArchitectCleared returns if the "Architect" field was cleared in this mutation.
func (m *JobAuthorMutation) ArchitectCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldArchitect]
	return ok
}

// ResetArchitect resets all changes to the "Architect" field.
func (m *JobAuthorMutation) ResetArchitect() {
	m._Architect = nil
	delete(m.clearedFields, jobauthor.FieldArchitect)
}

// SetStatic sets the "Static" field.
func (m *JobAuthorMutation) SetStatic(s string) {
	m._Static = &s
}

// Static returns the value of the "Static" field in the mutation.
func (m *JobAuthorMutation) Static() (r string, exists bool) {
	v := m._Static
	if v == nil {
		return
	}
	return *v, true
}

// OldStatic returns the old "Static" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldStatic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatic: %w", err)
	}
	return oldValue.Static, nil
}

// ClearStatic clears the value of the "Static" field.
func (m *JobAuthorMutation) ClearStatic() {
	m._Static = nil
	m.clearedFields[jobauthor.FieldStatic] = struct{}{}
}

// StaticCleared returns if the "Static" field was cleared in this mutation.
func (m *JobAuthorMutation) StaticCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldStatic]
	return ok
}

// ResetStatic resets all changes to the "Static" field.
func (m *JobAuthorMutation) ResetStatic() {
	m._Static = nil
	delete(m.clearedFields, jobauthor.FieldStatic)
}

// SetMechanic sets the "Mechanic" field.
func (m *JobAuthorMutation) SetMechanic(s string) {
	m._Mechanic = &s
}

// Mechanic returns the value of the "Mechanic" field in the mutation.
func (m *JobAuthorMutation) Mechanic() (r string, exists bool) {
	v := m._Mechanic
	if v == nil {
		return
	}
	return *v, true
}

// OldMechanic returns the old "Mechanic" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldMechanic(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMechanic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMechanic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMechanic: %w", err)
	}
	return oldValue.Mechanic, nil
}

// ClearMechanic clears the value of the "Mechanic" field.
func (m *JobAuthorMutation) ClearMechanic() {
	m._Mechanic = nil
	m.clearedFields[jobauthor.FieldMechanic] = struct{}{}
}

// MechanicCleared returns if the "Mechanic" field was cleared in this mutation.
func (m *JobAuthorMutation) MechanicCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldMechanic]
	return ok
}

// ResetMechanic resets all changes to the "Mechanic" field.
func (m *JobAuthorMutation) ResetMechanic() {
	m._Mechanic = nil
	delete(m.clearedFields, jobauthor.FieldMechanic)
}

// SetElectric sets the "Electric" field.
func (m *JobAuthorMutation) SetElectric(s string) {
	m._Electric = &s
}

// Electric returns the value of the "Electric" field in the mutation.
func (m *JobAuthorMutation) Electric() (r string, exists bool) {
	v := m._Electric
	if v == nil {
		return
	}
	return *v, true
}

// OldElectric returns the old "Electric" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldElectric(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectric: %w", err)
	}
	return oldValue.Electric, nil
}

// ClearElectric clears the value of the "Electric" field.
func (m *JobAuthorMutation) ClearElectric() {
	m._Electric = nil
	m.clearedFields[jobauthor.FieldElectric] = struct{}{}
}

// ElectricCleared returns if the "Electric" field was cleared in this mutation.
func (m *JobAuthorMutation) ElectricCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldElectric]
	return ok
}

// ResetElectric resets all changes to the "Electric" field.
func (m *JobAuthorMutation) ResetElectric() {
	m._Electric = nil
	delete(m.clearedFields, jobauthor.FieldElectric)
}

// SetFloor sets the "Floor" field.
func (m *JobAuthorMutation) SetFloor(s string) {
	m._Floor = &s
}

// Floor returns the value of the "Floor" field in the mutation.
func (m *JobAuthorMutation) Floor() (r string, exists bool) {
	v := m._Floor
	if v == nil {
		return
	}
	return *v, true
}

// OldFloor returns the old "Floor" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldFloor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloor: %w", err)
	}
	return oldValue.Floor, nil
}

// ClearFloor clears the value of the "Floor" field.
func (m *JobAuthorMutation) ClearFloor() {
	m._Floor = nil
	m.clearedFields[jobauthor.FieldFloor] = struct{}{}
}

// FloorCleared returns if the "Floor" field was cleared in this mutation.
func (m *JobAuthorMutation) FloorCleared() bool {
	_, ok := m.clearedFields[jobauthor.FieldFloor]
	return ok
}

// ResetFloor resets all changes to the "Floor" field.
func (m *JobAuthorMutation) ResetFloor() {
	m._Floor = nil
	delete(m.clearedFields, jobauthor.FieldFloor)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobAuthorMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobAuthorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobAuthorMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobAuthorMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobAuthorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobAuthor entity.
// If the JobAuthor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAuthorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobAuthorMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddAuthorIDs adds the "authors" edge to the JobDetail entity by ids.
func (m *JobAuthorMutation) AddAuthorIDs(ids ...int) {
	if m.authors == nil {
		m.authors = make(map[int]struct{})
	}
	for i := range ids {
		m.authors[ids[i]] = struct{}{}
	}
}

// ClearAuthors clears the "authors" edge to the JobDetail entity.
func (m *JobAuthorMutation) ClearAuthors() {
	m.clearedauthors = true
}

// AuthorsCleared reports if the "authors" edge to the JobDetail entity was cleared.
func (m *JobAuthorMutation) AuthorsCleared() bool {
	return m.clearedauthors
}

// RemoveAuthorIDs removes the "authors" edge to the JobDetail entity by IDs.
func (m *JobAuthorMutation) RemoveAuthorIDs(ids ...int) {
	if m.removedauthors == nil {
		m.removedauthors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.authors, ids[i])
		m.removedauthors[ids[i]] = struct{}{}
	}
}

// RemovedAuthors returns the removed IDs of the "authors" edge to the JobDetail entity.
func (m *JobAuthorMutation) RemovedAuthorsIDs() (ids []int) {
	for id := range m.removedauthors {
		ids = append(ids, id)
	}
	return
}

// AuthorsIDs returns the "authors" edge IDs in the mutation.
func (m *JobAuthorMutation) AuthorsIDs() (ids []int) {
	for id := range m.authors {
		ids = append(ids, id)
	}
	return
}

// ResetAuthors resets all changes to the "authors" edge.
func (m *JobAuthorMutation) ResetAuthors() {
	m.authors = nil
	m.clearedauthors = false
	m.removedauthors = nil
}

// Where appends a list predicates to the JobAuthorMutation builder.
func (m *JobAuthorMutation) Where(ps ...predicate.JobAuthor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobAuthorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobAuthorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobAuthor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobAuthorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobAuthorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobAuthor).
func (m *JobAuthorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobAuthorMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Architect != nil {
		fields = append(fields, jobauthor.FieldArchitect)
	}
	if m._Static != nil {
		fields = append(fields, jobauthor.FieldStatic)
	}
	if m._Mechanic != nil {
		fields = append(fields, jobauthor.FieldMechanic)
	}
	if m._Electric != nil {
		fields = append(fields, jobauthor.FieldElectric)
	}
	if m._Floor != nil {
		fields = append(fields, jobauthor.FieldFloor)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobauthor.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobauthor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobAuthorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobauthor.FieldArchitect:
		return m.Architect()
	case jobauthor.FieldStatic:
		return m.Static()
	case jobauthor.FieldMechanic:
		return m.Mechanic()
	case jobauthor.FieldElectric:
		return m.Electric()
	case jobauthor.FieldFloor:
		return m.Floor()
	case jobauthor.FieldCreatedAt:
		return m.CreatedAt()
	case jobauthor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobAuthorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobauthor.FieldArchitect:
		return m.OldArchitect(ctx)
	case jobauthor.FieldStatic:
		return m.OldStatic(ctx)
	case jobauthor.FieldMechanic:
		return m.OldMechanic(ctx)
	case jobauthor.FieldElectric:
		return m.OldElectric(ctx)
	case jobauthor.FieldFloor:
		return m.OldFloor(ctx)
	case jobauthor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobauthor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobAuthor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAuthorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobauthor.FieldArchitect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchitect(v)
		return nil
	case jobauthor.FieldStatic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatic(v)
		return nil
	case jobauthor.FieldMechanic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMechanic(v)
		return nil
	case jobauthor.FieldElectric:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectric(v)
		return nil
	case jobauthor.FieldFloor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloor(v)
		return nil
	case jobauthor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobauthor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobAuthor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobAuthorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobAuthorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAuthorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobAuthor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobAuthorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobauthor.FieldArchitect) {
		fields = append(fields, jobauthor.FieldArchitect)
	}
	if m.FieldCleared(jobauthor.FieldStatic) {
		fields = append(fields, jobauthor.FieldStatic)
	}
	if m.FieldCleared(jobauthor.FieldMechanic) {
		fields = append(fields, jobauthor.FieldMechanic)
	}
	if m.FieldCleared(jobauthor.FieldElectric) {
		fields = append(fields, jobauthor.FieldElectric)
	}
	if m.FieldCleared(jobauthor.FieldFloor) {
		fields = append(fields, jobauthor.FieldFloor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobAuthorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobAuthorMutation) ClearField(name string) error {
	switch name {
	case jobauthor.FieldArchitect:
		m.ClearArchitect()
		return nil
	case jobauthor.FieldStatic:
		m.ClearStatic()
		return nil
	case jobauthor.FieldMechanic:
		m.ClearMechanic()
		return nil
	case jobauthor.FieldElectric:
		m.ClearElectric()
		return nil
	case jobauthor.FieldFloor:
		m.ClearFloor()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobAuthorMutation) ResetField(name string) error {
	switch name {
	case jobauthor.FieldArchitect:
		m.ResetArchitect()
		return nil
	case jobauthor.FieldStatic:
		m.ResetStatic()
		return nil
	case jobauthor.FieldMechanic:
		m.ResetMechanic()
		return nil
	case jobauthor.FieldElectric:
		m.ResetElectric()
		return nil
	case jobauthor.FieldFloor:
		m.ResetFloor()
		return nil
	case jobauthor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobauthor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobAuthorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.authors != nil {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobAuthorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobauthor.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.authors))
		for id := range m.authors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobAuthorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedauthors != nil {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobAuthorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobauthor.EdgeAuthors:
		ids := make([]ent.Value, 0, len(m.removedauthors))
		for id := range m.removedauthors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobAuthorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedauthors {
		edges = append(edges, jobauthor.EdgeAuthors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobAuthorMutation) EdgeCleared(name string) bool {
	switch name {
	case jobauthor.EdgeAuthors:
		return m.clearedauthors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobAuthorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobAuthor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobAuthorMutation) ResetEdge(name string) error {
	switch name {
	case jobauthor.EdgeAuthors:
		m.ResetAuthors()
		return nil
	}
	return fmt.Errorf("unknown JobAuthor edge %s", name)
}

// JobContractorMutation represents an operation that mutates the JobContractor nodes in the graph.
type JobContractorMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Name              *string
	_TcNo              *int
	add_TcNo           *int
	_Address           *string
	_RegisterNo        *int
	add_RegisterNo     *int
	_TaxAdmin          *string
	_TaxNo             *int
	add_TaxNo          *int
	_Phone             *string
	_Email             *string
	_Note              *string
	_CreatedAt         *time.Time
	_UpdatedAt         *time.Time
	clearedFields      map[string]struct{}
	contractors        map[int]struct{}
	removedcontractors map[int]struct{}
	clearedcontractors bool
	done               bool
	oldValue           func(context.Context) (*JobContractor, error)
	predicates         []predicate.JobContractor
}

var _ ent.Mutation = (*JobContractorMutation)(nil)

// jobcontractorOption allows management of the mutation configuration using functional options.
type jobcontractorOption func(*JobContractorMutation)

// newJobContractorMutation creates new mutation for the JobContractor entity.
func newJobContractorMutation(c config, op Op, opts ...jobcontractorOption) *JobContractorMutation {
	m := &JobContractorMutation{
		config:        c,
		op:            op,
		typ:           TypeJobContractor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobContractorID sets the ID field of the mutation.
func withJobContractorID(id int) jobcontractorOption {
	return func(m *JobContractorMutation) {
		var (
			err   error
			once  sync.Once
			value *JobContractor
		)
		m.oldValue = func(ctx context.Context) (*JobContractor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobContractor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobContractor sets the old JobContractor of the mutation.
func withJobContractor(node *JobContractor) jobcontractorOption {
	return func(m *JobContractorMutation) {
		m.oldValue = func(context.Context) (*JobContractor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobContractorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobContractorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobContractorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobContractorMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobContractor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobContractorMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobContractorMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobContractorMutation) ResetName() {
	m._Name = nil
}

// SetTcNo sets the "TcNo" field.
func (m *JobContractorMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *JobContractorMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *JobContractorMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *JobContractorMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *JobContractorMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[jobcontractor.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *JobContractorMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *JobContractorMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, jobcontractor.FieldTcNo)
}

// SetAddress sets the "Address" field.
func (m *JobContractorMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobContractorMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobContractorMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobcontractor.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobContractorMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobContractorMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobcontractor.FieldAddress)
}

// SetRegisterNo sets the "RegisterNo" field.
func (m *JobContractorMutation) SetRegisterNo(i int) {
	m._RegisterNo = &i
	m.add_RegisterNo = nil
}

// RegisterNo returns the value of the "RegisterNo" field in the mutation.
func (m *JobContractorMutation) RegisterNo() (r int, exists bool) {
	v := m._RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterNo returns the old "RegisterNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldRegisterNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterNo: %w", err)
	}
	return oldValue.RegisterNo, nil
}

// AddRegisterNo adds i to the "RegisterNo" field.
func (m *JobContractorMutation) AddRegisterNo(i int) {
	if m.add_RegisterNo != nil {
		*m.add_RegisterNo += i
	} else {
		m.add_RegisterNo = &i
	}
}

// AddedRegisterNo returns the value that was added to the "RegisterNo" field in this mutation.
func (m *JobContractorMutation) AddedRegisterNo() (r int, exists bool) {
	v := m.add_RegisterNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegisterNo clears the value of the "RegisterNo" field.
func (m *JobContractorMutation) ClearRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	m.clearedFields[jobcontractor.FieldRegisterNo] = struct{}{}
}

// RegisterNoCleared returns if the "RegisterNo" field was cleared in this mutation.
func (m *JobContractorMutation) RegisterNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldRegisterNo]
	return ok
}

// ResetRegisterNo resets all changes to the "RegisterNo" field.
func (m *JobContractorMutation) ResetRegisterNo() {
	m._RegisterNo = nil
	m.add_RegisterNo = nil
	delete(m.clearedFields, jobcontractor.FieldRegisterNo)
}

// SetTaxAdmin sets the "TaxAdmin" field.
func (m *JobContractorMutation) SetTaxAdmin(s string) {
	m._TaxAdmin = &s
}

// TaxAdmin returns the value of the "TaxAdmin" field in the mutation.
func (m *JobContractorMutation) TaxAdmin() (r string, exists bool) {
	v := m._TaxAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAdmin returns the old "TaxAdmin" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldTaxAdmin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAdmin: %w", err)
	}
	return oldValue.TaxAdmin, nil
}

// ClearTaxAdmin clears the value of the "TaxAdmin" field.
func (m *JobContractorMutation) ClearTaxAdmin() {
	m._TaxAdmin = nil
	m.clearedFields[jobcontractor.FieldTaxAdmin] = struct{}{}
}

// TaxAdminCleared returns if the "TaxAdmin" field was cleared in this mutation.
func (m *JobContractorMutation) TaxAdminCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldTaxAdmin]
	return ok
}

// ResetTaxAdmin resets all changes to the "TaxAdmin" field.
func (m *JobContractorMutation) ResetTaxAdmin() {
	m._TaxAdmin = nil
	delete(m.clearedFields, jobcontractor.FieldTaxAdmin)
}

// SetTaxNo sets the "TaxNo" field.
func (m *JobContractorMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *JobContractorMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *JobContractorMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *JobContractorMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *JobContractorMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[jobcontractor.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *JobContractorMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *JobContractorMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, jobcontractor.FieldTaxNo)
}

// SetPhone sets the "Phone" field.
func (m *JobContractorMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *JobContractorMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *JobContractorMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[jobcontractor.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *JobContractorMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *JobContractorMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, jobcontractor.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *JobContractorMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *JobContractorMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *JobContractorMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[jobcontractor.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *JobContractorMutation) EmailCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *JobContractorMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, jobcontractor.FieldEmail)
}

// SetNote sets the "Note" field.
func (m *JobContractorMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobContractorMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobContractorMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobcontractor.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobContractorMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobcontractor.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobContractorMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobcontractor.FieldNote)
}

// SetCreatedAt sets the "CreatedAt" field.
func (m *JobContractorMutation) SetCreatedAt(t time.Time) {
	m._CreatedAt = &t
}

// CreatedAt returns the value of the "CreatedAt" field in the mutation.
func (m *JobContractorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m._CreatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "CreatedAt" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "CreatedAt" field.
func (m *JobContractorMutation) ResetCreatedAt() {
	m._CreatedAt = nil
}

// SetUpdatedAt sets the "UpdatedAt" field.
func (m *JobContractorMutation) SetUpdatedAt(t time.Time) {
	m._UpdatedAt = &t
}

// UpdatedAt returns the value of the "UpdatedAt" field in the mutation.
func (m *JobContractorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m._UpdatedAt
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "UpdatedAt" field's value of the JobContractor entity.
// If the JobContractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobContractorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "UpdatedAt" field.
func (m *JobContractorMutation) ResetUpdatedAt() {
	m._UpdatedAt = nil
}

// AddContractorIDs adds the "contractors" edge to the JobDetail entity by ids.
func (m *JobContractorMutation) AddContractorIDs(ids ...int) {
	if m.contractors == nil {
		m.contractors = make(map[int]struct{})
	}
	for i := range ids {
		m.contractors[ids[i]] = struct{}{}
	}
}

// ClearContractors clears the "contractors" edge to the JobDetail entity.
func (m *JobContractorMutation) ClearContractors() {
	m.clearedcontractors = true
}

// ContractorsCleared reports if the "contractors" edge to the JobDetail entity was cleared.
func (m *JobContractorMutation) ContractorsCleared() bool {
	return m.clearedcontractors
}

// RemoveContractorIDs removes the "contractors" edge to the JobDetail entity by IDs.
func (m *JobContractorMutation) RemoveContractorIDs(ids ...int) {
	if m.removedcontractors == nil {
		m.removedcontractors = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.contractors, ids[i])
		m.removedcontractors[ids[i]] = struct{}{}
	}
}

// RemovedContractors returns the removed IDs of the "contractors" edge to the JobDetail entity.
func (m *JobContractorMutation) RemovedContractorsIDs() (ids []int) {
	for id := range m.removedcontractors {
		ids = append(ids, id)
	}
	return
}

// ContractorsIDs returns the "contractors" edge IDs in the mutation.
func (m *JobContractorMutation) ContractorsIDs() (ids []int) {
	for id := range m.contractors {
		ids = append(ids, id)
	}
	return
}

// ResetContractors resets all changes to the "contractors" edge.
func (m *JobContractorMutation) ResetContractors() {
	m.contractors = nil
	m.clearedcontractors = false
	m.removedcontractors = nil
}

// Where appends a list predicates to the JobContractorMutation builder.
func (m *JobContractorMutation) Where(ps ...predicate.JobContractor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobContractorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobContractorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobContractor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobContractorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobContractorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobContractor).
func (m *JobContractorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobContractorMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._Name != nil {
		fields = append(fields, jobcontractor.FieldName)
	}
	if m._TcNo != nil {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m._Address != nil {
		fields = append(fields, jobcontractor.FieldAddress)
	}
	if m._RegisterNo != nil {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m._TaxAdmin != nil {
		fields = append(fields, jobcontractor.FieldTaxAdmin)
	}
	if m._TaxNo != nil {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	if m._Phone != nil {
		fields = append(fields, jobcontractor.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, jobcontractor.FieldEmail)
	}
	if m._Note != nil {
		fields = append(fields, jobcontractor.FieldNote)
	}
	if m._CreatedAt != nil {
		fields = append(fields, jobcontractor.FieldCreatedAt)
	}
	if m._UpdatedAt != nil {
		fields = append(fields, jobcontractor.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobContractorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobcontractor.FieldName:
		return m.Name()
	case jobcontractor.FieldTcNo:
		return m.TcNo()
	case jobcontractor.FieldAddress:
		return m.Address()
	case jobcontractor.FieldRegisterNo:
		return m.RegisterNo()
	case jobcontractor.FieldTaxAdmin:
		return m.TaxAdmin()
	case jobcontractor.FieldTaxNo:
		return m.TaxNo()
	case jobcontractor.FieldPhone:
		return m.Phone()
	case jobcontractor.FieldEmail:
		return m.Email()
	case jobcontractor.FieldNote:
		return m.Note()
	case jobcontractor.FieldCreatedAt:
		return m.CreatedAt()
	case jobcontractor.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobContractorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobcontractor.FieldName:
		return m.OldName(ctx)
	case jobcontractor.FieldTcNo:
		return m.OldTcNo(ctx)
	case jobcontractor.FieldAddress:
		return m.OldAddress(ctx)
	case jobcontractor.FieldRegisterNo:
		return m.OldRegisterNo(ctx)
	case jobcontractor.FieldTaxAdmin:
		return m.OldTaxAdmin(ctx)
	case jobcontractor.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case jobcontractor.FieldPhone:
		return m.OldPhone(ctx)
	case jobcontractor.FieldEmail:
		return m.OldEmail(ctx)
	case jobcontractor.FieldNote:
		return m.OldNote(ctx)
	case jobcontractor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobcontractor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobContractor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobContractorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobcontractor.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobcontractor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case jobcontractor.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobcontractor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterNo(v)
		return nil
	case jobcontractor.FieldTaxAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAdmin(v)
		return nil
	case jobcontractor.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case jobcontractor.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case jobcontractor.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case jobcontractor.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobcontractor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobcontractor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobContractor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobContractorMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m.add_RegisterNo != nil {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobContractorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobcontractor.FieldTcNo:
		return m.AddedTcNo()
	case jobcontractor.FieldRegisterNo:
		return m.AddedRegisterNo()
	case jobcontractor.FieldTaxNo:
		return m.AddedTaxNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobContractorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobcontractor.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case jobcontractor.FieldRegisterNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegisterNo(v)
		return nil
	case jobcontractor.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	}
	return fmt.Errorf("unknown JobContractor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobContractorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobcontractor.FieldTcNo) {
		fields = append(fields, jobcontractor.FieldTcNo)
	}
	if m.FieldCleared(jobcontractor.FieldAddress) {
		fields = append(fields, jobcontractor.FieldAddress)
	}
	if m.FieldCleared(jobcontractor.FieldRegisterNo) {
		fields = append(fields, jobcontractor.FieldRegisterNo)
	}
	if m.FieldCleared(jobcontractor.FieldTaxAdmin) {
		fields = append(fields, jobcontractor.FieldTaxAdmin)
	}
	if m.FieldCleared(jobcontractor.FieldTaxNo) {
		fields = append(fields, jobcontractor.FieldTaxNo)
	}
	if m.FieldCleared(jobcontractor.FieldPhone) {
		fields = append(fields, jobcontractor.FieldPhone)
	}
	if m.FieldCleared(jobcontractor.FieldEmail) {
		fields = append(fields, jobcontractor.FieldEmail)
	}
	if m.FieldCleared(jobcontractor.FieldNote) {
		fields = append(fields, jobcontractor.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobContractorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobContractorMutation) ClearField(name string) error {
	switch name {
	case jobcontractor.FieldTcNo:
		m.ClearTcNo()
		return nil
	case jobcontractor.FieldAddress:
		m.ClearAddress()
		return nil
	case jobcontractor.FieldRegisterNo:
		m.ClearRegisterNo()
		return nil
	case jobcontractor.FieldTaxAdmin:
		m.ClearTaxAdmin()
		return nil
	case jobcontractor.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case jobcontractor.FieldPhone:
		m.ClearPhone()
		return nil
	case jobcontractor.FieldEmail:
		m.ClearEmail()
		return nil
	case jobcontractor.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobContractor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobContractorMutation) ResetField(name string) error {
	switch name {
	case jobcontractor.FieldName:
		m.ResetName()
		return nil
	case jobcontractor.FieldTcNo:
		m.ResetTcNo()
		return nil
	case jobcontractor.FieldAddress:
		m.ResetAddress()
		return nil
	case jobcontractor.FieldRegisterNo:
		m.ResetRegisterNo()
		return nil
	case jobcontractor.FieldTaxAdmin:
		m.ResetTaxAdmin()
		return nil
	case jobcontractor.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case jobcontractor.FieldPhone:
		m.ResetPhone()
		return nil
	case jobcontractor.FieldEmail:
		m.ResetEmail()
		return nil
	case jobcontractor.FieldNote:
		m.ResetNote()
		return nil
	case jobcontractor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobcontractor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobContractor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobContractorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.contractors != nil {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobContractorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobcontractor.EdgeContractors:
		ids := make([]ent.Value, 0, len(m.contractors))
		for id := range m.contractors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobContractorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcontractors != nil {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobContractorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobcontractor.EdgeContractors:
		ids := make([]ent.Value, 0, len(m.removedcontractors))
		for id := range m.removedcontractors {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobContractorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcontractors {
		edges = append(edges, jobcontractor.EdgeContractors)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobContractorMutation) EdgeCleared(name string) bool {
	switch name {
	case jobcontractor.EdgeContractors:
		return m.clearedcontractors
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobContractorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobContractor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobContractorMutation) ResetEdge(name string) error {
	switch name {
	case jobcontractor.EdgeContractors:
		m.ResetContractors()
		return nil
	}
	return fmt.Errorf("unknown JobContractor edge %s", name)
}

// JobDetailMutation represents an operation that mutates the JobDetail nodes in the graph.
type JobDetailMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_YibfNo                   *int
	add_YibfNo                *int
	_Province                 *string
	_Idare                    *string
	_Pafta                    *string
	_Ada                      *string
	_Parsel                   *string
	_FolderNo                 *string
	_Status                   *int
	add_Status                *int
	_ContractDate             *time.Time
	_StartDate                *time.Time
	_LicenseDate              *time.Time
	_LicenseNo                *string
	_ConstructionArea         *string
	_District                 *string
	_Village                  *string
	_Street                   *string
	_BuildingClass            *string
	_BuildingType             *string
	_BuildingBlock            *string
	_LandArea                 *string
	_Floors                   *int
	add_Floors                *int
	_UsagePurpose             *string
	_Note                     *string
	_Started                  *int
	add_Started               *int
	_Deleted                  *int
	add_Deleted               *int
	created_at                *time.Time
	updated_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *int
	clearedowner              bool
	contractor                *int
	clearedcontractor         bool
	author                    *int
	clearedauthor             bool
	progress                  *int
	clearedprogress           bool
	inspector                 *int
	clearedinspector          bool
	architect                 *int
	clearedarchitect          bool
	static                    *int
	clearedstatic             bool
	mechanic                  *int
	clearedmechanic           bool
	electric                  *int
	clearedelectric           bool
	controller                *int
	clearedcontroller         bool
	mechaniccontroller        *int
	clearedmechaniccontroller bool
	electriccontroller        *int
	clearedelectriccontroller bool
	layers                    map[int]struct{}
	removedlayers             map[int]struct{}
	clearedlayers             bool
	done                      bool
	oldValue                  func(context.Context) (*JobDetail, error)
	predicates                []predicate.JobDetail
}

var _ ent.Mutation = (*JobDetailMutation)(nil)

// jobdetailOption allows management of the mutation configuration using functional options.
type jobdetailOption func(*JobDetailMutation)

// newJobDetailMutation creates new mutation for the JobDetail entity.
func newJobDetailMutation(c config, op Op, opts ...jobdetailOption) *JobDetailMutation {
	m := &JobDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeJobDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobDetailID sets the ID field of the mutation.
func withJobDetailID(id int) jobdetailOption {
	return func(m *JobDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *JobDetail
		)
		m.oldValue = func(ctx context.Context) (*JobDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobDetail sets the old JobDetail of the mutation.
func withJobDetail(node *JobDetail) jobdetailOption {
	return func(m *JobDetailMutation) {
		m.oldValue = func(context.Context) (*JobDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetYibfNo sets the "YibfNo" field.
func (m *JobDetailMutation) SetYibfNo(i int) {
	m._YibfNo = &i
	m.add_YibfNo = nil
}

// YibfNo returns the value of the "YibfNo" field in the mutation.
func (m *JobDetailMutation) YibfNo() (r int, exists bool) {
	v := m._YibfNo
	if v == nil {
		return
	}
	return *v, true
}

// OldYibfNo returns the old "YibfNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldYibfNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYibfNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYibfNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYibfNo: %w", err)
	}
	return oldValue.YibfNo, nil
}

// AddYibfNo adds i to the "YibfNo" field.
func (m *JobDetailMutation) AddYibfNo(i int) {
	if m.add_YibfNo != nil {
		*m.add_YibfNo += i
	} else {
		m.add_YibfNo = &i
	}
}

// AddedYibfNo returns the value that was added to the "YibfNo" field in this mutation.
func (m *JobDetailMutation) AddedYibfNo() (r int, exists bool) {
	v := m.add_YibfNo
	if v == nil {
		return
	}
	return *v, true
}

// ResetYibfNo resets all changes to the "YibfNo" field.
func (m *JobDetailMutation) ResetYibfNo() {
	m._YibfNo = nil
	m.add_YibfNo = nil
}

// SetProvince sets the "Province" field.
func (m *JobDetailMutation) SetProvince(s string) {
	m._Province = &s
}

// Province returns the value of the "Province" field in the mutation.
func (m *JobDetailMutation) Province() (r string, exists bool) {
	v := m._Province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "Province" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "Province" field.
func (m *JobDetailMutation) ClearProvince() {
	m._Province = nil
	m.clearedFields[jobdetail.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "Province" field was cleared in this mutation.
func (m *JobDetailMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "Province" field.
func (m *JobDetailMutation) ResetProvince() {
	m._Province = nil
	delete(m.clearedFields, jobdetail.FieldProvince)
}

// SetIdare sets the "Idare" field.
func (m *JobDetailMutation) SetIdare(s string) {
	m._Idare = &s
}

// Idare returns the value of the "Idare" field in the mutation.
func (m *JobDetailMutation) Idare() (r string, exists bool) {
	v := m._Idare
	if v == nil {
		return
	}
	return *v, true
}

// OldIdare returns the old "Idare" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldIdare(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdare: %w", err)
	}
	return oldValue.Idare, nil
}

// ClearIdare clears the value of the "Idare" field.
func (m *JobDetailMutation) ClearIdare() {
	m._Idare = nil
	m.clearedFields[jobdetail.FieldIdare] = struct{}{}
}

// IdareCleared returns if the "Idare" field was cleared in this mutation.
func (m *JobDetailMutation) IdareCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldIdare]
	return ok
}

// ResetIdare resets all changes to the "Idare" field.
func (m *JobDetailMutation) ResetIdare() {
	m._Idare = nil
	delete(m.clearedFields, jobdetail.FieldIdare)
}

// SetPafta sets the "Pafta" field.
func (m *JobDetailMutation) SetPafta(s string) {
	m._Pafta = &s
}

// Pafta returns the value of the "Pafta" field in the mutation.
func (m *JobDetailMutation) Pafta() (r string, exists bool) {
	v := m._Pafta
	if v == nil {
		return
	}
	return *v, true
}

// OldPafta returns the old "Pafta" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldPafta(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPafta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPafta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPafta: %w", err)
	}
	return oldValue.Pafta, nil
}

// ClearPafta clears the value of the "Pafta" field.
func (m *JobDetailMutation) ClearPafta() {
	m._Pafta = nil
	m.clearedFields[jobdetail.FieldPafta] = struct{}{}
}

// PaftaCleared returns if the "Pafta" field was cleared in this mutation.
func (m *JobDetailMutation) PaftaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldPafta]
	return ok
}

// ResetPafta resets all changes to the "Pafta" field.
func (m *JobDetailMutation) ResetPafta() {
	m._Pafta = nil
	delete(m.clearedFields, jobdetail.FieldPafta)
}

// SetAda sets the "Ada" field.
func (m *JobDetailMutation) SetAda(s string) {
	m._Ada = &s
}

// Ada returns the value of the "Ada" field in the mutation.
func (m *JobDetailMutation) Ada() (r string, exists bool) {
	v := m._Ada
	if v == nil {
		return
	}
	return *v, true
}

// OldAda returns the old "Ada" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldAda(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAda is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAda requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAda: %w", err)
	}
	return oldValue.Ada, nil
}

// ClearAda clears the value of the "Ada" field.
func (m *JobDetailMutation) ClearAda() {
	m._Ada = nil
	m.clearedFields[jobdetail.FieldAda] = struct{}{}
}

// AdaCleared returns if the "Ada" field was cleared in this mutation.
func (m *JobDetailMutation) AdaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldAda]
	return ok
}

// ResetAda resets all changes to the "Ada" field.
func (m *JobDetailMutation) ResetAda() {
	m._Ada = nil
	delete(m.clearedFields, jobdetail.FieldAda)
}

// SetParsel sets the "Parsel" field.
func (m *JobDetailMutation) SetParsel(s string) {
	m._Parsel = &s
}

// Parsel returns the value of the "Parsel" field in the mutation.
func (m *JobDetailMutation) Parsel() (r string, exists bool) {
	v := m._Parsel
	if v == nil {
		return
	}
	return *v, true
}

// OldParsel returns the old "Parsel" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldParsel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParsel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParsel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParsel: %w", err)
	}
	return oldValue.Parsel, nil
}

// ClearParsel clears the value of the "Parsel" field.
func (m *JobDetailMutation) ClearParsel() {
	m._Parsel = nil
	m.clearedFields[jobdetail.FieldParsel] = struct{}{}
}

// ParselCleared returns if the "Parsel" field was cleared in this mutation.
func (m *JobDetailMutation) ParselCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldParsel]
	return ok
}

// ResetParsel resets all changes to the "Parsel" field.
func (m *JobDetailMutation) ResetParsel() {
	m._Parsel = nil
	delete(m.clearedFields, jobdetail.FieldParsel)
}

// SetFolderNo sets the "FolderNo" field.
func (m *JobDetailMutation) SetFolderNo(s string) {
	m._FolderNo = &s
}

// FolderNo returns the value of the "FolderNo" field in the mutation.
func (m *JobDetailMutation) FolderNo() (r string, exists bool) {
	v := m._FolderNo
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderNo returns the old "FolderNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldFolderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderNo: %w", err)
	}
	return oldValue.FolderNo, nil
}

// ClearFolderNo clears the value of the "FolderNo" field.
func (m *JobDetailMutation) ClearFolderNo() {
	m._FolderNo = nil
	m.clearedFields[jobdetail.FieldFolderNo] = struct{}{}
}

// FolderNoCleared returns if the "FolderNo" field was cleared in this mutation.
func (m *JobDetailMutation) FolderNoCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldFolderNo]
	return ok
}

// ResetFolderNo resets all changes to the "FolderNo" field.
func (m *JobDetailMutation) ResetFolderNo() {
	m._FolderNo = nil
	delete(m.clearedFields, jobdetail.FieldFolderNo)
}

// SetStatus sets the "Status" field.
func (m *JobDetailMutation) SetStatus(i int) {
	m._Status = &i
	m.add_Status = nil
}

// Status returns the value of the "Status" field in the mutation.
func (m *JobDetailMutation) Status() (r int, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "Status" field.
func (m *JobDetailMutation) AddStatus(i int) {
	if m.add_Status != nil {
		*m.add_Status += i
	} else {
		m.add_Status = &i
	}
}

// AddedStatus returns the value that was added to the "Status" field in this mutation.
func (m *JobDetailMutation) AddedStatus() (r int, exists bool) {
	v := m.add_Status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "Status" field.
func (m *JobDetailMutation) ResetStatus() {
	m._Status = nil
	m.add_Status = nil
}

// SetContractDate sets the "ContractDate" field.
func (m *JobDetailMutation) SetContractDate(t time.Time) {
	m._ContractDate = &t
}

// ContractDate returns the value of the "ContractDate" field in the mutation.
func (m *JobDetailMutation) ContractDate() (r time.Time, exists bool) {
	v := m._ContractDate
	if v == nil {
		return
	}
	return *v, true
}

// OldContractDate returns the old "ContractDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldContractDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractDate: %w", err)
	}
	return oldValue.ContractDate, nil
}

// ClearContractDate clears the value of the "ContractDate" field.
func (m *JobDetailMutation) ClearContractDate() {
	m._ContractDate = nil
	m.clearedFields[jobdetail.FieldContractDate] = struct{}{}
}

// ContractDateCleared returns if the "ContractDate" field was cleared in this mutation.
func (m *JobDetailMutation) ContractDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldContractDate]
	return ok
}

// ResetContractDate resets all changes to the "ContractDate" field.
func (m *JobDetailMutation) ResetContractDate() {
	m._ContractDate = nil
	delete(m.clearedFields, jobdetail.FieldContractDate)
}

// SetStartDate sets the "StartDate" field.
func (m *JobDetailMutation) SetStartDate(t time.Time) {
	m._StartDate = &t
}

// StartDate returns the value of the "StartDate" field in the mutation.
func (m *JobDetailMutation) StartDate() (r time.Time, exists bool) {
	v := m._StartDate
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "StartDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "StartDate" field.
func (m *JobDetailMutation) ClearStartDate() {
	m._StartDate = nil
	m.clearedFields[jobdetail.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "StartDate" field was cleared in this mutation.
func (m *JobDetailMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "StartDate" field.
func (m *JobDetailMutation) ResetStartDate() {
	m._StartDate = nil
	delete(m.clearedFields, jobdetail.FieldStartDate)
}

// SetLicenseDate sets the "LicenseDate" field.
func (m *JobDetailMutation) SetLicenseDate(t time.Time) {
	m._LicenseDate = &t
}

// LicenseDate returns the value of the "LicenseDate" field in the mutation.
func (m *JobDetailMutation) LicenseDate() (r time.Time, exists bool) {
	v := m._LicenseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseDate returns the old "LicenseDate" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLicenseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseDate: %w", err)
	}
	return oldValue.LicenseDate, nil
}

// ClearLicenseDate clears the value of the "LicenseDate" field.
func (m *JobDetailMutation) ClearLicenseDate() {
	m._LicenseDate = nil
	m.clearedFields[jobdetail.FieldLicenseDate] = struct{}{}
}

// LicenseDateCleared returns if the "LicenseDate" field was cleared in this mutation.
func (m *JobDetailMutation) LicenseDateCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLicenseDate]
	return ok
}

// ResetLicenseDate resets all changes to the "LicenseDate" field.
func (m *JobDetailMutation) ResetLicenseDate() {
	m._LicenseDate = nil
	delete(m.clearedFields, jobdetail.FieldLicenseDate)
}

// SetLicenseNo sets the "LicenseNo" field.
func (m *JobDetailMutation) SetLicenseNo(s string) {
	m._LicenseNo = &s
}

// LicenseNo returns the value of the "LicenseNo" field in the mutation.
func (m *JobDetailMutation) LicenseNo() (r string, exists bool) {
	v := m._LicenseNo
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNo returns the old "LicenseNo" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLicenseNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNo: %w", err)
	}
	return oldValue.LicenseNo, nil
}

// ClearLicenseNo clears the value of the "LicenseNo" field.
func (m *JobDetailMutation) ClearLicenseNo() {
	m._LicenseNo = nil
	m.clearedFields[jobdetail.FieldLicenseNo] = struct{}{}
}

// LicenseNoCleared returns if the "LicenseNo" field was cleared in this mutation.
func (m *JobDetailMutation) LicenseNoCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLicenseNo]
	return ok
}

// ResetLicenseNo resets all changes to the "LicenseNo" field.
func (m *JobDetailMutation) ResetLicenseNo() {
	m._LicenseNo = nil
	delete(m.clearedFields, jobdetail.FieldLicenseNo)
}

// SetConstructionArea sets the "ConstructionArea" field.
func (m *JobDetailMutation) SetConstructionArea(s string) {
	m._ConstructionArea = &s
}

// ConstructionArea returns the value of the "ConstructionArea" field in the mutation.
func (m *JobDetailMutation) ConstructionArea() (r string, exists bool) {
	v := m._ConstructionArea
	if v == nil {
		return
	}
	return *v, true
}

// OldConstructionArea returns the old "ConstructionArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldConstructionArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstructionArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstructionArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstructionArea: %w", err)
	}
	return oldValue.ConstructionArea, nil
}

// ClearConstructionArea clears the value of the "ConstructionArea" field.
func (m *JobDetailMutation) ClearConstructionArea() {
	m._ConstructionArea = nil
	m.clearedFields[jobdetail.FieldConstructionArea] = struct{}{}
}

// ConstructionAreaCleared returns if the "ConstructionArea" field was cleared in this mutation.
func (m *JobDetailMutation) ConstructionAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldConstructionArea]
	return ok
}

// ResetConstructionArea resets all changes to the "ConstructionArea" field.
func (m *JobDetailMutation) ResetConstructionArea() {
	m._ConstructionArea = nil
	delete(m.clearedFields, jobdetail.FieldConstructionArea)
}

// SetDistrict sets the "District" field.
func (m *JobDetailMutation) SetDistrict(s string) {
	m._District = &s
}

// District returns the value of the "District" field in the mutation.
func (m *JobDetailMutation) District() (r string, exists bool) {
	v := m._District
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "District" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldDistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "District" field.
func (m *JobDetailMutation) ClearDistrict() {
	m._District = nil
	m.clearedFields[jobdetail.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "District" field was cleared in this mutation.
func (m *JobDetailMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "District" field.
func (m *JobDetailMutation) ResetDistrict() {
	m._District = nil
	delete(m.clearedFields, jobdetail.FieldDistrict)
}

// SetVillage sets the "Village" field.
func (m *JobDetailMutation) SetVillage(s string) {
	m._Village = &s
}

// Village returns the value of the "Village" field in the mutation.
func (m *JobDetailMutation) Village() (r string, exists bool) {
	v := m._Village
	if v == nil {
		return
	}
	return *v, true
}

// OldVillage returns the old "Village" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldVillage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVillage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVillage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVillage: %w", err)
	}
	return oldValue.Village, nil
}

// ClearVillage clears the value of the "Village" field.
func (m *JobDetailMutation) ClearVillage() {
	m._Village = nil
	m.clearedFields[jobdetail.FieldVillage] = struct{}{}
}

// VillageCleared returns if the "Village" field was cleared in this mutation.
func (m *JobDetailMutation) VillageCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldVillage]
	return ok
}

// ResetVillage resets all changes to the "Village" field.
func (m *JobDetailMutation) ResetVillage() {
	m._Village = nil
	delete(m.clearedFields, jobdetail.FieldVillage)
}

// SetStreet sets the "Street" field.
func (m *JobDetailMutation) SetStreet(s string) {
	m._Street = &s
}

// Street returns the value of the "Street" field in the mutation.
func (m *JobDetailMutation) Street() (r string, exists bool) {
	v := m._Street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "Street" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "Street" field.
func (m *JobDetailMutation) ClearStreet() {
	m._Street = nil
	m.clearedFields[jobdetail.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "Street" field was cleared in this mutation.
func (m *JobDetailMutation) StreetCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "Street" field.
func (m *JobDetailMutation) ResetStreet() {
	m._Street = nil
	delete(m.clearedFields, jobdetail.FieldStreet)
}

// SetBuildingClass sets the "BuildingClass" field.
func (m *JobDetailMutation) SetBuildingClass(s string) {
	m._BuildingClass = &s
}

// BuildingClass returns the value of the "BuildingClass" field in the mutation.
func (m *JobDetailMutation) BuildingClass() (r string, exists bool) {
	v := m._BuildingClass
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingClass returns the old "BuildingClass" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBuildingClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingClass: %w", err)
	}
	return oldValue.BuildingClass, nil
}

// ClearBuildingClass clears the value of the "BuildingClass" field.
func (m *JobDetailMutation) ClearBuildingClass() {
	m._BuildingClass = nil
	m.clearedFields[jobdetail.FieldBuildingClass] = struct{}{}
}

// BuildingClassCleared returns if the "BuildingClass" field was cleared in this mutation.
func (m *JobDetailMutation) BuildingClassCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBuildingClass]
	return ok
}

// ResetBuildingClass resets all changes to the "BuildingClass" field.
func (m *JobDetailMutation) ResetBuildingClass() {
	m._BuildingClass = nil
	delete(m.clearedFields, jobdetail.FieldBuildingClass)
}

// SetBuildingType sets the "BuildingType" field.
func (m *JobDetailMutation) SetBuildingType(s string) {
	m._BuildingType = &s
}

// BuildingType returns the value of the "BuildingType" field in the mutation.
func (m *JobDetailMutation) BuildingType() (r string, exists bool) {
	v := m._BuildingType
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingType returns the old "BuildingType" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBuildingType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingType: %w", err)
	}
	return oldValue.BuildingType, nil
}

// ClearBuildingType clears the value of the "BuildingType" field.
func (m *JobDetailMutation) ClearBuildingType() {
	m._BuildingType = nil
	m.clearedFields[jobdetail.FieldBuildingType] = struct{}{}
}

// BuildingTypeCleared returns if the "BuildingType" field was cleared in this mutation.
func (m *JobDetailMutation) BuildingTypeCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBuildingType]
	return ok
}

// ResetBuildingType resets all changes to the "BuildingType" field.
func (m *JobDetailMutation) ResetBuildingType() {
	m._BuildingType = nil
	delete(m.clearedFields, jobdetail.FieldBuildingType)
}

// SetBuildingBlock sets the "BuildingBlock" field.
func (m *JobDetailMutation) SetBuildingBlock(s string) {
	m._BuildingBlock = &s
}

// BuildingBlock returns the value of the "BuildingBlock" field in the mutation.
func (m *JobDetailMutation) BuildingBlock() (r string, exists bool) {
	v := m._BuildingBlock
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildingBlock returns the old "BuildingBlock" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldBuildingBlock(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildingBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildingBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildingBlock: %w", err)
	}
	return oldValue.BuildingBlock, nil
}

// ClearBuildingBlock clears the value of the "BuildingBlock" field.
func (m *JobDetailMutation) ClearBuildingBlock() {
	m._BuildingBlock = nil
	m.clearedFields[jobdetail.FieldBuildingBlock] = struct{}{}
}

// BuildingBlockCleared returns if the "BuildingBlock" field was cleared in this mutation.
func (m *JobDetailMutation) BuildingBlockCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldBuildingBlock]
	return ok
}

// ResetBuildingBlock resets all changes to the "BuildingBlock" field.
func (m *JobDetailMutation) ResetBuildingBlock() {
	m._BuildingBlock = nil
	delete(m.clearedFields, jobdetail.FieldBuildingBlock)
}

// SetLandArea sets the "LandArea" field.
func (m *JobDetailMutation) SetLandArea(s string) {
	m._LandArea = &s
}

// LandArea returns the value of the "LandArea" field in the mutation.
func (m *JobDetailMutation) LandArea() (r string, exists bool) {
	v := m._LandArea
	if v == nil {
		return
	}
	return *v, true
}

// OldLandArea returns the old "LandArea" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldLandArea(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandArea: %w", err)
	}
	return oldValue.LandArea, nil
}

// ClearLandArea clears the value of the "LandArea" field.
func (m *JobDetailMutation) ClearLandArea() {
	m._LandArea = nil
	m.clearedFields[jobdetail.FieldLandArea] = struct{}{}
}

// LandAreaCleared returns if the "LandArea" field was cleared in this mutation.
func (m *JobDetailMutation) LandAreaCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldLandArea]
	return ok
}

// ResetLandArea resets all changes to the "LandArea" field.
func (m *JobDetailMutation) ResetLandArea() {
	m._LandArea = nil
	delete(m.clearedFields, jobdetail.FieldLandArea)
}

// SetFloors sets the "Floors" field.
func (m *JobDetailMutation) SetFloors(i int) {
	m._Floors = &i
	m.add_Floors = nil
}

// Floors returns the value of the "Floors" field in the mutation.
func (m *JobDetailMutation) Floors() (r int, exists bool) {
	v := m._Floors
	if v == nil {
		return
	}
	return *v, true
}

// OldFloors returns the old "Floors" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldFloors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFloors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFloors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloors: %w", err)
	}
	return oldValue.Floors, nil
}

// AddFloors adds i to the "Floors" field.
func (m *JobDetailMutation) AddFloors(i int) {
	if m.add_Floors != nil {
		*m.add_Floors += i
	} else {
		m.add_Floors = &i
	}
}

// AddedFloors returns the value that was added to the "Floors" field in this mutation.
func (m *JobDetailMutation) AddedFloors() (r int, exists bool) {
	v := m.add_Floors
	if v == nil {
		return
	}
	return *v, true
}

// ClearFloors clears the value of the "Floors" field.
func (m *JobDetailMutation) ClearFloors() {
	m._Floors = nil
	m.add_Floors = nil
	m.clearedFields[jobdetail.FieldFloors] = struct{}{}
}

// FloorsCleared returns if the "Floors" field was cleared in this mutation.
func (m *JobDetailMutation) FloorsCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldFloors]
	return ok
}

// ResetFloors resets all changes to the "Floors" field.
func (m *JobDetailMutation) ResetFloors() {
	m._Floors = nil
	m.add_Floors = nil
	delete(m.clearedFields, jobdetail.FieldFloors)
}

// SetUsagePurpose sets the "UsagePurpose" field.
func (m *JobDetailMutation) SetUsagePurpose(s string) {
	m._UsagePurpose = &s
}

// UsagePurpose returns the value of the "UsagePurpose" field in the mutation.
func (m *JobDetailMutation) UsagePurpose() (r string, exists bool) {
	v := m._UsagePurpose
	if v == nil {
		return
	}
	return *v, true
}

// OldUsagePurpose returns the old "UsagePurpose" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldUsagePurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsagePurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsagePurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsagePurpose: %w", err)
	}
	return oldValue.UsagePurpose, nil
}

// ClearUsagePurpose clears the value of the "UsagePurpose" field.
func (m *JobDetailMutation) ClearUsagePurpose() {
	m._UsagePurpose = nil
	m.clearedFields[jobdetail.FieldUsagePurpose] = struct{}{}
}

// UsagePurposeCleared returns if the "UsagePurpose" field was cleared in this mutation.
func (m *JobDetailMutation) UsagePurposeCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldUsagePurpose]
	return ok
}

// ResetUsagePurpose resets all changes to the "UsagePurpose" field.
func (m *JobDetailMutation) ResetUsagePurpose() {
	m._UsagePurpose = nil
	delete(m.clearedFields, jobdetail.FieldUsagePurpose)
}

// SetNote sets the "Note" field.
func (m *JobDetailMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobDetailMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobDetailMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobdetail.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobDetailMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobdetail.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobDetailMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobdetail.FieldNote)
}

// SetStarted sets the "Started" field.
func (m *JobDetailMutation) SetStarted(i int) {
	m._Started = &i
	m.add_Started = nil
}

// Started returns the value of the "Started" field in the mutation.
func (m *JobDetailMutation) Started() (r int, exists bool) {
	v := m._Started
	if v == nil {
		return
	}
	return *v, true
}

// OldStarted returns the old "Started" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldStarted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStarted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStarted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStarted: %w", err)
	}
	return oldValue.Started, nil
}

// AddStarted adds i to the "Started" field.
func (m *JobDetailMutation) AddStarted(i int) {
	if m.add_Started != nil {
		*m.add_Started += i
	} else {
		m.add_Started = &i
	}
}

// AddedStarted returns the value that was added to the "Started" field in this mutation.
func (m *JobDetailMutation) AddedStarted() (r int, exists bool) {
	v := m.add_Started
	if v == nil {
		return
	}
	return *v, true
}

// ResetStarted resets all changes to the "Started" field.
func (m *JobDetailMutation) ResetStarted() {
	m._Started = nil
	m.add_Started = nil
}

// SetDeleted sets the "Deleted" field.
func (m *JobDetailMutation) SetDeleted(i int) {
	m._Deleted = &i
	m.add_Deleted = nil
}

// Deleted returns the value of the "Deleted" field in the mutation.
func (m *JobDetailMutation) Deleted() (r int, exists bool) {
	v := m._Deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "Deleted" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldDeleted(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// AddDeleted adds i to the "Deleted" field.
func (m *JobDetailMutation) AddDeleted(i int) {
	if m.add_Deleted != nil {
		*m.add_Deleted += i
	} else {
		m.add_Deleted = &i
	}
}

// AddedDeleted returns the value that was added to the "Deleted" field in this mutation.
func (m *JobDetailMutation) AddedDeleted() (r int, exists bool) {
	v := m.add_Deleted
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeleted resets all changes to the "Deleted" field.
func (m *JobDetailMutation) ResetDeleted() {
	m._Deleted = nil
	m.add_Deleted = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *JobDetailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobDetailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobDetailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobDetailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobDetailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobDetail entity.
// If the JobDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDetailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobDetailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner" edge to the JobOwner entity by id.
func (m *JobDetailMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the JobOwner entity.
func (m *JobDetailMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the JobOwner entity was cleared.
func (m *JobDetailMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *JobDetailMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *JobDetailMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetContractorID sets the "contractor" edge to the JobContractor entity by id.
func (m *JobDetailMutation) SetContractorID(id int) {
	m.contractor = &id
}

// ClearContractor clears the "contractor" edge to the JobContractor entity.
func (m *JobDetailMutation) ClearContractor() {
	m.clearedcontractor = true
}

// ContractorCleared reports if the "contractor" edge to the JobContractor entity was cleared.
func (m *JobDetailMutation) ContractorCleared() bool {
	return m.clearedcontractor
}

// ContractorID returns the "contractor" edge ID in the mutation.
func (m *JobDetailMutation) ContractorID() (id int, exists bool) {
	if m.contractor != nil {
		return *m.contractor, true
	}
	return
}

// ContractorIDs returns the "contractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ContractorIDs() (ids []int) {
	if id := m.contractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContractor resets all changes to the "contractor" edge.
func (m *JobDetailMutation) ResetContractor() {
	m.contractor = nil
	m.clearedcontractor = false
}

// SetAuthorID sets the "author" edge to the JobAuthor entity by id.
func (m *JobDetailMutation) SetAuthorID(id int) {
	m.author = &id
}

// ClearAuthor clears the "author" edge to the JobAuthor entity.
func (m *JobDetailMutation) ClearAuthor() {
	m.clearedauthor = true
}

// AuthorCleared reports if the "author" edge to the JobAuthor entity was cleared.
func (m *JobDetailMutation) AuthorCleared() bool {
	return m.clearedauthor
}

// AuthorID returns the "author" edge ID in the mutation.
func (m *JobDetailMutation) AuthorID() (id int, exists bool) {
	if m.author != nil {
		return *m.author, true
	}
	return
}

// AuthorIDs returns the "author" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) AuthorIDs() (ids []int) {
	if id := m.author; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthor resets all changes to the "author" edge.
func (m *JobDetailMutation) ResetAuthor() {
	m.author = nil
	m.clearedauthor = false
}

// SetProgressID sets the "progress" edge to the JobProgress entity by id.
func (m *JobDetailMutation) SetProgressID(id int) {
	m.progress = &id
}

// ClearProgress clears the "progress" edge to the JobProgress entity.
func (m *JobDetailMutation) ClearProgress() {
	m.clearedprogress = true
}

// ProgressCleared reports if the "progress" edge to the JobProgress entity was cleared.
func (m *JobDetailMutation) ProgressCleared() bool {
	return m.clearedprogress
}

// ProgressID returns the "progress" edge ID in the mutation.
func (m *JobDetailMutation) ProgressID() (id int, exists bool) {
	if m.progress != nil {
		return *m.progress, true
	}
	return
}

// ProgressIDs returns the "progress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProgressID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ProgressIDs() (ids []int) {
	if id := m.progress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProgress resets all changes to the "progress" edge.
func (m *JobDetailMutation) ResetProgress() {
	m.progress = nil
	m.clearedprogress = false
}

// SetInspectorID sets the "inspector" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetInspectorID(id int) {
	m.inspector = &id
}

// ClearInspector clears the "inspector" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearInspector() {
	m.clearedinspector = true
}

// InspectorCleared reports if the "inspector" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) InspectorCleared() bool {
	return m.clearedinspector
}

// InspectorID returns the "inspector" edge ID in the mutation.
func (m *JobDetailMutation) InspectorID() (id int, exists bool) {
	if m.inspector != nil {
		return *m.inspector, true
	}
	return
}

// InspectorIDs returns the "inspector" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InspectorID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) InspectorIDs() (ids []int) {
	if id := m.inspector; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInspector resets all changes to the "inspector" edge.
func (m *JobDetailMutation) ResetInspector() {
	m.inspector = nil
	m.clearedinspector = false
}

// SetArchitectID sets the "architect" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetArchitectID(id int) {
	m.architect = &id
}

// ClearArchitect clears the "architect" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearArchitect() {
	m.clearedarchitect = true
}

// ArchitectCleared reports if the "architect" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ArchitectCleared() bool {
	return m.clearedarchitect
}

// ArchitectID returns the "architect" edge ID in the mutation.
func (m *JobDetailMutation) ArchitectID() (id int, exists bool) {
	if m.architect != nil {
		return *m.architect, true
	}
	return
}

// ArchitectIDs returns the "architect" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ArchitectID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ArchitectIDs() (ids []int) {
	if id := m.architect; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetArchitect resets all changes to the "architect" edge.
func (m *JobDetailMutation) ResetArchitect() {
	m.architect = nil
	m.clearedarchitect = false
}

// SetStaticID sets the "static" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetStaticID(id int) {
	m.static = &id
}

// ClearStatic clears the "static" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearStatic() {
	m.clearedstatic = true
}

// StaticCleared reports if the "static" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) StaticCleared() bool {
	return m.clearedstatic
}

// StaticID returns the "static" edge ID in the mutation.
func (m *JobDetailMutation) StaticID() (id int, exists bool) {
	if m.static != nil {
		return *m.static, true
	}
	return
}

// StaticIDs returns the "static" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaticID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) StaticIDs() (ids []int) {
	if id := m.static; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatic resets all changes to the "static" edge.
func (m *JobDetailMutation) ResetStatic() {
	m.static = nil
	m.clearedstatic = false
}

// SetMechanicID sets the "mechanic" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetMechanicID(id int) {
	m.mechanic = &id
}

// ClearMechanic clears the "mechanic" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearMechanic() {
	m.clearedmechanic = true
}

// MechanicCleared reports if the "mechanic" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) MechanicCleared() bool {
	return m.clearedmechanic
}

// MechanicID returns the "mechanic" edge ID in the mutation.
func (m *JobDetailMutation) MechanicID() (id int, exists bool) {
	if m.mechanic != nil {
		return *m.mechanic, true
	}
	return
}

// MechanicIDs returns the "mechanic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MechanicID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) MechanicIDs() (ids []int) {
	if id := m.mechanic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMechanic resets all changes to the "mechanic" edge.
func (m *JobDetailMutation) ResetMechanic() {
	m.mechanic = nil
	m.clearedmechanic = false
}

// SetElectricID sets the "electric" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetElectricID(id int) {
	m.electric = &id
}

// ClearElectric clears the "electric" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearElectric() {
	m.clearedelectric = true
}

// ElectricCleared reports if the "electric" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ElectricCleared() bool {
	return m.clearedelectric
}

// ElectricID returns the "electric" edge ID in the mutation.
func (m *JobDetailMutation) ElectricID() (id int, exists bool) {
	if m.electric != nil {
		return *m.electric, true
	}
	return
}

// ElectricIDs returns the "electric" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectricID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ElectricIDs() (ids []int) {
	if id := m.electric; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElectric resets all changes to the "electric" edge.
func (m *JobDetailMutation) ResetElectric() {
	m.electric = nil
	m.clearedelectric = false
}

// SetControllerID sets the "controller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetControllerID(id int) {
	m.controller = &id
}

// ClearController clears the "controller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearController() {
	m.clearedcontroller = true
}

// ControllerCleared reports if the "controller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ControllerCleared() bool {
	return m.clearedcontroller
}

// ControllerID returns the "controller" edge ID in the mutation.
func (m *JobDetailMutation) ControllerID() (id int, exists bool) {
	if m.controller != nil {
		return *m.controller, true
	}
	return
}

// ControllerIDs returns the "controller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ControllerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ControllerIDs() (ids []int) {
	if id := m.controller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetController resets all changes to the "controller" edge.
func (m *JobDetailMutation) ResetController() {
	m.controller = nil
	m.clearedcontroller = false
}

// SetMechaniccontrollerID sets the "mechaniccontroller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetMechaniccontrollerID(id int) {
	m.mechaniccontroller = &id
}

// ClearMechaniccontroller clears the "mechaniccontroller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearMechaniccontroller() {
	m.clearedmechaniccontroller = true
}

// MechaniccontrollerCleared reports if the "mechaniccontroller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) MechaniccontrollerCleared() bool {
	return m.clearedmechaniccontroller
}

// MechaniccontrollerID returns the "mechaniccontroller" edge ID in the mutation.
func (m *JobDetailMutation) MechaniccontrollerID() (id int, exists bool) {
	if m.mechaniccontroller != nil {
		return *m.mechaniccontroller, true
	}
	return
}

// MechaniccontrollerIDs returns the "mechaniccontroller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MechaniccontrollerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) MechaniccontrollerIDs() (ids []int) {
	if id := m.mechaniccontroller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMechaniccontroller resets all changes to the "mechaniccontroller" edge.
func (m *JobDetailMutation) ResetMechaniccontroller() {
	m.mechaniccontroller = nil
	m.clearedmechaniccontroller = false
}

// SetElectriccontrollerID sets the "electriccontroller" edge to the CompanyEngineer entity by id.
func (m *JobDetailMutation) SetElectriccontrollerID(id int) {
	m.electriccontroller = &id
}

// ClearElectriccontroller clears the "electriccontroller" edge to the CompanyEngineer entity.
func (m *JobDetailMutation) ClearElectriccontroller() {
	m.clearedelectriccontroller = true
}

// ElectriccontrollerCleared reports if the "electriccontroller" edge to the CompanyEngineer entity was cleared.
func (m *JobDetailMutation) ElectriccontrollerCleared() bool {
	return m.clearedelectriccontroller
}

// ElectriccontrollerID returns the "electriccontroller" edge ID in the mutation.
func (m *JobDetailMutation) ElectriccontrollerID() (id int, exists bool) {
	if m.electriccontroller != nil {
		return *m.electriccontroller, true
	}
	return
}

// ElectriccontrollerIDs returns the "electriccontroller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectriccontrollerID instead. It exists only for internal usage by the builders.
func (m *JobDetailMutation) ElectriccontrollerIDs() (ids []int) {
	if id := m.electriccontroller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElectriccontroller resets all changes to the "electriccontroller" edge.
func (m *JobDetailMutation) ResetElectriccontroller() {
	m.electriccontroller = nil
	m.clearedelectriccontroller = false
}

// AddLayerIDs adds the "layers" edge to the JobLayer entity by ids.
func (m *JobDetailMutation) AddLayerIDs(ids ...int) {
	if m.layers == nil {
		m.layers = make(map[int]struct{})
	}
	for i := range ids {
		m.layers[ids[i]] = struct{}{}
	}
}

// ClearLayers clears the "layers" edge to the JobLayer entity.
func (m *JobDetailMutation) ClearLayers() {
	m.clearedlayers = true
}

// LayersCleared reports if the "layers" edge to the JobLayer entity was cleared.
func (m *JobDetailMutation) LayersCleared() bool {
	return m.clearedlayers
}

// RemoveLayerIDs removes the "layers" edge to the JobLayer entity by IDs.
func (m *JobDetailMutation) RemoveLayerIDs(ids ...int) {
	if m.removedlayers == nil {
		m.removedlayers = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.layers, ids[i])
		m.removedlayers[ids[i]] = struct{}{}
	}
}

// RemovedLayers returns the removed IDs of the "layers" edge to the JobLayer entity.
func (m *JobDetailMutation) RemovedLayersIDs() (ids []int) {
	for id := range m.removedlayers {
		ids = append(ids, id)
	}
	return
}

// LayersIDs returns the "layers" edge IDs in the mutation.
func (m *JobDetailMutation) LayersIDs() (ids []int) {
	for id := range m.layers {
		ids = append(ids, id)
	}
	return
}

// ResetLayers resets all changes to the "layers" edge.
func (m *JobDetailMutation) ResetLayers() {
	m.layers = nil
	m.clearedlayers = false
	m.removedlayers = nil
}

// Where appends a list predicates to the JobDetailMutation builder.
func (m *JobDetailMutation) Where(ps ...predicate.JobDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobDetail).
func (m *JobDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobDetailMutation) Fields() []string {
	fields := make([]string, 0, 27)
	if m._YibfNo != nil {
		fields = append(fields, jobdetail.FieldYibfNo)
	}
	if m._Province != nil {
		fields = append(fields, jobdetail.FieldProvince)
	}
	if m._Idare != nil {
		fields = append(fields, jobdetail.FieldIdare)
	}
	if m._Pafta != nil {
		fields = append(fields, jobdetail.FieldPafta)
	}
	if m._Ada != nil {
		fields = append(fields, jobdetail.FieldAda)
	}
	if m._Parsel != nil {
		fields = append(fields, jobdetail.FieldParsel)
	}
	if m._FolderNo != nil {
		fields = append(fields, jobdetail.FieldFolderNo)
	}
	if m._Status != nil {
		fields = append(fields, jobdetail.FieldStatus)
	}
	if m._ContractDate != nil {
		fields = append(fields, jobdetail.FieldContractDate)
	}
	if m._StartDate != nil {
		fields = append(fields, jobdetail.FieldStartDate)
	}
	if m._LicenseDate != nil {
		fields = append(fields, jobdetail.FieldLicenseDate)
	}
	if m._LicenseNo != nil {
		fields = append(fields, jobdetail.FieldLicenseNo)
	}
	if m._ConstructionArea != nil {
		fields = append(fields, jobdetail.FieldConstructionArea)
	}
	if m._District != nil {
		fields = append(fields, jobdetail.FieldDistrict)
	}
	if m._Village != nil {
		fields = append(fields, jobdetail.FieldVillage)
	}
	if m._Street != nil {
		fields = append(fields, jobdetail.FieldStreet)
	}
	if m._BuildingClass != nil {
		fields = append(fields, jobdetail.FieldBuildingClass)
	}
	if m._BuildingType != nil {
		fields = append(fields, jobdetail.FieldBuildingType)
	}
	if m._BuildingBlock != nil {
		fields = append(fields, jobdetail.FieldBuildingBlock)
	}
	if m._LandArea != nil {
		fields = append(fields, jobdetail.FieldLandArea)
	}
	if m._Floors != nil {
		fields = append(fields, jobdetail.FieldFloors)
	}
	if m._UsagePurpose != nil {
		fields = append(fields, jobdetail.FieldUsagePurpose)
	}
	if m._Note != nil {
		fields = append(fields, jobdetail.FieldNote)
	}
	if m._Started != nil {
		fields = append(fields, jobdetail.FieldStarted)
	}
	if m._Deleted != nil {
		fields = append(fields, jobdetail.FieldDeleted)
	}
	if m.created_at != nil {
		fields = append(fields, jobdetail.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobdetail.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.YibfNo()
	case jobdetail.FieldProvince:
		return m.Province()
	case jobdetail.FieldIdare:
		return m.Idare()
	case jobdetail.FieldPafta:
		return m.Pafta()
	case jobdetail.FieldAda:
		return m.Ada()
	case jobdetail.FieldParsel:
		return m.Parsel()
	case jobdetail.FieldFolderNo:
		return m.FolderNo()
	case jobdetail.FieldStatus:
		return m.Status()
	case jobdetail.FieldContractDate:
		return m.ContractDate()
	case jobdetail.FieldStartDate:
		return m.StartDate()
	case jobdetail.FieldLicenseDate:
		return m.LicenseDate()
	case jobdetail.FieldLicenseNo:
		return m.LicenseNo()
	case jobdetail.FieldConstructionArea:
		return m.ConstructionArea()
	case jobdetail.FieldDistrict:
		return m.District()
	case jobdetail.FieldVillage:
		return m.Village()
	case jobdetail.FieldStreet:
		return m.Street()
	case jobdetail.FieldBuildingClass:
		return m.BuildingClass()
	case jobdetail.FieldBuildingType:
		return m.BuildingType()
	case jobdetail.FieldBuildingBlock:
		return m.BuildingBlock()
	case jobdetail.FieldLandArea:
		return m.LandArea()
	case jobdetail.FieldFloors:
		return m.Floors()
	case jobdetail.FieldUsagePurpose:
		return m.UsagePurpose()
	case jobdetail.FieldNote:
		return m.Note()
	case jobdetail.FieldStarted:
		return m.Started()
	case jobdetail.FieldDeleted:
		return m.Deleted()
	case jobdetail.FieldCreatedAt:
		return m.CreatedAt()
	case jobdetail.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.OldYibfNo(ctx)
	case jobdetail.FieldProvince:
		return m.OldProvince(ctx)
	case jobdetail.FieldIdare:
		return m.OldIdare(ctx)
	case jobdetail.FieldPafta:
		return m.OldPafta(ctx)
	case jobdetail.FieldAda:
		return m.OldAda(ctx)
	case jobdetail.FieldParsel:
		return m.OldParsel(ctx)
	case jobdetail.FieldFolderNo:
		return m.OldFolderNo(ctx)
	case jobdetail.FieldStatus:
		return m.OldStatus(ctx)
	case jobdetail.FieldContractDate:
		return m.OldContractDate(ctx)
	case jobdetail.FieldStartDate:
		return m.OldStartDate(ctx)
	case jobdetail.FieldLicenseDate:
		return m.OldLicenseDate(ctx)
	case jobdetail.FieldLicenseNo:
		return m.OldLicenseNo(ctx)
	case jobdetail.FieldConstructionArea:
		return m.OldConstructionArea(ctx)
	case jobdetail.FieldDistrict:
		return m.OldDistrict(ctx)
	case jobdetail.FieldVillage:
		return m.OldVillage(ctx)
	case jobdetail.FieldStreet:
		return m.OldStreet(ctx)
	case jobdetail.FieldBuildingClass:
		return m.OldBuildingClass(ctx)
	case jobdetail.FieldBuildingType:
		return m.OldBuildingType(ctx)
	case jobdetail.FieldBuildingBlock:
		return m.OldBuildingBlock(ctx)
	case jobdetail.FieldLandArea:
		return m.OldLandArea(ctx)
	case jobdetail.FieldFloors:
		return m.OldFloors(ctx)
	case jobdetail.FieldUsagePurpose:
		return m.OldUsagePurpose(ctx)
	case jobdetail.FieldNote:
		return m.OldNote(ctx)
	case jobdetail.FieldStarted:
		return m.OldStarted(ctx)
	case jobdetail.FieldDeleted:
		return m.OldDeleted(ctx)
	case jobdetail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobdetail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobdetail.FieldYibfNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYibfNo(v)
		return nil
	case jobdetail.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case jobdetail.FieldIdare:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdare(v)
		return nil
	case jobdetail.FieldPafta:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPafta(v)
		return nil
	case jobdetail.FieldAda:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAda(v)
		return nil
	case jobdetail.FieldParsel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParsel(v)
		return nil
	case jobdetail.FieldFolderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderNo(v)
		return nil
	case jobdetail.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobdetail.FieldContractDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractDate(v)
		return nil
	case jobdetail.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case jobdetail.FieldLicenseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseDate(v)
		return nil
	case jobdetail.FieldLicenseNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNo(v)
		return nil
	case jobdetail.FieldConstructionArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstructionArea(v)
		return nil
	case jobdetail.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case jobdetail.FieldVillage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVillage(v)
		return nil
	case jobdetail.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case jobdetail.FieldBuildingClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingClass(v)
		return nil
	case jobdetail.FieldBuildingType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingType(v)
		return nil
	case jobdetail.FieldBuildingBlock:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildingBlock(v)
		return nil
	case jobdetail.FieldLandArea:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandArea(v)
		return nil
	case jobdetail.FieldFloors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloors(v)
		return nil
	case jobdetail.FieldUsagePurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsagePurpose(v)
		return nil
	case jobdetail.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobdetail.FieldStarted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStarted(v)
		return nil
	case jobdetail.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case jobdetail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobdetail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_YibfNo != nil {
		fields = append(fields, jobdetail.FieldYibfNo)
	}
	if m.add_Status != nil {
		fields = append(fields, jobdetail.FieldStatus)
	}
	if m.add_Floors != nil {
		fields = append(fields, jobdetail.FieldFloors)
	}
	if m.add_Started != nil {
		fields = append(fields, jobdetail.FieldStarted)
	}
	if m.add_Deleted != nil {
		fields = append(fields, jobdetail.FieldDeleted)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobdetail.FieldYibfNo:
		return m.AddedYibfNo()
	case jobdetail.FieldStatus:
		return m.AddedStatus()
	case jobdetail.FieldFloors:
		return m.AddedFloors()
	case jobdetail.FieldStarted:
		return m.AddedStarted()
	case jobdetail.FieldDeleted:
		return m.AddedDeleted()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobdetail.FieldYibfNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYibfNo(v)
		return nil
	case jobdetail.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case jobdetail.FieldFloors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloors(v)
		return nil
	case jobdetail.FieldStarted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStarted(v)
		return nil
	case jobdetail.FieldDeleted:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown JobDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobdetail.FieldProvince) {
		fields = append(fields, jobdetail.FieldProvince)
	}
	if m.FieldCleared(jobdetail.FieldIdare) {
		fields = append(fields, jobdetail.FieldIdare)
	}
	if m.FieldCleared(jobdetail.FieldPafta) {
		fields = append(fields, jobdetail.FieldPafta)
	}
	if m.FieldCleared(jobdetail.FieldAda) {
		fields = append(fields, jobdetail.FieldAda)
	}
	if m.FieldCleared(jobdetail.FieldParsel) {
		fields = append(fields, jobdetail.FieldParsel)
	}
	if m.FieldCleared(jobdetail.FieldFolderNo) {
		fields = append(fields, jobdetail.FieldFolderNo)
	}
	if m.FieldCleared(jobdetail.FieldContractDate) {
		fields = append(fields, jobdetail.FieldContractDate)
	}
	if m.FieldCleared(jobdetail.FieldStartDate) {
		fields = append(fields, jobdetail.FieldStartDate)
	}
	if m.FieldCleared(jobdetail.FieldLicenseDate) {
		fields = append(fields, jobdetail.FieldLicenseDate)
	}
	if m.FieldCleared(jobdetail.FieldLicenseNo) {
		fields = append(fields, jobdetail.FieldLicenseNo)
	}
	if m.FieldCleared(jobdetail.FieldConstructionArea) {
		fields = append(fields, jobdetail.FieldConstructionArea)
	}
	if m.FieldCleared(jobdetail.FieldDistrict) {
		fields = append(fields, jobdetail.FieldDistrict)
	}
	if m.FieldCleared(jobdetail.FieldVillage) {
		fields = append(fields, jobdetail.FieldVillage)
	}
	if m.FieldCleared(jobdetail.FieldStreet) {
		fields = append(fields, jobdetail.FieldStreet)
	}
	if m.FieldCleared(jobdetail.FieldBuildingClass) {
		fields = append(fields, jobdetail.FieldBuildingClass)
	}
	if m.FieldCleared(jobdetail.FieldBuildingType) {
		fields = append(fields, jobdetail.FieldBuildingType)
	}
	if m.FieldCleared(jobdetail.FieldBuildingBlock) {
		fields = append(fields, jobdetail.FieldBuildingBlock)
	}
	if m.FieldCleared(jobdetail.FieldLandArea) {
		fields = append(fields, jobdetail.FieldLandArea)
	}
	if m.FieldCleared(jobdetail.FieldFloors) {
		fields = append(fields, jobdetail.FieldFloors)
	}
	if m.FieldCleared(jobdetail.FieldUsagePurpose) {
		fields = append(fields, jobdetail.FieldUsagePurpose)
	}
	if m.FieldCleared(jobdetail.FieldNote) {
		fields = append(fields, jobdetail.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobDetailMutation) ClearField(name string) error {
	switch name {
	case jobdetail.FieldProvince:
		m.ClearProvince()
		return nil
	case jobdetail.FieldIdare:
		m.ClearIdare()
		return nil
	case jobdetail.FieldPafta:
		m.ClearPafta()
		return nil
	case jobdetail.FieldAda:
		m.ClearAda()
		return nil
	case jobdetail.FieldParsel:
		m.ClearParsel()
		return nil
	case jobdetail.FieldFolderNo:
		m.ClearFolderNo()
		return nil
	case jobdetail.FieldContractDate:
		m.ClearContractDate()
		return nil
	case jobdetail.FieldStartDate:
		m.ClearStartDate()
		return nil
	case jobdetail.FieldLicenseDate:
		m.ClearLicenseDate()
		return nil
	case jobdetail.FieldLicenseNo:
		m.ClearLicenseNo()
		return nil
	case jobdetail.FieldConstructionArea:
		m.ClearConstructionArea()
		return nil
	case jobdetail.FieldDistrict:
		m.ClearDistrict()
		return nil
	case jobdetail.FieldVillage:
		m.ClearVillage()
		return nil
	case jobdetail.FieldStreet:
		m.ClearStreet()
		return nil
	case jobdetail.FieldBuildingClass:
		m.ClearBuildingClass()
		return nil
	case jobdetail.FieldBuildingType:
		m.ClearBuildingType()
		return nil
	case jobdetail.FieldBuildingBlock:
		m.ClearBuildingBlock()
		return nil
	case jobdetail.FieldLandArea:
		m.ClearLandArea()
		return nil
	case jobdetail.FieldFloors:
		m.ClearFloors()
		return nil
	case jobdetail.FieldUsagePurpose:
		m.ClearUsagePurpose()
		return nil
	case jobdetail.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobDetailMutation) ResetField(name string) error {
	switch name {
	case jobdetail.FieldYibfNo:
		m.ResetYibfNo()
		return nil
	case jobdetail.FieldProvince:
		m.ResetProvince()
		return nil
	case jobdetail.FieldIdare:
		m.ResetIdare()
		return nil
	case jobdetail.FieldPafta:
		m.ResetPafta()
		return nil
	case jobdetail.FieldAda:
		m.ResetAda()
		return nil
	case jobdetail.FieldParsel:
		m.ResetParsel()
		return nil
	case jobdetail.FieldFolderNo:
		m.ResetFolderNo()
		return nil
	case jobdetail.FieldStatus:
		m.ResetStatus()
		return nil
	case jobdetail.FieldContractDate:
		m.ResetContractDate()
		return nil
	case jobdetail.FieldStartDate:
		m.ResetStartDate()
		return nil
	case jobdetail.FieldLicenseDate:
		m.ResetLicenseDate()
		return nil
	case jobdetail.FieldLicenseNo:
		m.ResetLicenseNo()
		return nil
	case jobdetail.FieldConstructionArea:
		m.ResetConstructionArea()
		return nil
	case jobdetail.FieldDistrict:
		m.ResetDistrict()
		return nil
	case jobdetail.FieldVillage:
		m.ResetVillage()
		return nil
	case jobdetail.FieldStreet:
		m.ResetStreet()
		return nil
	case jobdetail.FieldBuildingClass:
		m.ResetBuildingClass()
		return nil
	case jobdetail.FieldBuildingType:
		m.ResetBuildingType()
		return nil
	case jobdetail.FieldBuildingBlock:
		m.ResetBuildingBlock()
		return nil
	case jobdetail.FieldLandArea:
		m.ResetLandArea()
		return nil
	case jobdetail.FieldFloors:
		m.ResetFloors()
		return nil
	case jobdetail.FieldUsagePurpose:
		m.ResetUsagePurpose()
		return nil
	case jobdetail.FieldNote:
		m.ResetNote()
		return nil
	case jobdetail.FieldStarted:
		m.ResetStarted()
		return nil
	case jobdetail.FieldDeleted:
		m.ResetDeleted()
		return nil
	case jobdetail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobdetail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.owner != nil {
		edges = append(edges, jobdetail.EdgeOwner)
	}
	if m.contractor != nil {
		edges = append(edges, jobdetail.EdgeContractor)
	}
	if m.author != nil {
		edges = append(edges, jobdetail.EdgeAuthor)
	}
	if m.progress != nil {
		edges = append(edges, jobdetail.EdgeProgress)
	}
	if m.inspector != nil {
		edges = append(edges, jobdetail.EdgeInspector)
	}
	if m.architect != nil {
		edges = append(edges, jobdetail.EdgeArchitect)
	}
	if m.static != nil {
		edges = append(edges, jobdetail.EdgeStatic)
	}
	if m.mechanic != nil {
		edges = append(edges, jobdetail.EdgeMechanic)
	}
	if m.electric != nil {
		edges = append(edges, jobdetail.EdgeElectric)
	}
	if m.controller != nil {
		edges = append(edges, jobdetail.EdgeController)
	}
	if m.mechaniccontroller != nil {
		edges = append(edges, jobdetail.EdgeMechaniccontroller)
	}
	if m.electriccontroller != nil {
		edges = append(edges, jobdetail.EdgeElectriccontroller)
	}
	if m.layers != nil {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobdetail.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeContractor:
		if id := m.contractor; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeAuthor:
		if id := m.author; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeProgress:
		if id := m.progress; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeInspector:
		if id := m.inspector; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeArchitect:
		if id := m.architect; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeStatic:
		if id := m.static; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeMechanic:
		if id := m.mechanic; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeElectric:
		if id := m.electric; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeController:
		if id := m.controller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeMechaniccontroller:
		if id := m.mechaniccontroller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeElectriccontroller:
		if id := m.electriccontroller; id != nil {
			return []ent.Value{*id}
		}
	case jobdetail.EdgeLayers:
		ids := make([]ent.Value, 0, len(m.layers))
		for id := range m.layers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedlayers != nil {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobDetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobdetail.EdgeLayers:
		ids := make([]ent.Value, 0, len(m.removedlayers))
		for id := range m.removedlayers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedowner {
		edges = append(edges, jobdetail.EdgeOwner)
	}
	if m.clearedcontractor {
		edges = append(edges, jobdetail.EdgeContractor)
	}
	if m.clearedauthor {
		edges = append(edges, jobdetail.EdgeAuthor)
	}
	if m.clearedprogress {
		edges = append(edges, jobdetail.EdgeProgress)
	}
	if m.clearedinspector {
		edges = append(edges, jobdetail.EdgeInspector)
	}
	if m.clearedarchitect {
		edges = append(edges, jobdetail.EdgeArchitect)
	}
	if m.clearedstatic {
		edges = append(edges, jobdetail.EdgeStatic)
	}
	if m.clearedmechanic {
		edges = append(edges, jobdetail.EdgeMechanic)
	}
	if m.clearedelectric {
		edges = append(edges, jobdetail.EdgeElectric)
	}
	if m.clearedcontroller {
		edges = append(edges, jobdetail.EdgeController)
	}
	if m.clearedmechaniccontroller {
		edges = append(edges, jobdetail.EdgeMechaniccontroller)
	}
	if m.clearedelectriccontroller {
		edges = append(edges, jobdetail.EdgeElectriccontroller)
	}
	if m.clearedlayers {
		edges = append(edges, jobdetail.EdgeLayers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case jobdetail.EdgeOwner:
		return m.clearedowner
	case jobdetail.EdgeContractor:
		return m.clearedcontractor
	case jobdetail.EdgeAuthor:
		return m.clearedauthor
	case jobdetail.EdgeProgress:
		return m.clearedprogress
	case jobdetail.EdgeInspector:
		return m.clearedinspector
	case jobdetail.EdgeArchitect:
		return m.clearedarchitect
	case jobdetail.EdgeStatic:
		return m.clearedstatic
	case jobdetail.EdgeMechanic:
		return m.clearedmechanic
	case jobdetail.EdgeElectric:
		return m.clearedelectric
	case jobdetail.EdgeController:
		return m.clearedcontroller
	case jobdetail.EdgeMechaniccontroller:
		return m.clearedmechaniccontroller
	case jobdetail.EdgeElectriccontroller:
		return m.clearedelectriccontroller
	case jobdetail.EdgeLayers:
		return m.clearedlayers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobDetailMutation) ClearEdge(name string) error {
	switch name {
	case jobdetail.EdgeOwner:
		m.ClearOwner()
		return nil
	case jobdetail.EdgeContractor:
		m.ClearContractor()
		return nil
	case jobdetail.EdgeAuthor:
		m.ClearAuthor()
		return nil
	case jobdetail.EdgeProgress:
		m.ClearProgress()
		return nil
	case jobdetail.EdgeInspector:
		m.ClearInspector()
		return nil
	case jobdetail.EdgeArchitect:
		m.ClearArchitect()
		return nil
	case jobdetail.EdgeStatic:
		m.ClearStatic()
		return nil
	case jobdetail.EdgeMechanic:
		m.ClearMechanic()
		return nil
	case jobdetail.EdgeElectric:
		m.ClearElectric()
		return nil
	case jobdetail.EdgeController:
		m.ClearController()
		return nil
	case jobdetail.EdgeMechaniccontroller:
		m.ClearMechaniccontroller()
		return nil
	case jobdetail.EdgeElectriccontroller:
		m.ClearElectriccontroller()
		return nil
	}
	return fmt.Errorf("unknown JobDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobDetailMutation) ResetEdge(name string) error {
	switch name {
	case jobdetail.EdgeOwner:
		m.ResetOwner()
		return nil
	case jobdetail.EdgeContractor:
		m.ResetContractor()
		return nil
	case jobdetail.EdgeAuthor:
		m.ResetAuthor()
		return nil
	case jobdetail.EdgeProgress:
		m.ResetProgress()
		return nil
	case jobdetail.EdgeInspector:
		m.ResetInspector()
		return nil
	case jobdetail.EdgeArchitect:
		m.ResetArchitect()
		return nil
	case jobdetail.EdgeStatic:
		m.ResetStatic()
		return nil
	case jobdetail.EdgeMechanic:
		m.ResetMechanic()
		return nil
	case jobdetail.EdgeElectric:
		m.ResetElectric()
		return nil
	case jobdetail.EdgeController:
		m.ResetController()
		return nil
	case jobdetail.EdgeMechaniccontroller:
		m.ResetMechaniccontroller()
		return nil
	case jobdetail.EdgeElectriccontroller:
		m.ResetElectriccontroller()
		return nil
	case jobdetail.EdgeLayers:
		m.ResetLayers()
		return nil
	}
	return fmt.Errorf("unknown JobDetail edge %s", name)
}

// JobLayerMutation represents an operation that mutates the JobLayer nodes in the graph.
type JobLayerMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_Name          *string
	_Metre         *string
	_MoldDate      *time.Time
	_ConcreteDate  *time.Time
	_Samples       *int
	add_Samples    *int
	_ConcreteClass *string
	_WeekResult    *string
	_MonthResult   *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	layer          *int
	clearedlayer   bool
	done           bool
	oldValue       func(context.Context) (*JobLayer, error)
	predicates     []predicate.JobLayer
}

var _ ent.Mutation = (*JobLayerMutation)(nil)

// joblayerOption allows management of the mutation configuration using functional options.
type joblayerOption func(*JobLayerMutation)

// newJobLayerMutation creates new mutation for the JobLayer entity.
func newJobLayerMutation(c config, op Op, opts ...joblayerOption) *JobLayerMutation {
	m := &JobLayerMutation{
		config:        c,
		op:            op,
		typ:           TypeJobLayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobLayerID sets the ID field of the mutation.
func withJobLayerID(id int) joblayerOption {
	return func(m *JobLayerMutation) {
		var (
			err   error
			once  sync.Once
			value *JobLayer
		)
		m.oldValue = func(ctx context.Context) (*JobLayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobLayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobLayer sets the old JobLayer of the mutation.
func withJobLayer(node *JobLayer) joblayerOption {
	return func(m *JobLayerMutation) {
		m.oldValue = func(context.Context) (*JobLayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobLayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobLayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobLayerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobLayerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobLayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobLayerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobLayerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobLayerMutation) ResetName() {
	m._Name = nil
}

// SetMetre sets the "Metre" field.
func (m *JobLayerMutation) SetMetre(s string) {
	m._Metre = &s
}

// Metre returns the value of the "Metre" field in the mutation.
func (m *JobLayerMutation) Metre() (r string, exists bool) {
	v := m._Metre
	if v == nil {
		return
	}
	return *v, true
}

// OldMetre returns the old "Metre" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMetre(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetre is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetre requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetre: %w", err)
	}
	return oldValue.Metre, nil
}

// ResetMetre resets all changes to the "Metre" field.
func (m *JobLayerMutation) ResetMetre() {
	m._Metre = nil
}

// SetMoldDate sets the "MoldDate" field.
func (m *JobLayerMutation) SetMoldDate(t time.Time) {
	m._MoldDate = &t
}

// MoldDate returns the value of the "MoldDate" field in the mutation.
func (m *JobLayerMutation) MoldDate() (r time.Time, exists bool) {
	v := m._MoldDate
	if v == nil {
		return
	}
	return *v, true
}

// OldMoldDate returns the old "MoldDate" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMoldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoldDate: %w", err)
	}
	return oldValue.MoldDate, nil
}

// ClearMoldDate clears the value of the "MoldDate" field.
func (m *JobLayerMutation) ClearMoldDate() {
	m._MoldDate = nil
	m.clearedFields[joblayer.FieldMoldDate] = struct{}{}
}

// MoldDateCleared returns if the "MoldDate" field was cleared in this mutation.
func (m *JobLayerMutation) MoldDateCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldMoldDate]
	return ok
}

// ResetMoldDate resets all changes to the "MoldDate" field.
func (m *JobLayerMutation) ResetMoldDate() {
	m._MoldDate = nil
	delete(m.clearedFields, joblayer.FieldMoldDate)
}

// SetConcreteDate sets the "ConcreteDate" field.
func (m *JobLayerMutation) SetConcreteDate(t time.Time) {
	m._ConcreteDate = &t
}

// ConcreteDate returns the value of the "ConcreteDate" field in the mutation.
func (m *JobLayerMutation) ConcreteDate() (r time.Time, exists bool) {
	v := m._ConcreteDate
	if v == nil {
		return
	}
	return *v, true
}

// OldConcreteDate returns the old "ConcreteDate" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldConcreteDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcreteDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcreteDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcreteDate: %w", err)
	}
	return oldValue.ConcreteDate, nil
}

// ClearConcreteDate clears the value of the "ConcreteDate" field.
func (m *JobLayerMutation) ClearConcreteDate() {
	m._ConcreteDate = nil
	m.clearedFields[joblayer.FieldConcreteDate] = struct{}{}
}

// ConcreteDateCleared returns if the "ConcreteDate" field was cleared in this mutation.
func (m *JobLayerMutation) ConcreteDateCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldConcreteDate]
	return ok
}

// ResetConcreteDate resets all changes to the "ConcreteDate" field.
func (m *JobLayerMutation) ResetConcreteDate() {
	m._ConcreteDate = nil
	delete(m.clearedFields, joblayer.FieldConcreteDate)
}

// SetSamples sets the "Samples" field.
func (m *JobLayerMutation) SetSamples(i int) {
	m._Samples = &i
	m.add_Samples = nil
}

// Samples returns the value of the "Samples" field in the mutation.
func (m *JobLayerMutation) Samples() (r int, exists bool) {
	v := m._Samples
	if v == nil {
		return
	}
	return *v, true
}

// OldSamples returns the old "Samples" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldSamples(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSamples is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSamples requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSamples: %w", err)
	}
	return oldValue.Samples, nil
}

// AddSamples adds i to the "Samples" field.
func (m *JobLayerMutation) AddSamples(i int) {
	if m.add_Samples != nil {
		*m.add_Samples += i
	} else {
		m.add_Samples = &i
	}
}

// AddedSamples returns the value that was added to the "Samples" field in this mutation.
func (m *JobLayerMutation) AddedSamples() (r int, exists bool) {
	v := m.add_Samples
	if v == nil {
		return
	}
	return *v, true
}

// ClearSamples clears the value of the "Samples" field.
func (m *JobLayerMutation) ClearSamples() {
	m._Samples = nil
	m.add_Samples = nil
	m.clearedFields[joblayer.FieldSamples] = struct{}{}
}

// SamplesCleared returns if the "Samples" field was cleared in this mutation.
func (m *JobLayerMutation) SamplesCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldSamples]
	return ok
}

// ResetSamples resets all changes to the "Samples" field.
func (m *JobLayerMutation) ResetSamples() {
	m._Samples = nil
	m.add_Samples = nil
	delete(m.clearedFields, joblayer.FieldSamples)
}

// SetConcreteClass sets the "ConcreteClass" field.
func (m *JobLayerMutation) SetConcreteClass(s string) {
	m._ConcreteClass = &s
}

// ConcreteClass returns the value of the "ConcreteClass" field in the mutation.
func (m *JobLayerMutation) ConcreteClass() (r string, exists bool) {
	v := m._ConcreteClass
	if v == nil {
		return
	}
	return *v, true
}

// OldConcreteClass returns the old "ConcreteClass" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldConcreteClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcreteClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcreteClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcreteClass: %w", err)
	}
	return oldValue.ConcreteClass, nil
}

// ClearConcreteClass clears the value of the "ConcreteClass" field.
func (m *JobLayerMutation) ClearConcreteClass() {
	m._ConcreteClass = nil
	m.clearedFields[joblayer.FieldConcreteClass] = struct{}{}
}

// ConcreteClassCleared returns if the "ConcreteClass" field was cleared in this mutation.
func (m *JobLayerMutation) ConcreteClassCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldConcreteClass]
	return ok
}

// ResetConcreteClass resets all changes to the "ConcreteClass" field.
func (m *JobLayerMutation) ResetConcreteClass() {
	m._ConcreteClass = nil
	delete(m.clearedFields, joblayer.FieldConcreteClass)
}

// SetWeekResult sets the "WeekResult" field.
func (m *JobLayerMutation) SetWeekResult(s string) {
	m._WeekResult = &s
}

// WeekResult returns the value of the "WeekResult" field in the mutation.
func (m *JobLayerMutation) WeekResult() (r string, exists bool) {
	v := m._WeekResult
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekResult returns the old "WeekResult" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldWeekResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekResult: %w", err)
	}
	return oldValue.WeekResult, nil
}

// ClearWeekResult clears the value of the "WeekResult" field.
func (m *JobLayerMutation) ClearWeekResult() {
	m._WeekResult = nil
	m.clearedFields[joblayer.FieldWeekResult] = struct{}{}
}

// WeekResultCleared returns if the "WeekResult" field was cleared in this mutation.
func (m *JobLayerMutation) WeekResultCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldWeekResult]
	return ok
}

// ResetWeekResult resets all changes to the "WeekResult" field.
func (m *JobLayerMutation) ResetWeekResult() {
	m._WeekResult = nil
	delete(m.clearedFields, joblayer.FieldWeekResult)
}

// SetMonthResult sets the "MonthResult" field.
func (m *JobLayerMutation) SetMonthResult(s string) {
	m._MonthResult = &s
}

// MonthResult returns the value of the "MonthResult" field in the mutation.
func (m *JobLayerMutation) MonthResult() (r string, exists bool) {
	v := m._MonthResult
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthResult returns the old "MonthResult" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldMonthResult(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthResult: %w", err)
	}
	return oldValue.MonthResult, nil
}

// ClearMonthResult clears the value of the "MonthResult" field.
func (m *JobLayerMutation) ClearMonthResult() {
	m._MonthResult = nil
	m.clearedFields[joblayer.FieldMonthResult] = struct{}{}
}

// MonthResultCleared returns if the "MonthResult" field was cleared in this mutation.
func (m *JobLayerMutation) MonthResultCleared() bool {
	_, ok := m.clearedFields[joblayer.FieldMonthResult]
	return ok
}

// ResetMonthResult resets all changes to the "MonthResult" field.
func (m *JobLayerMutation) ResetMonthResult() {
	m._MonthResult = nil
	delete(m.clearedFields, joblayer.FieldMonthResult)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobLayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobLayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobLayerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobLayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobLayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobLayer entity.
// If the JobLayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobLayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobLayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLayerID sets the "layer" edge to the JobDetail entity by id.
func (m *JobLayerMutation) SetLayerID(id int) {
	m.layer = &id
}

// ClearLayer clears the "layer" edge to the JobDetail entity.
func (m *JobLayerMutation) ClearLayer() {
	m.clearedlayer = true
}

// LayerCleared reports if the "layer" edge to the JobDetail entity was cleared.
func (m *JobLayerMutation) LayerCleared() bool {
	return m.clearedlayer
}

// LayerID returns the "layer" edge ID in the mutation.
func (m *JobLayerMutation) LayerID() (id int, exists bool) {
	if m.layer != nil {
		return *m.layer, true
	}
	return
}

// LayerIDs returns the "layer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LayerID instead. It exists only for internal usage by the builders.
func (m *JobLayerMutation) LayerIDs() (ids []int) {
	if id := m.layer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLayer resets all changes to the "layer" edge.
func (m *JobLayerMutation) ResetLayer() {
	m.layer = nil
	m.clearedlayer = false
}

// Where appends a list predicates to the JobLayerMutation builder.
func (m *JobLayerMutation) Where(ps ...predicate.JobLayer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobLayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobLayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobLayer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobLayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobLayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobLayer).
func (m *JobLayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobLayerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._Name != nil {
		fields = append(fields, joblayer.FieldName)
	}
	if m._Metre != nil {
		fields = append(fields, joblayer.FieldMetre)
	}
	if m._MoldDate != nil {
		fields = append(fields, joblayer.FieldMoldDate)
	}
	if m._ConcreteDate != nil {
		fields = append(fields, joblayer.FieldConcreteDate)
	}
	if m._Samples != nil {
		fields = append(fields, joblayer.FieldSamples)
	}
	if m._ConcreteClass != nil {
		fields = append(fields, joblayer.FieldConcreteClass)
	}
	if m._WeekResult != nil {
		fields = append(fields, joblayer.FieldWeekResult)
	}
	if m._MonthResult != nil {
		fields = append(fields, joblayer.FieldMonthResult)
	}
	if m.created_at != nil {
		fields = append(fields, joblayer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, joblayer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobLayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case joblayer.FieldName:
		return m.Name()
	case joblayer.FieldMetre:
		return m.Metre()
	case joblayer.FieldMoldDate:
		return m.MoldDate()
	case joblayer.FieldConcreteDate:
		return m.ConcreteDate()
	case joblayer.FieldSamples:
		return m.Samples()
	case joblayer.FieldConcreteClass:
		return m.ConcreteClass()
	case joblayer.FieldWeekResult:
		return m.WeekResult()
	case joblayer.FieldMonthResult:
		return m.MonthResult()
	case joblayer.FieldCreatedAt:
		return m.CreatedAt()
	case joblayer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobLayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case joblayer.FieldName:
		return m.OldName(ctx)
	case joblayer.FieldMetre:
		return m.OldMetre(ctx)
	case joblayer.FieldMoldDate:
		return m.OldMoldDate(ctx)
	case joblayer.FieldConcreteDate:
		return m.OldConcreteDate(ctx)
	case joblayer.FieldSamples:
		return m.OldSamples(ctx)
	case joblayer.FieldConcreteClass:
		return m.OldConcreteClass(ctx)
	case joblayer.FieldWeekResult:
		return m.OldWeekResult(ctx)
	case joblayer.FieldMonthResult:
		return m.OldMonthResult(ctx)
	case joblayer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case joblayer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobLayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case joblayer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case joblayer.FieldMetre:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetre(v)
		return nil
	case joblayer.FieldMoldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoldDate(v)
		return nil
	case joblayer.FieldConcreteDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcreteDate(v)
		return nil
	case joblayer.FieldSamples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSamples(v)
		return nil
	case joblayer.FieldConcreteClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcreteClass(v)
		return nil
	case joblayer.FieldWeekResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekResult(v)
		return nil
	case joblayer.FieldMonthResult:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthResult(v)
		return nil
	case joblayer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case joblayer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobLayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobLayerMutation) AddedFields() []string {
	var fields []string
	if m.add_Samples != nil {
		fields = append(fields, joblayer.FieldSamples)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobLayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case joblayer.FieldSamples:
		return m.AddedSamples()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobLayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case joblayer.FieldSamples:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSamples(v)
		return nil
	}
	return fmt.Errorf("unknown JobLayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobLayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(joblayer.FieldMoldDate) {
		fields = append(fields, joblayer.FieldMoldDate)
	}
	if m.FieldCleared(joblayer.FieldConcreteDate) {
		fields = append(fields, joblayer.FieldConcreteDate)
	}
	if m.FieldCleared(joblayer.FieldSamples) {
		fields = append(fields, joblayer.FieldSamples)
	}
	if m.FieldCleared(joblayer.FieldConcreteClass) {
		fields = append(fields, joblayer.FieldConcreteClass)
	}
	if m.FieldCleared(joblayer.FieldWeekResult) {
		fields = append(fields, joblayer.FieldWeekResult)
	}
	if m.FieldCleared(joblayer.FieldMonthResult) {
		fields = append(fields, joblayer.FieldMonthResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobLayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobLayerMutation) ClearField(name string) error {
	switch name {
	case joblayer.FieldMoldDate:
		m.ClearMoldDate()
		return nil
	case joblayer.FieldConcreteDate:
		m.ClearConcreteDate()
		return nil
	case joblayer.FieldSamples:
		m.ClearSamples()
		return nil
	case joblayer.FieldConcreteClass:
		m.ClearConcreteClass()
		return nil
	case joblayer.FieldWeekResult:
		m.ClearWeekResult()
		return nil
	case joblayer.FieldMonthResult:
		m.ClearMonthResult()
		return nil
	}
	return fmt.Errorf("unknown JobLayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobLayerMutation) ResetField(name string) error {
	switch name {
	case joblayer.FieldName:
		m.ResetName()
		return nil
	case joblayer.FieldMetre:
		m.ResetMetre()
		return nil
	case joblayer.FieldMoldDate:
		m.ResetMoldDate()
		return nil
	case joblayer.FieldConcreteDate:
		m.ResetConcreteDate()
		return nil
	case joblayer.FieldSamples:
		m.ResetSamples()
		return nil
	case joblayer.FieldConcreteClass:
		m.ResetConcreteClass()
		return nil
	case joblayer.FieldWeekResult:
		m.ResetWeekResult()
		return nil
	case joblayer.FieldMonthResult:
		m.ResetMonthResult()
		return nil
	case joblayer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case joblayer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobLayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobLayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.layer != nil {
		edges = append(edges, joblayer.EdgeLayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobLayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case joblayer.EdgeLayer:
		if id := m.layer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobLayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobLayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobLayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlayer {
		edges = append(edges, joblayer.EdgeLayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobLayerMutation) EdgeCleared(name string) bool {
	switch name {
	case joblayer.EdgeLayer:
		return m.clearedlayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobLayerMutation) ClearEdge(name string) error {
	switch name {
	case joblayer.EdgeLayer:
		m.ClearLayer()
		return nil
	}
	return fmt.Errorf("unknown JobLayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobLayerMutation) ResetEdge(name string) error {
	switch name {
	case joblayer.EdgeLayer:
		m.ResetLayer()
		return nil
	}
	return fmt.Errorf("unknown JobLayer edge %s", name)
}

// JobOwnerMutation represents an operation that mutates the JobOwner nodes in the graph.
type JobOwnerMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Name         *string
	_TcNo         *int
	add_TcNo      *int
	_Address      *string
	_TaxAdmin     *string
	_TaxNo        *int
	add_TaxNo     *int
	_Phone        *string
	_Email        *string
	_Note         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	owners        map[int]struct{}
	removedowners map[int]struct{}
	clearedowners bool
	done          bool
	oldValue      func(context.Context) (*JobOwner, error)
	predicates    []predicate.JobOwner
}

var _ ent.Mutation = (*JobOwnerMutation)(nil)

// jobownerOption allows management of the mutation configuration using functional options.
type jobownerOption func(*JobOwnerMutation)

// newJobOwnerMutation creates new mutation for the JobOwner entity.
func newJobOwnerMutation(c config, op Op, opts ...jobownerOption) *JobOwnerMutation {
	m := &JobOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeJobOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobOwnerID sets the ID field of the mutation.
func withJobOwnerID(id int) jobownerOption {
	return func(m *JobOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *JobOwner
		)
		m.oldValue = func(ctx context.Context) (*JobOwner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobOwner sets the old JobOwner of the mutation.
func withJobOwner(node *JobOwner) jobownerOption {
	return func(m *JobOwnerMutation) {
		m.oldValue = func(context.Context) (*JobOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobOwnerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobOwnerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobOwner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "Name" field.
func (m *JobOwnerMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *JobOwnerMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *JobOwnerMutation) ResetName() {
	m._Name = nil
}

// SetTcNo sets the "TcNo" field.
func (m *JobOwnerMutation) SetTcNo(i int) {
	m._TcNo = &i
	m.add_TcNo = nil
}

// TcNo returns the value of the "TcNo" field in the mutation.
func (m *JobOwnerMutation) TcNo() (r int, exists bool) {
	v := m._TcNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTcNo returns the old "TcNo" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTcNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTcNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTcNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTcNo: %w", err)
	}
	return oldValue.TcNo, nil
}

// AddTcNo adds i to the "TcNo" field.
func (m *JobOwnerMutation) AddTcNo(i int) {
	if m.add_TcNo != nil {
		*m.add_TcNo += i
	} else {
		m.add_TcNo = &i
	}
}

// AddedTcNo returns the value that was added to the "TcNo" field in this mutation.
func (m *JobOwnerMutation) AddedTcNo() (r int, exists bool) {
	v := m.add_TcNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTcNo clears the value of the "TcNo" field.
func (m *JobOwnerMutation) ClearTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	m.clearedFields[jobowner.FieldTcNo] = struct{}{}
}

// TcNoCleared returns if the "TcNo" field was cleared in this mutation.
func (m *JobOwnerMutation) TcNoCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTcNo]
	return ok
}

// ResetTcNo resets all changes to the "TcNo" field.
func (m *JobOwnerMutation) ResetTcNo() {
	m._TcNo = nil
	m.add_TcNo = nil
	delete(m.clearedFields, jobowner.FieldTcNo)
}

// SetAddress sets the "Address" field.
func (m *JobOwnerMutation) SetAddress(s string) {
	m._Address = &s
}

// Address returns the value of the "Address" field in the mutation.
func (m *JobOwnerMutation) Address() (r string, exists bool) {
	v := m._Address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "Address" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "Address" field.
func (m *JobOwnerMutation) ClearAddress() {
	m._Address = nil
	m.clearedFields[jobowner.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "Address" field was cleared in this mutation.
func (m *JobOwnerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "Address" field.
func (m *JobOwnerMutation) ResetAddress() {
	m._Address = nil
	delete(m.clearedFields, jobowner.FieldAddress)
}

// SetTaxAdmin sets the "TaxAdmin" field.
func (m *JobOwnerMutation) SetTaxAdmin(s string) {
	m._TaxAdmin = &s
}

// TaxAdmin returns the value of the "TaxAdmin" field in the mutation.
func (m *JobOwnerMutation) TaxAdmin() (r string, exists bool) {
	v := m._TaxAdmin
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxAdmin returns the old "TaxAdmin" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTaxAdmin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxAdmin: %w", err)
	}
	return oldValue.TaxAdmin, nil
}

// ClearTaxAdmin clears the value of the "TaxAdmin" field.
func (m *JobOwnerMutation) ClearTaxAdmin() {
	m._TaxAdmin = nil
	m.clearedFields[jobowner.FieldTaxAdmin] = struct{}{}
}

// TaxAdminCleared returns if the "TaxAdmin" field was cleared in this mutation.
func (m *JobOwnerMutation) TaxAdminCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTaxAdmin]
	return ok
}

// ResetTaxAdmin resets all changes to the "TaxAdmin" field.
func (m *JobOwnerMutation) ResetTaxAdmin() {
	m._TaxAdmin = nil
	delete(m.clearedFields, jobowner.FieldTaxAdmin)
}

// SetTaxNo sets the "TaxNo" field.
func (m *JobOwnerMutation) SetTaxNo(i int) {
	m._TaxNo = &i
	m.add_TaxNo = nil
}

// TaxNo returns the value of the "TaxNo" field in the mutation.
func (m *JobOwnerMutation) TaxNo() (r int, exists bool) {
	v := m._TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxNo returns the old "TaxNo" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldTaxNo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxNo: %w", err)
	}
	return oldValue.TaxNo, nil
}

// AddTaxNo adds i to the "TaxNo" field.
func (m *JobOwnerMutation) AddTaxNo(i int) {
	if m.add_TaxNo != nil {
		*m.add_TaxNo += i
	} else {
		m.add_TaxNo = &i
	}
}

// AddedTaxNo returns the value that was added to the "TaxNo" field in this mutation.
func (m *JobOwnerMutation) AddedTaxNo() (r int, exists bool) {
	v := m.add_TaxNo
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaxNo clears the value of the "TaxNo" field.
func (m *JobOwnerMutation) ClearTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	m.clearedFields[jobowner.FieldTaxNo] = struct{}{}
}

// TaxNoCleared returns if the "TaxNo" field was cleared in this mutation.
func (m *JobOwnerMutation) TaxNoCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldTaxNo]
	return ok
}

// ResetTaxNo resets all changes to the "TaxNo" field.
func (m *JobOwnerMutation) ResetTaxNo() {
	m._TaxNo = nil
	m.add_TaxNo = nil
	delete(m.clearedFields, jobowner.FieldTaxNo)
}

// SetPhone sets the "Phone" field.
func (m *JobOwnerMutation) SetPhone(s string) {
	m._Phone = &s
}

// Phone returns the value of the "Phone" field in the mutation.
func (m *JobOwnerMutation) Phone() (r string, exists bool) {
	v := m._Phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "Phone" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "Phone" field.
func (m *JobOwnerMutation) ClearPhone() {
	m._Phone = nil
	m.clearedFields[jobowner.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "Phone" field was cleared in this mutation.
func (m *JobOwnerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "Phone" field.
func (m *JobOwnerMutation) ResetPhone() {
	m._Phone = nil
	delete(m.clearedFields, jobowner.FieldPhone)
}

// SetEmail sets the "Email" field.
func (m *JobOwnerMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *JobOwnerMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *JobOwnerMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[jobowner.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *JobOwnerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *JobOwnerMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, jobowner.FieldEmail)
}

// SetNote sets the "Note" field.
func (m *JobOwnerMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobOwnerMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobOwnerMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobowner.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobOwnerMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobowner.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobOwnerMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobowner.FieldNote)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobOwnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobOwnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobOwnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobOwnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobOwnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobOwner entity.
// If the JobOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobOwnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobOwnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddOwnerIDs adds the "owners" edge to the JobDetail entity by ids.
func (m *JobOwnerMutation) AddOwnerIDs(ids ...int) {
	if m.owners == nil {
		m.owners = make(map[int]struct{})
	}
	for i := range ids {
		m.owners[ids[i]] = struct{}{}
	}
}

// ClearOwners clears the "owners" edge to the JobDetail entity.
func (m *JobOwnerMutation) ClearOwners() {
	m.clearedowners = true
}

// OwnersCleared reports if the "owners" edge to the JobDetail entity was cleared.
func (m *JobOwnerMutation) OwnersCleared() bool {
	return m.clearedowners
}

// RemoveOwnerIDs removes the "owners" edge to the JobDetail entity by IDs.
func (m *JobOwnerMutation) RemoveOwnerIDs(ids ...int) {
	if m.removedowners == nil {
		m.removedowners = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.owners, ids[i])
		m.removedowners[ids[i]] = struct{}{}
	}
}

// RemovedOwners returns the removed IDs of the "owners" edge to the JobDetail entity.
func (m *JobOwnerMutation) RemovedOwnersIDs() (ids []int) {
	for id := range m.removedowners {
		ids = append(ids, id)
	}
	return
}

// OwnersIDs returns the "owners" edge IDs in the mutation.
func (m *JobOwnerMutation) OwnersIDs() (ids []int) {
	for id := range m.owners {
		ids = append(ids, id)
	}
	return
}

// ResetOwners resets all changes to the "owners" edge.
func (m *JobOwnerMutation) ResetOwners() {
	m.owners = nil
	m.clearedowners = false
	m.removedowners = nil
}

// Where appends a list predicates to the JobOwnerMutation builder.
func (m *JobOwnerMutation) Where(ps ...predicate.JobOwner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobOwnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobOwnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobOwner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobOwnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobOwnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobOwner).
func (m *JobOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobOwnerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._Name != nil {
		fields = append(fields, jobowner.FieldName)
	}
	if m._TcNo != nil {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m._Address != nil {
		fields = append(fields, jobowner.FieldAddress)
	}
	if m._TaxAdmin != nil {
		fields = append(fields, jobowner.FieldTaxAdmin)
	}
	if m._TaxNo != nil {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	if m._Phone != nil {
		fields = append(fields, jobowner.FieldPhone)
	}
	if m._Email != nil {
		fields = append(fields, jobowner.FieldEmail)
	}
	if m._Note != nil {
		fields = append(fields, jobowner.FieldNote)
	}
	if m.created_at != nil {
		fields = append(fields, jobowner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobowner.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobowner.FieldName:
		return m.Name()
	case jobowner.FieldTcNo:
		return m.TcNo()
	case jobowner.FieldAddress:
		return m.Address()
	case jobowner.FieldTaxAdmin:
		return m.TaxAdmin()
	case jobowner.FieldTaxNo:
		return m.TaxNo()
	case jobowner.FieldPhone:
		return m.Phone()
	case jobowner.FieldEmail:
		return m.Email()
	case jobowner.FieldNote:
		return m.Note()
	case jobowner.FieldCreatedAt:
		return m.CreatedAt()
	case jobowner.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobowner.FieldName:
		return m.OldName(ctx)
	case jobowner.FieldTcNo:
		return m.OldTcNo(ctx)
	case jobowner.FieldAddress:
		return m.OldAddress(ctx)
	case jobowner.FieldTaxAdmin:
		return m.OldTaxAdmin(ctx)
	case jobowner.FieldTaxNo:
		return m.OldTaxNo(ctx)
	case jobowner.FieldPhone:
		return m.OldPhone(ctx)
	case jobowner.FieldEmail:
		return m.OldEmail(ctx)
	case jobowner.FieldNote:
		return m.OldNote(ctx)
	case jobowner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobowner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobOwner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobowner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case jobowner.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTcNo(v)
		return nil
	case jobowner.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case jobowner.FieldTaxAdmin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxAdmin(v)
		return nil
	case jobowner.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxNo(v)
		return nil
	case jobowner.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case jobowner.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case jobowner.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case jobowner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobowner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobOwnerMutation) AddedFields() []string {
	var fields []string
	if m.add_TcNo != nil {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m.add_TaxNo != nil {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobOwnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobowner.FieldTcNo:
		return m.AddedTcNo()
	case jobowner.FieldTaxNo:
		return m.AddedTaxNo()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobowner.FieldTcNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTcNo(v)
		return nil
	case jobowner.FieldTaxNo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaxNo(v)
		return nil
	}
	return fmt.Errorf("unknown JobOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobOwnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobowner.FieldTcNo) {
		fields = append(fields, jobowner.FieldTcNo)
	}
	if m.FieldCleared(jobowner.FieldAddress) {
		fields = append(fields, jobowner.FieldAddress)
	}
	if m.FieldCleared(jobowner.FieldTaxAdmin) {
		fields = append(fields, jobowner.FieldTaxAdmin)
	}
	if m.FieldCleared(jobowner.FieldTaxNo) {
		fields = append(fields, jobowner.FieldTaxNo)
	}
	if m.FieldCleared(jobowner.FieldPhone) {
		fields = append(fields, jobowner.FieldPhone)
	}
	if m.FieldCleared(jobowner.FieldEmail) {
		fields = append(fields, jobowner.FieldEmail)
	}
	if m.FieldCleared(jobowner.FieldNote) {
		fields = append(fields, jobowner.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobOwnerMutation) ClearField(name string) error {
	switch name {
	case jobowner.FieldTcNo:
		m.ClearTcNo()
		return nil
	case jobowner.FieldAddress:
		m.ClearAddress()
		return nil
	case jobowner.FieldTaxAdmin:
		m.ClearTaxAdmin()
		return nil
	case jobowner.FieldTaxNo:
		m.ClearTaxNo()
		return nil
	case jobowner.FieldPhone:
		m.ClearPhone()
		return nil
	case jobowner.FieldEmail:
		m.ClearEmail()
		return nil
	case jobowner.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobOwnerMutation) ResetField(name string) error {
	switch name {
	case jobowner.FieldName:
		m.ResetName()
		return nil
	case jobowner.FieldTcNo:
		m.ResetTcNo()
		return nil
	case jobowner.FieldAddress:
		m.ResetAddress()
		return nil
	case jobowner.FieldTaxAdmin:
		m.ResetTaxAdmin()
		return nil
	case jobowner.FieldTaxNo:
		m.ResetTaxNo()
		return nil
	case jobowner.FieldPhone:
		m.ResetPhone()
		return nil
	case jobowner.FieldEmail:
		m.ResetEmail()
		return nil
	case jobowner.FieldNote:
		m.ResetNote()
		return nil
	case jobowner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobowner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owners != nil {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobOwnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobowner.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.owners))
		for id := range m.owners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedowners != nil {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobOwnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobowner.EdgeOwners:
		ids := make([]ent.Value, 0, len(m.removedowners))
		for id := range m.removedowners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowners {
		edges = append(edges, jobowner.EdgeOwners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobOwnerMutation) EdgeCleared(name string) bool {
	switch name {
	case jobowner.EdgeOwners:
		return m.clearedowners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobOwnerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobOwner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobOwnerMutation) ResetEdge(name string) error {
	switch name {
	case jobowner.EdgeOwners:
		m.ResetOwners()
		return nil
	}
	return fmt.Errorf("unknown JobOwner edge %s", name)
}

// JobProgressMutation represents an operation that mutates the JobProgress nodes in the graph.
type JobProgressMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_One            *int
	add_One         *int
	_Two            *int
	add_Two         *int
	_Three          *int
	add_Three       *int
	_Four           *int
	add_Four        *int
	_Five           *int
	add_Five        *int
	_Six            *int
	add_Six         *int
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	progress        map[int]struct{}
	removedprogress map[int]struct{}
	clearedprogress bool
	done            bool
	oldValue        func(context.Context) (*JobProgress, error)
	predicates      []predicate.JobProgress
}

var _ ent.Mutation = (*JobProgressMutation)(nil)

// jobprogressOption allows management of the mutation configuration using functional options.
type jobprogressOption func(*JobProgressMutation)

// newJobProgressMutation creates new mutation for the JobProgress entity.
func newJobProgressMutation(c config, op Op, opts ...jobprogressOption) *JobProgressMutation {
	m := &JobProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeJobProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobProgressID sets the ID field of the mutation.
func withJobProgressID(id int) jobprogressOption {
	return func(m *JobProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *JobProgress
		)
		m.oldValue = func(ctx context.Context) (*JobProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobProgress sets the old JobProgress of the mutation.
func withJobProgress(node *JobProgress) jobprogressOption {
	return func(m *JobProgressMutation) {
		m.oldValue = func(context.Context) (*JobProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobProgressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobProgressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOne sets the "One" field.
func (m *JobProgressMutation) SetOne(i int) {
	m._One = &i
	m.add_One = nil
}

// One returns the value of the "One" field in the mutation.
func (m *JobProgressMutation) One() (r int, exists bool) {
	v := m._One
	if v == nil {
		return
	}
	return *v, true
}

// OldOne returns the old "One" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldOne(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOne: %w", err)
	}
	return oldValue.One, nil
}

// AddOne adds i to the "One" field.
func (m *JobProgressMutation) AddOne(i int) {
	if m.add_One != nil {
		*m.add_One += i
	} else {
		m.add_One = &i
	}
}

// AddedOne returns the value that was added to the "One" field in this mutation.
func (m *JobProgressMutation) AddedOne() (r int, exists bool) {
	v := m.add_One
	if v == nil {
		return
	}
	return *v, true
}

// ClearOne clears the value of the "One" field.
func (m *JobProgressMutation) ClearOne() {
	m._One = nil
	m.add_One = nil
	m.clearedFields[jobprogress.FieldOne] = struct{}{}
}

// OneCleared returns if the "One" field was cleared in this mutation.
func (m *JobProgressMutation) OneCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldOne]
	return ok
}

// ResetOne resets all changes to the "One" field.
func (m *JobProgressMutation) ResetOne() {
	m._One = nil
	m.add_One = nil
	delete(m.clearedFields, jobprogress.FieldOne)
}

// SetTwo sets the "Two" field.
func (m *JobProgressMutation) SetTwo(i int) {
	m._Two = &i
	m.add_Two = nil
}

// Two returns the value of the "Two" field in the mutation.
func (m *JobProgressMutation) Two() (r int, exists bool) {
	v := m._Two
	if v == nil {
		return
	}
	return *v, true
}

// OldTwo returns the old "Two" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldTwo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwo: %w", err)
	}
	return oldValue.Two, nil
}

// AddTwo adds i to the "Two" field.
func (m *JobProgressMutation) AddTwo(i int) {
	if m.add_Two != nil {
		*m.add_Two += i
	} else {
		m.add_Two = &i
	}
}

// AddedTwo returns the value that was added to the "Two" field in this mutation.
func (m *JobProgressMutation) AddedTwo() (r int, exists bool) {
	v := m.add_Two
	if v == nil {
		return
	}
	return *v, true
}

// ClearTwo clears the value of the "Two" field.
func (m *JobProgressMutation) ClearTwo() {
	m._Two = nil
	m.add_Two = nil
	m.clearedFields[jobprogress.FieldTwo] = struct{}{}
}

// TwoCleared returns if the "Two" field was cleared in this mutation.
func (m *JobProgressMutation) TwoCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldTwo]
	return ok
}

// ResetTwo resets all changes to the "Two" field.
func (m *JobProgressMutation) ResetTwo() {
	m._Two = nil
	m.add_Two = nil
	delete(m.clearedFields, jobprogress.FieldTwo)
}

// SetThree sets the "Three" field.
func (m *JobProgressMutation) SetThree(i int) {
	m._Three = &i
	m.add_Three = nil
}

// Three returns the value of the "Three" field in the mutation.
func (m *JobProgressMutation) Three() (r int, exists bool) {
	v := m._Three
	if v == nil {
		return
	}
	return *v, true
}

// OldThree returns the old "Three" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldThree(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThree: %w", err)
	}
	return oldValue.Three, nil
}

// AddThree adds i to the "Three" field.
func (m *JobProgressMutation) AddThree(i int) {
	if m.add_Three != nil {
		*m.add_Three += i
	} else {
		m.add_Three = &i
	}
}

// AddedThree returns the value that was added to the "Three" field in this mutation.
func (m *JobProgressMutation) AddedThree() (r int, exists bool) {
	v := m.add_Three
	if v == nil {
		return
	}
	return *v, true
}

// ClearThree clears the value of the "Three" field.
func (m *JobProgressMutation) ClearThree() {
	m._Three = nil
	m.add_Three = nil
	m.clearedFields[jobprogress.FieldThree] = struct{}{}
}

// ThreeCleared returns if the "Three" field was cleared in this mutation.
func (m *JobProgressMutation) ThreeCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldThree]
	return ok
}

// ResetThree resets all changes to the "Three" field.
func (m *JobProgressMutation) ResetThree() {
	m._Three = nil
	m.add_Three = nil
	delete(m.clearedFields, jobprogress.FieldThree)
}

// SetFour sets the "Four" field.
func (m *JobProgressMutation) SetFour(i int) {
	m._Four = &i
	m.add_Four = nil
}

// Four returns the value of the "Four" field in the mutation.
func (m *JobProgressMutation) Four() (r int, exists bool) {
	v := m._Four
	if v == nil {
		return
	}
	return *v, true
}

// OldFour returns the old "Four" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldFour(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFour: %w", err)
	}
	return oldValue.Four, nil
}

// AddFour adds i to the "Four" field.
func (m *JobProgressMutation) AddFour(i int) {
	if m.add_Four != nil {
		*m.add_Four += i
	} else {
		m.add_Four = &i
	}
}

// AddedFour returns the value that was added to the "Four" field in this mutation.
func (m *JobProgressMutation) AddedFour() (r int, exists bool) {
	v := m.add_Four
	if v == nil {
		return
	}
	return *v, true
}

// ClearFour clears the value of the "Four" field.
func (m *JobProgressMutation) ClearFour() {
	m._Four = nil
	m.add_Four = nil
	m.clearedFields[jobprogress.FieldFour] = struct{}{}
}

// FourCleared returns if the "Four" field was cleared in this mutation.
func (m *JobProgressMutation) FourCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldFour]
	return ok
}

// ResetFour resets all changes to the "Four" field.
func (m *JobProgressMutation) ResetFour() {
	m._Four = nil
	m.add_Four = nil
	delete(m.clearedFields, jobprogress.FieldFour)
}

// SetFive sets the "Five" field.
func (m *JobProgressMutation) SetFive(i int) {
	m._Five = &i
	m.add_Five = nil
}

// Five returns the value of the "Five" field in the mutation.
func (m *JobProgressMutation) Five() (r int, exists bool) {
	v := m._Five
	if v == nil {
		return
	}
	return *v, true
}

// OldFive returns the old "Five" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldFive(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFive: %w", err)
	}
	return oldValue.Five, nil
}

// AddFive adds i to the "Five" field.
func (m *JobProgressMutation) AddFive(i int) {
	if m.add_Five != nil {
		*m.add_Five += i
	} else {
		m.add_Five = &i
	}
}

// AddedFive returns the value that was added to the "Five" field in this mutation.
func (m *JobProgressMutation) AddedFive() (r int, exists bool) {
	v := m.add_Five
	if v == nil {
		return
	}
	return *v, true
}

// ClearFive clears the value of the "Five" field.
func (m *JobProgressMutation) ClearFive() {
	m._Five = nil
	m.add_Five = nil
	m.clearedFields[jobprogress.FieldFive] = struct{}{}
}

// FiveCleared returns if the "Five" field was cleared in this mutation.
func (m *JobProgressMutation) FiveCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldFive]
	return ok
}

// ResetFive resets all changes to the "Five" field.
func (m *JobProgressMutation) ResetFive() {
	m._Five = nil
	m.add_Five = nil
	delete(m.clearedFields, jobprogress.FieldFive)
}

// SetSix sets the "Six" field.
func (m *JobProgressMutation) SetSix(i int) {
	m._Six = &i
	m.add_Six = nil
}

// Six returns the value of the "Six" field in the mutation.
func (m *JobProgressMutation) Six() (r int, exists bool) {
	v := m._Six
	if v == nil {
		return
	}
	return *v, true
}

// OldSix returns the old "Six" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldSix(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSix: %w", err)
	}
	return oldValue.Six, nil
}

// AddSix adds i to the "Six" field.
func (m *JobProgressMutation) AddSix(i int) {
	if m.add_Six != nil {
		*m.add_Six += i
	} else {
		m.add_Six = &i
	}
}

// AddedSix returns the value that was added to the "Six" field in this mutation.
func (m *JobProgressMutation) AddedSix() (r int, exists bool) {
	v := m.add_Six
	if v == nil {
		return
	}
	return *v, true
}

// ClearSix clears the value of the "Six" field.
func (m *JobProgressMutation) ClearSix() {
	m._Six = nil
	m.add_Six = nil
	m.clearedFields[jobprogress.FieldSix] = struct{}{}
}

// SixCleared returns if the "Six" field was cleared in this mutation.
func (m *JobProgressMutation) SixCleared() bool {
	_, ok := m.clearedFields[jobprogress.FieldSix]
	return ok
}

// ResetSix resets all changes to the "Six" field.
func (m *JobProgressMutation) ResetSix() {
	m._Six = nil
	m.add_Six = nil
	delete(m.clearedFields, jobprogress.FieldSix)
}

// SetCreatedAt sets the "created_at" field.
func (m *JobProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobProgressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobProgress entity.
// If the JobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobProgressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddProgresIDs adds the "progress" edge to the JobDetail entity by ids.
func (m *JobProgressMutation) AddProgresIDs(ids ...int) {
	if m.progress == nil {
		m.progress = make(map[int]struct{})
	}
	for i := range ids {
		m.progress[ids[i]] = struct{}{}
	}
}

// ClearProgress clears the "progress" edge to the JobDetail entity.
func (m *JobProgressMutation) ClearProgress() {
	m.clearedprogress = true
}

// ProgressCleared reports if the "progress" edge to the JobDetail entity was cleared.
func (m *JobProgressMutation) ProgressCleared() bool {
	return m.clearedprogress
}

// RemoveProgresIDs removes the "progress" edge to the JobDetail entity by IDs.
func (m *JobProgressMutation) RemoveProgresIDs(ids ...int) {
	if m.removedprogress == nil {
		m.removedprogress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.progress, ids[i])
		m.removedprogress[ids[i]] = struct{}{}
	}
}

// RemovedProgress returns the removed IDs of the "progress" edge to the JobDetail entity.
func (m *JobProgressMutation) RemovedProgressIDs() (ids []int) {
	for id := range m.removedprogress {
		ids = append(ids, id)
	}
	return
}

// ProgressIDs returns the "progress" edge IDs in the mutation.
func (m *JobProgressMutation) ProgressIDs() (ids []int) {
	for id := range m.progress {
		ids = append(ids, id)
	}
	return
}

// ResetProgress resets all changes to the "progress" edge.
func (m *JobProgressMutation) ResetProgress() {
	m.progress = nil
	m.clearedprogress = false
	m.removedprogress = nil
}

// Where appends a list predicates to the JobProgressMutation builder.
func (m *JobProgressMutation) Where(ps ...predicate.JobProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobProgress).
func (m *JobProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobProgressMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._One != nil {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m._Two != nil {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m._Three != nil {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m._Four != nil {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m._Five != nil {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m._Six != nil {
		fields = append(fields, jobprogress.FieldSix)
	}
	if m.created_at != nil {
		fields = append(fields, jobprogress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobprogress.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobprogress.FieldOne:
		return m.One()
	case jobprogress.FieldTwo:
		return m.Two()
	case jobprogress.FieldThree:
		return m.Three()
	case jobprogress.FieldFour:
		return m.Four()
	case jobprogress.FieldFive:
		return m.Five()
	case jobprogress.FieldSix:
		return m.Six()
	case jobprogress.FieldCreatedAt:
		return m.CreatedAt()
	case jobprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobprogress.FieldOne:
		return m.OldOne(ctx)
	case jobprogress.FieldTwo:
		return m.OldTwo(ctx)
	case jobprogress.FieldThree:
		return m.OldThree(ctx)
	case jobprogress.FieldFour:
		return m.OldFour(ctx)
	case jobprogress.FieldFive:
		return m.OldFive(ctx)
	case jobprogress.FieldSix:
		return m.OldSix(ctx)
	case jobprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown JobProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobprogress.FieldOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOne(v)
		return nil
	case jobprogress.FieldTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwo(v)
		return nil
	case jobprogress.FieldThree:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThree(v)
		return nil
	case jobprogress.FieldFour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFour(v)
		return nil
	case jobprogress.FieldFive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFive(v)
		return nil
	case jobprogress.FieldSix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSix(v)
		return nil
	case jobprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown JobProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobProgressMutation) AddedFields() []string {
	var fields []string
	if m.add_One != nil {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m.add_Two != nil {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m.add_Three != nil {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m.add_Four != nil {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m.add_Five != nil {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m.add_Six != nil {
		fields = append(fields, jobprogress.FieldSix)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case jobprogress.FieldOne:
		return m.AddedOne()
	case jobprogress.FieldTwo:
		return m.AddedTwo()
	case jobprogress.FieldThree:
		return m.AddedThree()
	case jobprogress.FieldFour:
		return m.AddedFour()
	case jobprogress.FieldFive:
		return m.AddedFive()
	case jobprogress.FieldSix:
		return m.AddedSix()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case jobprogress.FieldOne:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOne(v)
		return nil
	case jobprogress.FieldTwo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTwo(v)
		return nil
	case jobprogress.FieldThree:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThree(v)
		return nil
	case jobprogress.FieldFour:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFour(v)
		return nil
	case jobprogress.FieldFive:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFive(v)
		return nil
	case jobprogress.FieldSix:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSix(v)
		return nil
	}
	return fmt.Errorf("unknown JobProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobprogress.FieldOne) {
		fields = append(fields, jobprogress.FieldOne)
	}
	if m.FieldCleared(jobprogress.FieldTwo) {
		fields = append(fields, jobprogress.FieldTwo)
	}
	if m.FieldCleared(jobprogress.FieldThree) {
		fields = append(fields, jobprogress.FieldThree)
	}
	if m.FieldCleared(jobprogress.FieldFour) {
		fields = append(fields, jobprogress.FieldFour)
	}
	if m.FieldCleared(jobprogress.FieldFive) {
		fields = append(fields, jobprogress.FieldFive)
	}
	if m.FieldCleared(jobprogress.FieldSix) {
		fields = append(fields, jobprogress.FieldSix)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobProgressMutation) ClearField(name string) error {
	switch name {
	case jobprogress.FieldOne:
		m.ClearOne()
		return nil
	case jobprogress.FieldTwo:
		m.ClearTwo()
		return nil
	case jobprogress.FieldThree:
		m.ClearThree()
		return nil
	case jobprogress.FieldFour:
		m.ClearFour()
		return nil
	case jobprogress.FieldFive:
		m.ClearFive()
		return nil
	case jobprogress.FieldSix:
		m.ClearSix()
		return nil
	}
	return fmt.Errorf("unknown JobProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobProgressMutation) ResetField(name string) error {
	switch name {
	case jobprogress.FieldOne:
		m.ResetOne()
		return nil
	case jobprogress.FieldTwo:
		m.ResetTwo()
		return nil
	case jobprogress.FieldThree:
		m.ResetThree()
		return nil
	case jobprogress.FieldFour:
		m.ResetFour()
		return nil
	case jobprogress.FieldFive:
		m.ResetFive()
		return nil
	case jobprogress.FieldSix:
		m.ResetSix()
		return nil
	case jobprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown JobProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.progress != nil {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobprogress.EdgeProgress:
		ids := make([]ent.Value, 0, len(m.progress))
		for id := range m.progress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprogress != nil {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobProgressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case jobprogress.EdgeProgress:
		ids := make([]ent.Value, 0, len(m.removedprogress))
		for id := range m.removedprogress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprogress {
		edges = append(edges, jobprogress.EdgeProgress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case jobprogress.EdgeProgress:
		return m.clearedprogress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobProgressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown JobProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobProgressMutation) ResetEdge(name string) error {
	switch name {
	case jobprogress.EdgeProgress:
		m.ResetProgress()
		return nil
	}
	return fmt.Errorf("unknown JobProgress edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	name          *string
	email         *string
	phone         *int
	addphone      *int
	password      *string
	_Role         *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(i int) {
	m.phone = &i
	m.addphone = nil
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r int, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// AddPhone adds i to the "phone" field.
func (m *UserMutation) AddPhone(i int) {
	if m.addphone != nil {
		*m.addphone += i
	} else {
		m.addphone = &i
	}
}

// AddedPhone returns the value that was added to the "phone" field in this mutation.
func (m *UserMutation) AddedPhone() (r int, exists bool) {
	v := m.addphone
	if v == nil {
		return
	}
	return *v, true
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.addphone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	m.addphone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetRole sets the "Role" field.
func (m *UserMutation) SetRole(s string) {
	m._Role = &s
}

// Role returns the value of the "Role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m._Role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "Role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "Role" field.
func (m *UserMutation) ResetRole() {
	m._Role = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m._Role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPassword:
		return m.Password()
	case user.FieldRole:
		return m.Role()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addphone != nil {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldPhone:
		return m.AddedPhone()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldPhone:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPhone(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
