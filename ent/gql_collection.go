// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"github.com/polatbilal/gqlgen-ent/ent/companydetail"
	"github.com/polatbilal/gqlgen-ent/ent/companyengineer"
	"github.com/polatbilal/gqlgen-ent/ent/companytoken"
	"github.com/polatbilal/gqlgen-ent/ent/jobauthor"
	"github.com/polatbilal/gqlgen-ent/ent/jobcontractor"
	"github.com/polatbilal/gqlgen-ent/ent/jobdetail"
	"github.com/polatbilal/gqlgen-ent/ent/joblayer"
	"github.com/polatbilal/gqlgen-ent/ent/jobowner"
	"github.com/polatbilal/gqlgen-ent/ent/jobpayments"
	"github.com/polatbilal/gqlgen-ent/ent/jobprogress"
	"github.com/polatbilal/gqlgen-ent/ent/jobreceipt"
	"github.com/polatbilal/gqlgen-ent/ent/jobrelations"
	"github.com/polatbilal/gqlgen-ent/ent/jobsupervisor"
	"github.com/polatbilal/gqlgen-ent/ent/user"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cdq *CompanyDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cdq, nil
	}
	if err := cdq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cdq, nil
}

func (cdq *CompanyDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companydetail.Columns))
		selectedFields = []string{companydetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "jobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: cdq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			cdq.WithNamedJobs(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: cdq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			cdq.WithNamedUsers(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})

		case "tokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyTokenClient{config: cdq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companytokenImplementors)...); err != nil {
				return err
			}
			cdq.WithNamedTokens(alias, func(wq *CompanyTokenQuery) {
				*wq = *query
			})

		case "engineers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: cdq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			cdq.WithNamedEngineers(alias, func(wq *CompanyEngineerQuery) {
				*wq = *query
			})
		case "companycode":
			if _, ok := fieldSeen[companydetail.FieldCompanyCode]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCompanyCode)
				fieldSeen[companydetail.FieldCompanyCode] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[companydetail.FieldName]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldName)
				fieldSeen[companydetail.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companydetail.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldAddress)
				fieldSeen[companydetail.FieldAddress] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companydetail.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldPhone)
				fieldSeen[companydetail.FieldPhone] = struct{}{}
			}
		case "fax":
			if _, ok := fieldSeen[companydetail.FieldFax]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldFax)
				fieldSeen[companydetail.FieldFax] = struct{}{}
			}
		case "mobilephone":
			if _, ok := fieldSeen[companydetail.FieldMobilePhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldMobilePhone)
				fieldSeen[companydetail.FieldMobilePhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companydetail.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldEmail)
				fieldSeen[companydetail.FieldEmail] = struct{}{}
			}
		case "website":
			if _, ok := fieldSeen[companydetail.FieldWebsite]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldWebsite)
				fieldSeen[companydetail.FieldWebsite] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[companydetail.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxAdmin)
				fieldSeen[companydetail.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[companydetail.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxNo)
				fieldSeen[companydetail.FieldTaxNo] = struct{}{}
			}
		case "chamberinfo":
			if _, ok := fieldSeen[companydetail.FieldChamberInfo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldChamberInfo)
				fieldSeen[companydetail.FieldChamberInfo] = struct{}{}
			}
		case "chamberregisterno":
			if _, ok := fieldSeen[companydetail.FieldChamberRegisterNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldChamberRegisterNo)
				fieldSeen[companydetail.FieldChamberRegisterNo] = struct{}{}
			}
		case "visadate":
			if _, ok := fieldSeen[companydetail.FieldVisaDate]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaDate)
				fieldSeen[companydetail.FieldVisaDate] = struct{}{}
			}
		case "visaenddate":
			if _, ok := fieldSeen[companydetail.FieldVisaEndDate]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaEndDate)
				fieldSeen[companydetail.FieldVisaEndDate] = struct{}{}
			}
		case "visafinishedfor90days":
			if _, ok := fieldSeen[companydetail.FieldVisaFinishedFor90Days]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaFinishedFor90Days)
				fieldSeen[companydetail.FieldVisaFinishedFor90Days] = struct{}{}
			}
		case "corepersonabsent90days":
			if _, ok := fieldSeen[companydetail.FieldCorePersonAbsent90Days]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCorePersonAbsent90Days)
				fieldSeen[companydetail.FieldCorePersonAbsent90Days] = struct{}{}
			}
		case "isclosed":
			if _, ok := fieldSeen[companydetail.FieldIsClosed]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldIsClosed)
				fieldSeen[companydetail.FieldIsClosed] = struct{}{}
			}
		case "ownername":
			if _, ok := fieldSeen[companydetail.FieldOwnerName]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerName)
				fieldSeen[companydetail.FieldOwnerName] = struct{}{}
			}
		case "ownertcno":
			if _, ok := fieldSeen[companydetail.FieldOwnerTcNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerTcNo)
				fieldSeen[companydetail.FieldOwnerTcNo] = struct{}{}
			}
		case "owneraddress":
			if _, ok := fieldSeen[companydetail.FieldOwnerAddress]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerAddress)
				fieldSeen[companydetail.FieldOwnerAddress] = struct{}{}
			}
		case "ownerphone":
			if _, ok := fieldSeen[companydetail.FieldOwnerPhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerPhone)
				fieldSeen[companydetail.FieldOwnerPhone] = struct{}{}
			}
		case "owneremail":
			if _, ok := fieldSeen[companydetail.FieldOwnerEmail]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerEmail)
				fieldSeen[companydetail.FieldOwnerEmail] = struct{}{}
			}
		case "ownerregisterno":
			if _, ok := fieldSeen[companydetail.FieldOwnerRegisterNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerRegisterNo)
				fieldSeen[companydetail.FieldOwnerRegisterNo] = struct{}{}
			}
		case "ownercareer":
			if _, ok := fieldSeen[companydetail.FieldOwnerCareer]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldOwnerCareer)
				fieldSeen[companydetail.FieldOwnerCareer] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companydetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCreatedAt)
				fieldSeen[companydetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companydetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldUpdatedAt)
				fieldSeen[companydetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cdq.Select(selectedFields...)
	}
	return nil
}

type companydetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyDetailPaginateOption
}

func newCompanyDetailPaginateArgs(rv map[string]any) *companydetailPaginateArgs {
	args := &companydetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ceq *CompanyEngineerQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyEngineerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ceq, nil
	}
	if err := ceq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ceq, nil
}

func (ceq *CompanyEngineerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companyengineer.Columns))
		selectedFields = []string{companyengineer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ceq.withCompany = query

		case "statics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedStatics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "mechanics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedMechanics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "electrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedElectrics(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "inspectors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedInspectors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "architects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedArchitects(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "controllers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedControllers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "mechaniccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedMechaniccontrollers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})

		case "electriccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: ceq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			ceq.WithNamedElectriccontrollers(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[companyengineer.FieldName]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldName)
				fieldSeen[companyengineer.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[companyengineer.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldTcNo)
				fieldSeen[companyengineer.FieldTcNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companyengineer.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPhone)
				fieldSeen[companyengineer.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companyengineer.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmail)
				fieldSeen[companyengineer.FieldEmail] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companyengineer.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldAddress)
				fieldSeen[companyengineer.FieldAddress] = struct{}{}
			}
		case "career":
			if _, ok := fieldSeen[companyengineer.FieldCareer]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCareer)
				fieldSeen[companyengineer.FieldCareer] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[companyengineer.FieldPosition]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPosition)
				fieldSeen[companyengineer.FieldPosition] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[companyengineer.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldRegisterNo)
				fieldSeen[companyengineer.FieldRegisterNo] = struct{}{}
			}
		case "certno":
			if _, ok := fieldSeen[companyengineer.FieldCertNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCertNo)
				fieldSeen[companyengineer.FieldCertNo] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[companyengineer.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldYDSID)
				fieldSeen[companyengineer.FieldYDSID] = struct{}{}
			}
		case "employment":
			if _, ok := fieldSeen[companyengineer.FieldEmployment]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmployment)
				fieldSeen[companyengineer.FieldEmployment] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[companyengineer.FieldStatus]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldStatus)
				fieldSeen[companyengineer.FieldStatus] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[companyengineer.FieldNote]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldNote)
				fieldSeen[companyengineer.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companyengineer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCreatedAt)
				fieldSeen[companyengineer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companyengineer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldUpdatedAt)
				fieldSeen[companyengineer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ceq.Select(selectedFields...)
	}
	return nil
}

type companyengineerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyEngineerPaginateOption
}

func newCompanyEngineerPaginateArgs(rv map[string]any) *companyengineerPaginateArgs {
	args := &companyengineerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ctq *CompanyTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ctq, nil
	}
	if err := ctq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ctq, nil
}

func (ctq *CompanyTokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companytoken.Columns))
		selectedFields = []string{companytoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ctq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ctq.withCompany = query
		case "ydkusername":
			if _, ok := fieldSeen[companytoken.FieldYDKUsername]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldYDKUsername)
				fieldSeen[companytoken.FieldYDKUsername] = struct{}{}
			}
		case "ydkpassword":
			if _, ok := fieldSeen[companytoken.FieldYDKPassword]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldYDKPassword)
				fieldSeen[companytoken.FieldYDKPassword] = struct{}{}
			}
		case "token":
			if _, ok := fieldSeen[companytoken.FieldToken]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldToken)
				fieldSeen[companytoken.FieldToken] = struct{}{}
			}
		case "departmentid":
			if _, ok := fieldSeen[companytoken.FieldDepartmentId]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldDepartmentId)
				fieldSeen[companytoken.FieldDepartmentId] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companytoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldCreatedAt)
				fieldSeen[companytoken.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companytoken.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companytoken.FieldUpdatedAt)
				fieldSeen[companytoken.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ctq.Select(selectedFields...)
	}
	return nil
}

type companytokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyTokenPaginateOption
}

func newCompanyTokenPaginateArgs(rv map[string]any) *companytokenPaginateArgs {
	args := &companytokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cuq *CompanyUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cuq, nil
	}
	if err := cuq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cuq, nil
}

func (cuq *CompanyUserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: cuq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			cuq.withCompany = query

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cuq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			cuq.withUser = query
		}
	}
	return nil
}

type companyuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyUserPaginateOption
}

func newCompanyUserPaginateArgs(rv map[string]any) *companyuserPaginateArgs {
	args := &companyuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jaq *JobAuthorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobAuthorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jaq, nil
	}
	if err := jaq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jaq, nil
}

func (jaq *JobAuthorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobauthor.Columns))
		selectedFields = []string{jobauthor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jaq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jaq.WithNamedAuthors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobauthor.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldYibfNo)
				fieldSeen[jobauthor.FieldYibfNo] = struct{}{}
			}
		case "static":
			if _, ok := fieldSeen[jobauthor.FieldStatic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldStatic)
				fieldSeen[jobauthor.FieldStatic] = struct{}{}
			}
		case "mechanic":
			if _, ok := fieldSeen[jobauthor.FieldMechanic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldMechanic)
				fieldSeen[jobauthor.FieldMechanic] = struct{}{}
			}
		case "electric":
			if _, ok := fieldSeen[jobauthor.FieldElectric]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldElectric)
				fieldSeen[jobauthor.FieldElectric] = struct{}{}
			}
		case "architect":
			if _, ok := fieldSeen[jobauthor.FieldArchitect]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldArchitect)
				fieldSeen[jobauthor.FieldArchitect] = struct{}{}
			}
		case "geotechnicalengineer":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalEngineer]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalEngineer)
				fieldSeen[jobauthor.FieldGeotechnicalEngineer] = struct{}{}
			}
		case "geotechnicalgeologist":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalGeologist]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalGeologist)
				fieldSeen[jobauthor.FieldGeotechnicalGeologist] = struct{}{}
			}
		case "geotechnicalgeophysicist":
			if _, ok := fieldSeen[jobauthor.FieldGeotechnicalGeophysicist]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldGeotechnicalGeophysicist)
				fieldSeen[jobauthor.FieldGeotechnicalGeophysicist] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobauthor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldCreatedAt)
				fieldSeen[jobauthor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobauthor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldUpdatedAt)
				fieldSeen[jobauthor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jaq.Select(selectedFields...)
	}
	return nil
}

type jobauthorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobAuthorPaginateOption
}

func newJobAuthorPaginateArgs(rv map[string]any) *jobauthorPaginateArgs {
	args := &jobauthorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jcq *JobContractorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobContractorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jcq, nil
	}
	if err := jcq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jcq, nil
}

func (jcq *JobContractorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobcontractor.Columns))
		selectedFields = []string{jobcontractor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "contractors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jcq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jcq.WithNamedContractors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobcontractor.FieldName]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldName)
				fieldSeen[jobcontractor.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobcontractor.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTcNo)
				fieldSeen[jobcontractor.FieldTcNo] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[jobcontractor.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldRegisterNo)
				fieldSeen[jobcontractor.FieldRegisterNo] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobcontractor.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldAddress)
				fieldSeen[jobcontractor.FieldAddress] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobcontractor.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTaxNo)
				fieldSeen[jobcontractor.FieldTaxNo] = struct{}{}
			}
		case "mobilephone":
			if _, ok := fieldSeen[jobcontractor.FieldMobilePhone]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldMobilePhone)
				fieldSeen[jobcontractor.FieldMobilePhone] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobcontractor.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldPhone)
				fieldSeen[jobcontractor.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobcontractor.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldEmail)
				fieldSeen[jobcontractor.FieldEmail] = struct{}{}
			}
		case "persontype":
			if _, ok := fieldSeen[jobcontractor.FieldPersonType]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldPersonType)
				fieldSeen[jobcontractor.FieldPersonType] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobcontractor.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldYDSID)
				fieldSeen[jobcontractor.FieldYDSID] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobcontractor.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldNote)
				fieldSeen[jobcontractor.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobcontractor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldCreatedAt)
				fieldSeen[jobcontractor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobcontractor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldUpdatedAt)
				fieldSeen[jobcontractor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jcq.Select(selectedFields...)
	}
	return nil
}

type jobcontractorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobContractorPaginateOption
}

func newJobContractorPaginateArgs(rv map[string]any) *jobcontractorPaginateArgs {
	args := &jobcontractorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jdq *JobDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jdq, nil
	}
	if err := jdq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jdq, nil
}

func (jdq *JobDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobdetail.Columns))
		selectedFields = []string{jobdetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "relations":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jdq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jdq.withRelations = query
		case "yibfno":
			if _, ok := fieldSeen[jobdetail.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldYibfNo)
				fieldSeen[jobdetail.FieldYibfNo] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[jobdetail.FieldTitle]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldTitle)
				fieldSeen[jobdetail.FieldTitle] = struct{}{}
			}
		case "administration":
			if _, ok := fieldSeen[jobdetail.FieldAdministration]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldAdministration)
				fieldSeen[jobdetail.FieldAdministration] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[jobdetail.FieldState]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldState)
				fieldSeen[jobdetail.FieldState] = struct{}{}
			}
		case "island":
			if _, ok := fieldSeen[jobdetail.FieldIsland]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsland)
				fieldSeen[jobdetail.FieldIsland] = struct{}{}
			}
		case "parcel":
			if _, ok := fieldSeen[jobdetail.FieldParcel]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldParcel)
				fieldSeen[jobdetail.FieldParcel] = struct{}{}
			}
		case "sheet":
			if _, ok := fieldSeen[jobdetail.FieldSheet]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldSheet)
				fieldSeen[jobdetail.FieldSheet] = struct{}{}
			}
		case "contractdate":
			if _, ok := fieldSeen[jobdetail.FieldContractDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldContractDate)
				fieldSeen[jobdetail.FieldContractDate] = struct{}{}
			}
		case "startdate":
			if _, ok := fieldSeen[jobdetail.FieldStartDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStartDate)
				fieldSeen[jobdetail.FieldStartDate] = struct{}{}
			}
		case "licensedate":
			if _, ok := fieldSeen[jobdetail.FieldLicenseDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseDate)
				fieldSeen[jobdetail.FieldLicenseDate] = struct{}{}
			}
		case "licenseno":
			if _, ok := fieldSeen[jobdetail.FieldLicenseNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseNo)
				fieldSeen[jobdetail.FieldLicenseNo] = struct{}{}
			}
		case "distributiondate":
			if _, ok := fieldSeen[jobdetail.FieldDistributionDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldDistributionDate)
				fieldSeen[jobdetail.FieldDistributionDate] = struct{}{}
			}
		case "completiondate":
			if _, ok := fieldSeen[jobdetail.FieldCompletionDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCompletionDate)
				fieldSeen[jobdetail.FieldCompletionDate] = struct{}{}
			}
		case "landarea":
			if _, ok := fieldSeen[jobdetail.FieldLandArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLandArea)
				fieldSeen[jobdetail.FieldLandArea] = struct{}{}
			}
		case "totalarea":
			if _, ok := fieldSeen[jobdetail.FieldTotalArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldTotalArea)
				fieldSeen[jobdetail.FieldTotalArea] = struct{}{}
			}
		case "constructionarea":
			if _, ok := fieldSeen[jobdetail.FieldConstructionArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldConstructionArea)
				fieldSeen[jobdetail.FieldConstructionArea] = struct{}{}
			}
		case "leftarea":
			if _, ok := fieldSeen[jobdetail.FieldLeftArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLeftArea)
				fieldSeen[jobdetail.FieldLeftArea] = struct{}{}
			}
		case "ydsaddress":
			if _, ok := fieldSeen[jobdetail.FieldYDSAddress]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldYDSAddress)
				fieldSeen[jobdetail.FieldYDSAddress] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobdetail.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldAddress)
				fieldSeen[jobdetail.FieldAddress] = struct{}{}
			}
		case "buildingclass":
			if _, ok := fieldSeen[jobdetail.FieldBuildingClass]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingClass)
				fieldSeen[jobdetail.FieldBuildingClass] = struct{}{}
			}
		case "buildingtype":
			if _, ok := fieldSeen[jobdetail.FieldBuildingType]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingType)
				fieldSeen[jobdetail.FieldBuildingType] = struct{}{}
			}
		case "level":
			if _, ok := fieldSeen[jobdetail.FieldLevel]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLevel)
				fieldSeen[jobdetail.FieldLevel] = struct{}{}
			}
		case "unitprice":
			if _, ok := fieldSeen[jobdetail.FieldUnitPrice]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUnitPrice)
				fieldSeen[jobdetail.FieldUnitPrice] = struct{}{}
			}
		case "floorcount":
			if _, ok := fieldSeen[jobdetail.FieldFloorCount]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFloorCount)
				fieldSeen[jobdetail.FieldFloorCount] = struct{}{}
			}
		case "bksreferenceno":
			if _, ok := fieldSeen[jobdetail.FieldBKSReferenceNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBKSReferenceNo)
				fieldSeen[jobdetail.FieldBKSReferenceNo] = struct{}{}
			}
		case "coordinates":
			if _, ok := fieldSeen[jobdetail.FieldCoordinates]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCoordinates)
				fieldSeen[jobdetail.FieldCoordinates] = struct{}{}
			}
		case "folderno":
			if _, ok := fieldSeen[jobdetail.FieldFolderNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFolderNo)
				fieldSeen[jobdetail.FieldFolderNo] = struct{}{}
			}
		case "uploadedfile":
			if _, ok := fieldSeen[jobdetail.FieldUploadedFile]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUploadedFile)
				fieldSeen[jobdetail.FieldUploadedFile] = struct{}{}
			}
		case "industryarea":
			if _, ok := fieldSeen[jobdetail.FieldIndustryArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIndustryArea)
				fieldSeen[jobdetail.FieldIndustryArea] = struct{}{}
			}
		case "clusterstructure":
			if _, ok := fieldSeen[jobdetail.FieldClusterStructure]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldClusterStructure)
				fieldSeen[jobdetail.FieldClusterStructure] = struct{}{}
			}
		case "islicenseexpired":
			if _, ok := fieldSeen[jobdetail.FieldIsLicenseExpired]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsLicenseExpired)
				fieldSeen[jobdetail.FieldIsLicenseExpired] = struct{}{}
			}
		case "iscompleted":
			if _, ok := fieldSeen[jobdetail.FieldIsCompleted]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIsCompleted)
				fieldSeen[jobdetail.FieldIsCompleted] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobdetail.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldNote)
				fieldSeen[jobdetail.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobdetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCreatedAt)
				fieldSeen[jobdetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobdetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUpdatedAt)
				fieldSeen[jobdetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jdq.Select(selectedFields...)
	}
	return nil
}

type jobdetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobDetailPaginateOption
}

func newJobDetailPaginateArgs(rv map[string]any) *jobdetailPaginateArgs {
	args := &jobdetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jlq *JobLayerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobLayerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jlq, nil
	}
	if err := jlq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jlq, nil
}

func (jlq *JobLayerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(joblayer.Columns))
		selectedFields = []string{joblayer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "layer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jlq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jlq.withLayer = query
		case "yibfno":
			if _, ok := fieldSeen[joblayer.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldYibfNo)
				fieldSeen[joblayer.FieldYibfNo] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[joblayer.FieldName]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldName)
				fieldSeen[joblayer.FieldName] = struct{}{}
			}
		case "metre":
			if _, ok := fieldSeen[joblayer.FieldMetre]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMetre)
				fieldSeen[joblayer.FieldMetre] = struct{}{}
			}
		case "molddate":
			if _, ok := fieldSeen[joblayer.FieldMoldDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMoldDate)
				fieldSeen[joblayer.FieldMoldDate] = struct{}{}
			}
		case "concretedate":
			if _, ok := fieldSeen[joblayer.FieldConcreteDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteDate)
				fieldSeen[joblayer.FieldConcreteDate] = struct{}{}
			}
		case "samples":
			if _, ok := fieldSeen[joblayer.FieldSamples]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldSamples)
				fieldSeen[joblayer.FieldSamples] = struct{}{}
			}
		case "concreteclass":
			if _, ok := fieldSeen[joblayer.FieldConcreteClass]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteClass)
				fieldSeen[joblayer.FieldConcreteClass] = struct{}{}
			}
		case "weekresult":
			if _, ok := fieldSeen[joblayer.FieldWeekResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldWeekResult)
				fieldSeen[joblayer.FieldWeekResult] = struct{}{}
			}
		case "monthresult":
			if _, ok := fieldSeen[joblayer.FieldMonthResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMonthResult)
				fieldSeen[joblayer.FieldMonthResult] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[joblayer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldCreatedAt)
				fieldSeen[joblayer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[joblayer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldUpdatedAt)
				fieldSeen[joblayer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jlq.Select(selectedFields...)
	}
	return nil
}

type joblayerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobLayerPaginateOption
}

func newJobLayerPaginateArgs(rv map[string]any) *joblayerPaginateArgs {
	args := &joblayerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (joq *JobOwnerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobOwnerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return joq, nil
	}
	if err := joq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return joq, nil
}

func (joq *JobOwnerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobowner.Columns))
		selectedFields = []string{jobowner.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: joq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			joq.WithNamedOwners(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobowner.FieldName]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldName)
				fieldSeen[jobowner.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobowner.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldAddress)
				fieldSeen[jobowner.FieldAddress] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobowner.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTcNo)
				fieldSeen[jobowner.FieldTcNo] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[jobowner.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxAdmin)
				fieldSeen[jobowner.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobowner.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxNo)
				fieldSeen[jobowner.FieldTaxNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobowner.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldPhone)
				fieldSeen[jobowner.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobowner.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldEmail)
				fieldSeen[jobowner.FieldEmail] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobowner.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldYDSID)
				fieldSeen[jobowner.FieldYDSID] = struct{}{}
			}
		case "shareholder":
			if _, ok := fieldSeen[jobowner.FieldShareholder]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldShareholder)
				fieldSeen[jobowner.FieldShareholder] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobowner.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldNote)
				fieldSeen[jobowner.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobowner.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldCreatedAt)
				fieldSeen[jobowner.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobowner.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldUpdatedAt)
				fieldSeen[jobowner.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		joq.Select(selectedFields...)
	}
	return nil
}

type jobownerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobOwnerPaginateOption
}

func newJobOwnerPaginateArgs(rv map[string]any) *jobownerPaginateArgs {
	args := &jobownerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jpq *JobPaymentsQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobPaymentsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jpq, nil
	}
	if err := jpq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jpq, nil
}

func (jpq *JobPaymentsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobpayments.Columns))
		selectedFields = []string{jobpayments.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jpq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jpq.withPayments = query
		case "yibfno":
			if _, ok := fieldSeen[jobpayments.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldYibfNo)
				fieldSeen[jobpayments.FieldYibfNo] = struct{}{}
			}
		case "paymentno":
			if _, ok := fieldSeen[jobpayments.FieldPaymentNo]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentNo)
				fieldSeen[jobpayments.FieldPaymentNo] = struct{}{}
			}
		case "paymentdate":
			if _, ok := fieldSeen[jobpayments.FieldPaymentDate]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentDate)
				fieldSeen[jobpayments.FieldPaymentDate] = struct{}{}
			}
		case "paymenttype":
			if _, ok := fieldSeen[jobpayments.FieldPaymentType]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPaymentType)
				fieldSeen[jobpayments.FieldPaymentType] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[jobpayments.FieldState]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldState)
				fieldSeen[jobpayments.FieldState] = struct{}{}
			}
		case "totalpayment":
			if _, ok := fieldSeen[jobpayments.FieldTotalPayment]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldTotalPayment)
				fieldSeen[jobpayments.FieldTotalPayment] = struct{}{}
			}
		case "levelrequest":
			if _, ok := fieldSeen[jobpayments.FieldLevelRequest]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldLevelRequest)
				fieldSeen[jobpayments.FieldLevelRequest] = struct{}{}
			}
		case "levelapprove":
			if _, ok := fieldSeen[jobpayments.FieldLevelApprove]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldLevelApprove)
				fieldSeen[jobpayments.FieldLevelApprove] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[jobpayments.FieldAmount]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldAmount)
				fieldSeen[jobpayments.FieldAmount] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobpayments.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldCreatedAt)
				fieldSeen[jobpayments.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobpayments.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldUpdatedAt)
				fieldSeen[jobpayments.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jpq.Select(selectedFields...)
	}
	return nil
}

type jobpaymentsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobPaymentsPaginateOption
}

func newJobPaymentsPaginateArgs(rv map[string]any) *jobpaymentsPaginateArgs {
	args := &jobpaymentsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jpq *JobProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jpq, nil
	}
	if err := jpq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jpq, nil
}

func (jpq *JobProgressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobprogress.Columns))
		selectedFields = []string{jobprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jpq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jpq.WithNamedProgress(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobprogress.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldYibfNo)
				fieldSeen[jobprogress.FieldYibfNo] = struct{}{}
			}
		case "one":
			if _, ok := fieldSeen[jobprogress.FieldOne]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldOne)
				fieldSeen[jobprogress.FieldOne] = struct{}{}
			}
		case "two":
			if _, ok := fieldSeen[jobprogress.FieldTwo]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldTwo)
				fieldSeen[jobprogress.FieldTwo] = struct{}{}
			}
		case "three":
			if _, ok := fieldSeen[jobprogress.FieldThree]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldThree)
				fieldSeen[jobprogress.FieldThree] = struct{}{}
			}
		case "four":
			if _, ok := fieldSeen[jobprogress.FieldFour]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFour)
				fieldSeen[jobprogress.FieldFour] = struct{}{}
			}
		case "five":
			if _, ok := fieldSeen[jobprogress.FieldFive]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFive)
				fieldSeen[jobprogress.FieldFive] = struct{}{}
			}
		case "six":
			if _, ok := fieldSeen[jobprogress.FieldSix]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldSix)
				fieldSeen[jobprogress.FieldSix] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldCreatedAt)
				fieldSeen[jobprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldUpdatedAt)
				fieldSeen[jobprogress.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jpq.Select(selectedFields...)
	}
	return nil
}

type jobprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobProgressPaginateOption
}

func newJobProgressPaginateArgs(rv map[string]any) *jobprogressPaginateArgs {
	args := &jobprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jrq *JobReceiptQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobReceiptQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jrq, nil
	}
	if err := jrq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jrq, nil
}

func (jrq *JobReceiptQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobreceipt.Columns))
		selectedFields = []string{jobreceipt.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "receipt":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jrq.withReceipt = query
		case "yibfno":
			if _, ok := fieldSeen[jobreceipt.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldYibfNo)
				fieldSeen[jobreceipt.FieldYibfNo] = struct{}{}
			}
		case "receiptdate":
			if _, ok := fieldSeen[jobreceipt.FieldReceiptDate]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldReceiptDate)
				fieldSeen[jobreceipt.FieldReceiptDate] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[jobreceipt.FieldAmount]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldAmount)
				fieldSeen[jobreceipt.FieldAmount] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobreceipt.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldNote)
				fieldSeen[jobreceipt.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobreceipt.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldCreatedAt)
				fieldSeen[jobreceipt.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobreceipt.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobreceipt.FieldUpdatedAt)
				fieldSeen[jobreceipt.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jrq.Select(selectedFields...)
	}
	return nil
}

type jobreceiptPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobReceiptPaginateOption
}

func newJobReceiptPaginateArgs(rv map[string]any) *jobreceiptPaginateArgs {
	args := &jobreceiptPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jrq *JobRelationsQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobRelationsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jrq, nil
	}
	if err := jrq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jrq, nil
}

func (jrq *JobRelationsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobrelations.Columns))
		selectedFields = []string{jobrelations.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jrq.withJob = query

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobOwnerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobownerImplementors)...); err != nil {
				return err
			}
			jrq.withOwner = query

		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobAuthorClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobauthorImplementors)...); err != nil {
				return err
			}
			jrq.withAuthor = query

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			jrq.withCompany = query

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobprogressImplementors)...); err != nil {
				return err
			}
			jrq.withProgress = query

		case "contractor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobContractorClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobcontractorImplementors)...); err != nil {
				return err
			}
			jrq.withContractor = query

		case "supervisor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobSupervisorClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobsupervisorImplementors)...); err != nil {
				return err
			}
			jrq.withSupervisor = query

		case "static":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withStatic = query

		case "mechanic":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withMechanic = query

		case "electric":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withElectric = query

		case "inspector":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withInspector = query

		case "architect":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withArchitect = query

		case "controller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withController = query

		case "mechaniccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withMechaniccontroller = query

		case "electriccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jrq.withElectriccontroller = query

		case "layers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobLayerClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, joblayerImplementors)...); err != nil {
				return err
			}
			jrq.WithNamedLayers(alias, func(wq *JobLayerQuery) {
				*wq = *query
			})

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobPaymentsClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobpaymentsImplementors)...); err != nil {
				return err
			}
			jrq.WithNamedPayments(alias, func(wq *JobPaymentsQuery) {
				*wq = *query
			})

		case "receipts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobReceiptClient{config: jrq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobreceiptImplementors)...); err != nil {
				return err
			}
			jrq.WithNamedReceipts(alias, func(wq *JobReceiptQuery) {
				*wq = *query
			})
		case "yibfno":
			if _, ok := fieldSeen[jobrelations.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldYibfNo)
				fieldSeen[jobrelations.FieldYibfNo] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobrelations.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldCreatedAt)
				fieldSeen[jobrelations.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobrelations.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobrelations.FieldUpdatedAt)
				fieldSeen[jobrelations.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jrq.Select(selectedFields...)
	}
	return nil
}

type jobrelationsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobRelationsPaginateOption
}

func newJobRelationsPaginateArgs(rv map[string]any) *jobrelationsPaginateArgs {
	args := &jobrelationsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jsq *JobSupervisorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobSupervisorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jsq, nil
	}
	if err := jsq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jsq, nil
}

func (jsq *JobSupervisorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobsupervisor.Columns))
		selectedFields = []string{jobsupervisor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "supervisors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobRelationsClient{config: jsq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobrelationsImplementors)...); err != nil {
				return err
			}
			jsq.WithNamedSupervisors(alias, func(wq *JobRelationsQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobsupervisor.FieldName]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldName)
				fieldSeen[jobsupervisor.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobsupervisor.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldAddress)
				fieldSeen[jobsupervisor.FieldAddress] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobsupervisor.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldPhone)
				fieldSeen[jobsupervisor.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobsupervisor.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldEmail)
				fieldSeen[jobsupervisor.FieldEmail] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobsupervisor.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldTcNo)
				fieldSeen[jobsupervisor.FieldTcNo] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[jobsupervisor.FieldPosition]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldPosition)
				fieldSeen[jobsupervisor.FieldPosition] = struct{}{}
			}
		case "career":
			if _, ok := fieldSeen[jobsupervisor.FieldCareer]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldCareer)
				fieldSeen[jobsupervisor.FieldCareer] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[jobsupervisor.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldRegisterNo)
				fieldSeen[jobsupervisor.FieldRegisterNo] = struct{}{}
			}
		case "socialsecurityno":
			if _, ok := fieldSeen[jobsupervisor.FieldSocialSecurityNo]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldSocialSecurityNo)
				fieldSeen[jobsupervisor.FieldSocialSecurityNo] = struct{}{}
			}
		case "schoolgraduation":
			if _, ok := fieldSeen[jobsupervisor.FieldSchoolGraduation]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldSchoolGraduation)
				fieldSeen[jobsupervisor.FieldSchoolGraduation] = struct{}{}
			}
		case "ydsid":
			if _, ok := fieldSeen[jobsupervisor.FieldYDSID]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldYDSID)
				fieldSeen[jobsupervisor.FieldYDSID] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobsupervisor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldCreatedAt)
				fieldSeen[jobsupervisor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobsupervisor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobsupervisor.FieldUpdatedAt)
				fieldSeen[jobsupervisor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jsq.Select(selectedFields...)
	}
	return nil
}

type jobsupervisorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobSupervisorPaginateOption
}

func newJobSupervisorPaginateArgs(rv map[string]any) *jobsupervisorPaginateArgs {
	args := &jobsupervisorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uq *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uq, nil
	}
	if err := uq.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uq, nil
}

func (uq *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "companies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: uq.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			uq.WithNamedCompanies(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[user.FieldPhone]; !ok {
				selectedFields = append(selectedFields, user.FieldPhone)
				fieldSeen[user.FieldPhone] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[user.FieldPassword]; !ok {
				selectedFields = append(selectedFields, user.FieldPassword)
				fieldSeen[user.FieldPassword] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "refreshtoken":
			if _, ok := fieldSeen[user.FieldRefreshToken]; !ok {
				selectedFields = append(selectedFields, user.FieldRefreshToken)
				fieldSeen[user.FieldRefreshToken] = struct{}{}
			}
		case "refreshtokenexpireat":
			if _, ok := fieldSeen[user.FieldRefreshTokenExpireAt]; !ok {
				selectedFields = append(selectedFields, user.FieldRefreshTokenExpireAt)
				fieldSeen[user.FieldRefreshTokenExpireAt] = struct{}{}
			}
		case "licenseexpiredate":
			if _, ok := fieldSeen[user.FieldLicenseExpireDate]; !ok {
				selectedFields = append(selectedFields, user.FieldLicenseExpireDate)
				fieldSeen[user.FieldLicenseExpireDate] = struct{}{}
			}
		case "lastlogin":
			if _, ok := fieldSeen[user.FieldLastLogin]; !ok {
				selectedFields = append(selectedFields, user.FieldLastLogin)
				fieldSeen[user.FieldLastLogin] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[user.FieldActive]; !ok {
				selectedFields = append(selectedFields, user.FieldActive)
				fieldSeen[user.FieldActive] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uq.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok || v == nil {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
