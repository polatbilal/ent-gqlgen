// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"gqlgen-ent/ent/companydetail"
	"gqlgen-ent/ent/companyengineer"
	"gqlgen-ent/ent/jobauthor"
	"gqlgen-ent/ent/jobcontractor"
	"gqlgen-ent/ent/jobdetail"
	"gqlgen-ent/ent/joblayer"
	"gqlgen-ent/ent/jobowner"
	"gqlgen-ent/ent/jobpayments"
	"gqlgen-ent/ent/jobprogress"
	"gqlgen-ent/ent/user"

	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cd *CompanyDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cd, nil
	}
	if err := cd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cd, nil
}

func (cd *CompanyDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companydetail.Columns))
		selectedFields = []string{companydetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "companyowner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			cd.withCompanyOwner = query

		case "engineers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			cd.WithNamedEngineers(alias, func(wq *CompanyEngineerQuery) {
				*wq = *query
			})

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			cd.WithNamedUsers(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})

		case "jobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			cd.WithNamedJobs(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "companycode":
			if _, ok := fieldSeen[companydetail.FieldCompanyCode]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCompanyCode)
				fieldSeen[companydetail.FieldCompanyCode] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[companydetail.FieldName]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldName)
				fieldSeen[companydetail.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companydetail.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldAddress)
				fieldSeen[companydetail.FieldAddress] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[companydetail.FieldCity]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCity)
				fieldSeen[companydetail.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[companydetail.FieldState]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldState)
				fieldSeen[companydetail.FieldState] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companydetail.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldPhone)
				fieldSeen[companydetail.FieldPhone] = struct{}{}
			}
		case "fax":
			if _, ok := fieldSeen[companydetail.FieldFax]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldFax)
				fieldSeen[companydetail.FieldFax] = struct{}{}
			}
		case "mobile":
			if _, ok := fieldSeen[companydetail.FieldMobile]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldMobile)
				fieldSeen[companydetail.FieldMobile] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companydetail.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldEmail)
				fieldSeen[companydetail.FieldEmail] = struct{}{}
			}
		case "website":
			if _, ok := fieldSeen[companydetail.FieldWebsite]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldWebsite)
				fieldSeen[companydetail.FieldWebsite] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[companydetail.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxAdmin)
				fieldSeen[companydetail.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[companydetail.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldTaxNo)
				fieldSeen[companydetail.FieldTaxNo] = struct{}{}
			}
		case "commerce":
			if _, ok := fieldSeen[companydetail.FieldCommerce]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCommerce)
				fieldSeen[companydetail.FieldCommerce] = struct{}{}
			}
		case "commercereg":
			if _, ok := fieldSeen[companydetail.FieldCommerceReg]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCommerceReg)
				fieldSeen[companydetail.FieldCommerceReg] = struct{}{}
			}
		case "visadate":
			if _, ok := fieldSeen[companydetail.FieldVisaDate]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldVisaDate)
				fieldSeen[companydetail.FieldVisaDate] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companydetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldCreatedAt)
				fieldSeen[companydetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companydetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companydetail.FieldUpdatedAt)
				fieldSeen[companydetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cd.Select(selectedFields...)
	}
	return nil
}

type companydetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyDetailPaginateOption
}

func newCompanyDetailPaginateArgs(rv map[string]any) *companydetailPaginateArgs {
	args := &companydetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ce *CompanyEngineerQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyEngineerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ce, nil
	}
	if err := ce.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ce, nil
}

func (ce *CompanyEngineerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(companyengineer.Columns))
		selectedFields = []string{companyengineer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ce.withCompany = query

		case "companyowners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedCompanyOwners(alias, func(wq *CompanyDetailQuery) {
				*wq = *query
			})

		case "inspectors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedInspectors(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "architects":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedArchitects(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "statics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedStatics(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "mechanics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedMechanics(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "electrics":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedElectrics(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "controllers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedControllers(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "mechaniccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedMechaniccontrollers(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})

		case "electriccontrollers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ce.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ce.WithNamedElectriccontrollers(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[companyengineer.FieldName]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldName)
				fieldSeen[companyengineer.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[companyengineer.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldTcNo)
				fieldSeen[companyengineer.FieldTcNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[companyengineer.FieldPhone]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPhone)
				fieldSeen[companyengineer.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[companyengineer.FieldEmail]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmail)
				fieldSeen[companyengineer.FieldEmail] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[companyengineer.FieldAddress]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldAddress)
				fieldSeen[companyengineer.FieldAddress] = struct{}{}
			}
		case "career":
			if _, ok := fieldSeen[companyengineer.FieldCareer]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCareer)
				fieldSeen[companyengineer.FieldCareer] = struct{}{}
			}
		case "position":
			if _, ok := fieldSeen[companyengineer.FieldPosition]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldPosition)
				fieldSeen[companyengineer.FieldPosition] = struct{}{}
			}
		case "regno":
			if _, ok := fieldSeen[companyengineer.FieldRegNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldRegNo)
				fieldSeen[companyengineer.FieldRegNo] = struct{}{}
			}
		case "certno":
			if _, ok := fieldSeen[companyengineer.FieldCertNo]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCertNo)
				fieldSeen[companyengineer.FieldCertNo] = struct{}{}
			}
		case "ydsID":
			if _, ok := fieldSeen[companyengineer.FieldYdsID]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldYdsID)
				fieldSeen[companyengineer.FieldYdsID] = struct{}{}
			}
		case "employment":
			if _, ok := fieldSeen[companyengineer.FieldEmployment]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldEmployment)
				fieldSeen[companyengineer.FieldEmployment] = struct{}{}
			}
		case "dismissal":
			if _, ok := fieldSeen[companyengineer.FieldDismissal]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldDismissal)
				fieldSeen[companyengineer.FieldDismissal] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[companyengineer.FieldStatus]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldStatus)
				fieldSeen[companyengineer.FieldStatus] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[companyengineer.FieldNote]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldNote)
				fieldSeen[companyengineer.FieldNote] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[companyengineer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldCreatedAt)
				fieldSeen[companyengineer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[companyengineer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, companyengineer.FieldUpdatedAt)
				fieldSeen[companyengineer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ce.Select(selectedFields...)
	}
	return nil
}

type companyengineerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyEngineerPaginateOption
}

func newCompanyEngineerPaginateArgs(rv map[string]any) *companyengineerPaginateArgs {
	args := &companyengineerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cu *CompanyUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*CompanyUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cu, nil
	}
	if err := cu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cu, nil
}

func (cu *CompanyUserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			cu.withCompany = query

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			cu.withUser = query
		}
	}
	return nil
}

type companyuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CompanyUserPaginateOption
}

func newCompanyUserPaginateArgs(rv map[string]any) *companyuserPaginateArgs {
	args := &companyuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ja *JobAuthorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobAuthorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ja, nil
	}
	if err := ja.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ja, nil
}

func (ja *JobAuthorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobauthor.Columns))
		selectedFields = []string{jobauthor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "authors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: ja.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			ja.WithNamedAuthors(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "architect":
			if _, ok := fieldSeen[jobauthor.FieldArchitect]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldArchitect)
				fieldSeen[jobauthor.FieldArchitect] = struct{}{}
			}
		case "static":
			if _, ok := fieldSeen[jobauthor.FieldStatic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldStatic)
				fieldSeen[jobauthor.FieldStatic] = struct{}{}
			}
		case "mechanic":
			if _, ok := fieldSeen[jobauthor.FieldMechanic]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldMechanic)
				fieldSeen[jobauthor.FieldMechanic] = struct{}{}
			}
		case "electric":
			if _, ok := fieldSeen[jobauthor.FieldElectric]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldElectric)
				fieldSeen[jobauthor.FieldElectric] = struct{}{}
			}
		case "floor":
			if _, ok := fieldSeen[jobauthor.FieldFloor]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldFloor)
				fieldSeen[jobauthor.FieldFloor] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobauthor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldCreatedAt)
				fieldSeen[jobauthor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobauthor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobauthor.FieldUpdatedAt)
				fieldSeen[jobauthor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ja.Select(selectedFields...)
	}
	return nil
}

type jobauthorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobAuthorPaginateOption
}

func newJobAuthorPaginateArgs(rv map[string]any) *jobauthorPaginateArgs {
	args := &jobauthorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jc *JobContractorQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobContractorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jc, nil
	}
	if err := jc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jc, nil
}

func (jc *JobContractorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobcontractor.Columns))
		selectedFields = []string{jobcontractor.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "contractors":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jc.WithNamedContractors(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobcontractor.FieldName]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldName)
				fieldSeen[jobcontractor.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobcontractor.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTcNo)
				fieldSeen[jobcontractor.FieldTcNo] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobcontractor.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldAddress)
				fieldSeen[jobcontractor.FieldAddress] = struct{}{}
			}
		case "registerno":
			if _, ok := fieldSeen[jobcontractor.FieldRegisterNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldRegisterNo)
				fieldSeen[jobcontractor.FieldRegisterNo] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[jobcontractor.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTaxAdmin)
				fieldSeen[jobcontractor.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobcontractor.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldTaxNo)
				fieldSeen[jobcontractor.FieldTaxNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobcontractor.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldPhone)
				fieldSeen[jobcontractor.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobcontractor.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldEmail)
				fieldSeen[jobcontractor.FieldEmail] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobcontractor.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldNote)
				fieldSeen[jobcontractor.FieldNote] = struct{}{}
			}
		case "deleted":
			if _, ok := fieldSeen[jobcontractor.FieldDeleted]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldDeleted)
				fieldSeen[jobcontractor.FieldDeleted] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobcontractor.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldCreatedAt)
				fieldSeen[jobcontractor.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobcontractor.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobcontractor.FieldUpdatedAt)
				fieldSeen[jobcontractor.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jc.Select(selectedFields...)
	}
	return nil
}

type jobcontractorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobContractorPaginateOption
}

func newJobContractorPaginateArgs(rv map[string]any) *jobcontractorPaginateArgs {
	args := &jobcontractorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jd *JobDetailQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobDetailQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jd, nil
	}
	if err := jd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jd, nil
}

func (jd *JobDetailQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobdetail.Columns))
		selectedFields = []string{jobdetail.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobOwnerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobownerImplementors)...); err != nil {
				return err
			}
			jd.withOwner = query

		case "contractor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobContractorClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobcontractorImplementors)...); err != nil {
				return err
			}
			jd.withContractor = query

		case "author":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobAuthorClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobauthorImplementors)...); err != nil {
				return err
			}
			jd.withAuthor = query

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobprogressImplementors)...); err != nil {
				return err
			}
			jd.withProgress = query

		case "inspector":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withInspector = query

		case "architect":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withArchitect = query

		case "static":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withStatic = query

		case "mechanic":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withMechanic = query

		case "electric":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withElectric = query

		case "controller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withController = query

		case "mechaniccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withMechaniccontroller = query

		case "electriccontroller":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyEngineerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companyengineerImplementors)...); err != nil {
				return err
			}
			jd.withElectriccontroller = query

		case "layers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobLayerClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, joblayerImplementors)...); err != nil {
				return err
			}
			jd.WithNamedLayers(alias, func(wq *JobLayerQuery) {
				*wq = *query
			})

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobPaymentsClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobpaymentsImplementors)...); err != nil {
				return err
			}
			jd.WithNamedPayments(alias, func(wq *JobPaymentsQuery) {
				*wq = *query
			})

		case "company":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyDetailClient{config: jd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, companydetailImplementors)...); err != nil {
				return err
			}
			jd.withCompany = query
		case "yibfno":
			if _, ok := fieldSeen[jobdetail.FieldYibfNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldYibfNo)
				fieldSeen[jobdetail.FieldYibfNo] = struct{}{}
			}
		case "idare":
			if _, ok := fieldSeen[jobdetail.FieldIdare]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldIdare)
				fieldSeen[jobdetail.FieldIdare] = struct{}{}
			}
		case "pafta":
			if _, ok := fieldSeen[jobdetail.FieldPafta]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldPafta)
				fieldSeen[jobdetail.FieldPafta] = struct{}{}
			}
		case "ada":
			if _, ok := fieldSeen[jobdetail.FieldAda]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldAda)
				fieldSeen[jobdetail.FieldAda] = struct{}{}
			}
		case "parsel":
			if _, ok := fieldSeen[jobdetail.FieldParsel]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldParsel)
				fieldSeen[jobdetail.FieldParsel] = struct{}{}
			}
		case "folderno":
			if _, ok := fieldSeen[jobdetail.FieldFolderNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFolderNo)
				fieldSeen[jobdetail.FieldFolderNo] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[jobdetail.FieldStatus]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStatus)
				fieldSeen[jobdetail.FieldStatus] = struct{}{}
			}
		case "contractdate":
			if _, ok := fieldSeen[jobdetail.FieldContractDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldContractDate)
				fieldSeen[jobdetail.FieldContractDate] = struct{}{}
			}
		case "completiondate":
			if _, ok := fieldSeen[jobdetail.FieldCompletionDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCompletionDate)
				fieldSeen[jobdetail.FieldCompletionDate] = struct{}{}
			}
		case "startdate":
			if _, ok := fieldSeen[jobdetail.FieldStartDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStartDate)
				fieldSeen[jobdetail.FieldStartDate] = struct{}{}
			}
		case "licensedate":
			if _, ok := fieldSeen[jobdetail.FieldLicenseDate]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseDate)
				fieldSeen[jobdetail.FieldLicenseDate] = struct{}{}
			}
		case "licenseno":
			if _, ok := fieldSeen[jobdetail.FieldLicenseNo]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLicenseNo)
				fieldSeen[jobdetail.FieldLicenseNo] = struct{}{}
			}
		case "constructionarea":
			if _, ok := fieldSeen[jobdetail.FieldConstructionArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldConstructionArea)
				fieldSeen[jobdetail.FieldConstructionArea] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[jobdetail.FieldCity]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCity)
				fieldSeen[jobdetail.FieldCity] = struct{}{}
			}
		case "district":
			if _, ok := fieldSeen[jobdetail.FieldDistrict]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldDistrict)
				fieldSeen[jobdetail.FieldDistrict] = struct{}{}
			}
		case "village":
			if _, ok := fieldSeen[jobdetail.FieldVillage]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldVillage)
				fieldSeen[jobdetail.FieldVillage] = struct{}{}
			}
		case "street":
			if _, ok := fieldSeen[jobdetail.FieldStreet]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStreet)
				fieldSeen[jobdetail.FieldStreet] = struct{}{}
			}
		case "buildingclass":
			if _, ok := fieldSeen[jobdetail.FieldBuildingClass]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingClass)
				fieldSeen[jobdetail.FieldBuildingClass] = struct{}{}
			}
		case "buildingtype":
			if _, ok := fieldSeen[jobdetail.FieldBuildingType]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingType)
				fieldSeen[jobdetail.FieldBuildingType] = struct{}{}
			}
		case "buildingblock":
			if _, ok := fieldSeen[jobdetail.FieldBuildingBlock]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldBuildingBlock)
				fieldSeen[jobdetail.FieldBuildingBlock] = struct{}{}
			}
		case "landarea":
			if _, ok := fieldSeen[jobdetail.FieldLandArea]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldLandArea)
				fieldSeen[jobdetail.FieldLandArea] = struct{}{}
			}
		case "floors":
			if _, ok := fieldSeen[jobdetail.FieldFloors]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldFloors)
				fieldSeen[jobdetail.FieldFloors] = struct{}{}
			}
		case "usagepurpose":
			if _, ok := fieldSeen[jobdetail.FieldUsagePurpose]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUsagePurpose)
				fieldSeen[jobdetail.FieldUsagePurpose] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobdetail.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldNote)
				fieldSeen[jobdetail.FieldNote] = struct{}{}
			}
		case "started":
			if _, ok := fieldSeen[jobdetail.FieldStarted]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldStarted)
				fieldSeen[jobdetail.FieldStarted] = struct{}{}
			}
		case "deleted":
			if _, ok := fieldSeen[jobdetail.FieldDeleted]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldDeleted)
				fieldSeen[jobdetail.FieldDeleted] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobdetail.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldCreatedAt)
				fieldSeen[jobdetail.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobdetail.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobdetail.FieldUpdatedAt)
				fieldSeen[jobdetail.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jd.Select(selectedFields...)
	}
	return nil
}

type jobdetailPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobDetailPaginateOption
}

func newJobDetailPaginateArgs(rv map[string]any) *jobdetailPaginateArgs {
	args := &jobdetailPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jl *JobLayerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobLayerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jl, nil
	}
	if err := jl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jl, nil
}

func (jl *JobLayerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(joblayer.Columns))
		selectedFields = []string{joblayer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "layer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jl.withLayer = query
		case "name":
			if _, ok := fieldSeen[joblayer.FieldName]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldName)
				fieldSeen[joblayer.FieldName] = struct{}{}
			}
		case "metre":
			if _, ok := fieldSeen[joblayer.FieldMetre]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMetre)
				fieldSeen[joblayer.FieldMetre] = struct{}{}
			}
		case "molddate":
			if _, ok := fieldSeen[joblayer.FieldMoldDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMoldDate)
				fieldSeen[joblayer.FieldMoldDate] = struct{}{}
			}
		case "concretedate":
			if _, ok := fieldSeen[joblayer.FieldConcreteDate]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteDate)
				fieldSeen[joblayer.FieldConcreteDate] = struct{}{}
			}
		case "samples":
			if _, ok := fieldSeen[joblayer.FieldSamples]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldSamples)
				fieldSeen[joblayer.FieldSamples] = struct{}{}
			}
		case "concreteclass":
			if _, ok := fieldSeen[joblayer.FieldConcreteClass]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldConcreteClass)
				fieldSeen[joblayer.FieldConcreteClass] = struct{}{}
			}
		case "weekresult":
			if _, ok := fieldSeen[joblayer.FieldWeekResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldWeekResult)
				fieldSeen[joblayer.FieldWeekResult] = struct{}{}
			}
		case "monthresult":
			if _, ok := fieldSeen[joblayer.FieldMonthResult]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldMonthResult)
				fieldSeen[joblayer.FieldMonthResult] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[joblayer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldCreatedAt)
				fieldSeen[joblayer.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[joblayer.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, joblayer.FieldUpdatedAt)
				fieldSeen[joblayer.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jl.Select(selectedFields...)
	}
	return nil
}

type joblayerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobLayerPaginateOption
}

func newJobLayerPaginateArgs(rv map[string]any) *joblayerPaginateArgs {
	args := &joblayerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jo *JobOwnerQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobOwnerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jo, nil
	}
	if err := jo.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jo, nil
}

func (jo *JobOwnerQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobowner.Columns))
		selectedFields = []string{jobowner.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "owners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jo.WithNamedOwners(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[jobowner.FieldName]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldName)
				fieldSeen[jobowner.FieldName] = struct{}{}
			}
		case "tcno":
			if _, ok := fieldSeen[jobowner.FieldTcNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTcNo)
				fieldSeen[jobowner.FieldTcNo] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[jobowner.FieldAddress]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldAddress)
				fieldSeen[jobowner.FieldAddress] = struct{}{}
			}
		case "taxadmin":
			if _, ok := fieldSeen[jobowner.FieldTaxAdmin]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxAdmin)
				fieldSeen[jobowner.FieldTaxAdmin] = struct{}{}
			}
		case "taxno":
			if _, ok := fieldSeen[jobowner.FieldTaxNo]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldTaxNo)
				fieldSeen[jobowner.FieldTaxNo] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[jobowner.FieldPhone]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldPhone)
				fieldSeen[jobowner.FieldPhone] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[jobowner.FieldEmail]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldEmail)
				fieldSeen[jobowner.FieldEmail] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobowner.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldNote)
				fieldSeen[jobowner.FieldNote] = struct{}{}
			}
		case "deleted":
			if _, ok := fieldSeen[jobowner.FieldDeleted]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldDeleted)
				fieldSeen[jobowner.FieldDeleted] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobowner.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldCreatedAt)
				fieldSeen[jobowner.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobowner.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobowner.FieldUpdatedAt)
				fieldSeen[jobowner.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jo.Select(selectedFields...)
	}
	return nil
}

type jobownerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobOwnerPaginateOption
}

func newJobOwnerPaginateArgs(rv map[string]any) *jobownerPaginateArgs {
	args := &jobownerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jp *JobPaymentsQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobPaymentsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jp, nil
	}
	if err := jp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jp, nil
}

func (jp *JobPaymentsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobpayments.Columns))
		selectedFields = []string{jobpayments.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jp.withPayments = query
		case "date":
			if _, ok := fieldSeen[jobpayments.FieldDate]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldDate)
				fieldSeen[jobpayments.FieldDate] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[jobpayments.FieldAmount]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldAmount)
				fieldSeen[jobpayments.FieldAmount] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[jobpayments.FieldDescription]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldDescription)
				fieldSeen[jobpayments.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[jobpayments.FieldStatus]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldStatus)
				fieldSeen[jobpayments.FieldStatus] = struct{}{}
			}
		case "percentage":
			if _, ok := fieldSeen[jobpayments.FieldPercentage]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldPercentage)
				fieldSeen[jobpayments.FieldPercentage] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobpayments.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldCreatedAt)
				fieldSeen[jobpayments.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobpayments.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobpayments.FieldUpdatedAt)
				fieldSeen[jobpayments.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jp.Select(selectedFields...)
	}
	return nil
}

type jobpaymentsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobPaymentsPaginateOption
}

func newJobPaymentsPaginateArgs(rv map[string]any) *jobpaymentsPaginateArgs {
	args := &jobpaymentsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jp *JobProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jp, nil
	}
	if err := jp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jp, nil
}

func (jp *JobProgressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobprogress.Columns))
		selectedFields = []string{jobprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "progress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDetailClient{config: jp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, jobdetailImplementors)...); err != nil {
				return err
			}
			jp.WithNamedProgress(alias, func(wq *JobDetailQuery) {
				*wq = *query
			})
		case "one":
			if _, ok := fieldSeen[jobprogress.FieldOne]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldOne)
				fieldSeen[jobprogress.FieldOne] = struct{}{}
			}
		case "two":
			if _, ok := fieldSeen[jobprogress.FieldTwo]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldTwo)
				fieldSeen[jobprogress.FieldTwo] = struct{}{}
			}
		case "three":
			if _, ok := fieldSeen[jobprogress.FieldThree]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldThree)
				fieldSeen[jobprogress.FieldThree] = struct{}{}
			}
		case "four":
			if _, ok := fieldSeen[jobprogress.FieldFour]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFour)
				fieldSeen[jobprogress.FieldFour] = struct{}{}
			}
		case "five":
			if _, ok := fieldSeen[jobprogress.FieldFive]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldFive)
				fieldSeen[jobprogress.FieldFive] = struct{}{}
			}
		case "six":
			if _, ok := fieldSeen[jobprogress.FieldSix]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldSix)
				fieldSeen[jobprogress.FieldSix] = struct{}{}
			}
		case "createdat":
			if _, ok := fieldSeen[jobprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldCreatedAt)
				fieldSeen[jobprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedat":
			if _, ok := fieldSeen[jobprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogress.FieldUpdatedAt)
				fieldSeen[jobprogress.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jp.Select(selectedFields...)
	}
	return nil
}

type jobprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobProgressPaginateOption
}

func newJobProgressPaginateArgs(rv map[string]any) *jobprogressPaginateArgs {
	args := &jobprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "companies":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CompanyUserClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, companyuserImplementors)...); err != nil {
				return err
			}
			u.WithNamedCompanies(alias, func(wq *CompanyUserQuery) {
				*wq = *query
			})
		case "username":
			if _, ok := fieldSeen[user.FieldUsername]; !ok {
				selectedFields = append(selectedFields, user.FieldUsername)
				fieldSeen[user.FieldUsername] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[user.FieldPhone]; !ok {
				selectedFields = append(selectedFields, user.FieldPhone)
				fieldSeen[user.FieldPhone] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[user.FieldPassword]; !ok {
				selectedFields = append(selectedFields, user.FieldPassword)
				fieldSeen[user.FieldPassword] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
